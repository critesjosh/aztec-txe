{"noir_version":"0.33.0+61d6f251ea67204af2d17175f120e17f2e9e9156","name":"Vanhelsing","functions":[{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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9+Tr9+U//nuftevrftrAuR73366o7jfwvuO63+37juveGvQd172P6Dru4d509B3XvUPpO657O9N3XPfep++4kmvcXK7qyOWqjlyu6sjlqo5UrmqdUrmqdUrlqtYplatap1Suap0k17ipXNU6pXJV65TKVa1TKle1Trlc1ZzLVc25XNWcy1XNuVzVLLnGzeWq5lyuas7lqspY+26Zt3PhH/8p93HH2nfVccfad9Vxx9p31XHH2nfVccfad9Vxx9p31XHH2nfVccdqM9Rxx2oztHGXXK5qyeWqllyuasnlqnqcsBxp3FyuasnlqpZcrmrJ5aqWXK5KcrkqyeWqJJerklyuqscJy5HGzeWqJJerklyuSnK5KsnlqlbvG1H58pXcUuSn6z8n8L636BN4v6H82tkyr6//nNj7PaX/xN5vK90n3rzntf4Te49s/Sf2ntr6T+x+v+w+sfv9tfvE3uNb/4m9J7j+E6fzXFs6z7Wl81x7Os+1p/NcezrP5f4w0v4TS7qJ03ku94ej9p94LM9VynWec1nmRxF7VqvuT17tPO5YbquUfXqMezshe3V/nugvjrsu53HjH/9Z7+OOtQer4461AavjjrX7quOOtfWq4w6272rjDrbvauMOtu8q47o/1rTzuGP1G+q4uVyV+2NNO4+by2a4P+ez87ipbMbm/iTIXxy31iveH9P0ddz7xcrrozb3x0Zashlsi+vKZrD9sCsbgU2TzWDGoiubwVxIVzaDWZaubAarUbqyGaxz6cnG/fGHb2RTy7mSWu6Jwf1JiWZk3J9D90Yyx/VY9bif0Le5P7LOjkzif03zNE+Pz17ubBL7YZVNYj+ssknsh1U2if2wyiaxH9bYuD8NzpJNYnejskncE6tsEmdMlY1kZrNfU35MfGeT2hcrbFL7YoVNal+ssEntixU2qX3xazbuz/OzZJPaFytsUvtihU1qX6ywEdg02eCL22zwxW02+OI2G3xxmw2+uMlmxRe32eCL22wy++IvU349YvNik9kXa2wENk02mX2xxiazL9bYZPbFGpvMvlhjk9kXK2wGO0+4L5vMvlhjgy9us8EXt9kIbJps8MVtNvjiNht8cZsNvrjJZrAzb3+Rzfpgs+53Nqn3cIVN6nvx47NLne9sUt+LFTap78UKm9QdxWs2NXVHobBJ3VEobFL7G4VNan+jsBHYNNmk7igU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6ev9rJOz9zM7ez/N2ftZnL0fZ5/Pq7PP59XZ5/Pq7PN5dfb5vDr7fN6cfT5vzj6fN2efz5uzz+fN2edz/2jWr3/H4//rmJY73868yPMvz8v6evXXqvR4P4ez93P6ej/9s0AN38/s7P00Z+9ncfZ+xNn7WZ29n83Z+3H2+bw7+3zenX0+H84+nw9nn8/H7/73rt0uODZfb+d3/9eshcNz8vV2Zl9vp/l6O/89aSzf3o5o/6W/vsQ6f/1/Xq9e5Hkr9xRvb2j19oY2b29o9/aGDm9v6PT1hpZp+t03tMl0vaFvXzn59oZmb2+oeXtDi7c3JN7e0OrtDW3e3tAnP6kf/4rj8/+K8+P/inn6/L9i/vy/on3+X7F8/l8hn/9XrJ//V2yf/1d8/r/u+fP/dc+f/6+7ff6/7vb5/7rb5//rbp//r7t9/r/u9p//626vFt3mVbsMK2vW0jZn72d39n4OZ+/n9PV+lsnZ+/nPn3V/94uE9vzvfV6nTshdmq+3s/h6O+Lr7ay+3s7m6+3svt7O4evtnK7ejky+3o6vT2Xx9aksvj6Vxdensvj6VBZfn8ri61NZfH0qi69P5dXXp/Lq61N59fWpvPr6VF59fSqvvj6VV1+fyquvT+XV16fy6utTefP1qbz5+lTefH0qb74+lTdfn8qbr0/lzden8ubrU3nz9am8+fpU3n19Ku++PpV3X5/Ku69P5d3Xp/Lu61N59/WpvPv6VN59fSrvvj6VD1+fyoevT+XD16fy4etT+fD1qXz4+lQ+fH0qH74+lQ9fn8qHr0/l09en8unrU/n09al8+vpUPn19Kp++PpVPX5/Kp69P5dPXp/Lp6lNZJlefyjK5+lSWydWnskyuPpVlcvWpLJOrT2WZXH0qy+TqU1kmV5/KMvn6VJ59fSrPvj6VZ1+fyrOvT+XZ16fy7OtTefb1qTz7+lSefX0qz74+lZuvT+Xm61O5+fpUbr4+lZuvT+Xm61O5+fpUbr4+lZuvT+Xm61N58fWp7Ou3feLrt33i67d94uu3feLrt33i67d94uu3feLrt33i67d94uu3feLrt33i67d94uu3feLrt33i67d94uu3feLrt33i67d94uu3feLrt33i67d94uu3feLrt33i67d94uu3feLrt33i67d94uu3feLrt33i67d94uu3feLrt33i67d94uu3feLrt33i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"},{"name":"createCoffin","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"stakingToken","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"rewardsToken","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"periodInDays","type":{"kind":"field"},"visibility":"private"},{"name":"rewardsAmount","type":{"kind":"field"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"constructor","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(initializer)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"feeTo","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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"}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"Vanhelsing::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Vanhelsing::constructor_parameters","fields":[{"name":"feeTo","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Vanhelsing::createCoffin_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Vanhelsing::createCoffin_parameters","fields":[{"name":"stakingToken","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"rewardsToken","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"periodInDays","type":{"kind":"field"}},{"name":"rewardsAmount","type":{"kind":"field"}},{"name":"nonce","type":{"kind":"field"}}]}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"reject_all","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"approved_actions","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}}]},{"kind":"struct","fields":[{"name":"admin","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"minters","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"total_supply","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"pending_shields","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}},{"name":"public_balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}]}},{"name":"symbol","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}]}},{"name":"name","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}]}},{"name":"decimals","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}]}}]},{"kind":"struct","fields":[{"name":"coffins","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"coffinId","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"feeTo","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}}]}],"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000006827b230"},{"kind":"string","value":"AddressNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000006827b230"},{"kind":"string","value":"AddressNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000006827b230"},{"kind":"string","value":"AddressNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000071421477"},{"kind":"string","value":"ValueNote"}]}]}},"file_map":{"22":{"source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\nstruct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint { \n        EmbeddedCurvePoint {\n            x: self.x,\n            y: -self.y,\n            is_infinite: self.is_infinite\n        }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite) | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\nstruct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n// This is a hack as returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\nfn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint\n) -> EmbeddedCurvePoint\n// docs:end:embedded_curve_add\n{\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n    EmbeddedCurvePoint { x, y, is_infinite: point_array[2] == 1 }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n","path":"std/embedded_curve_ops.nr"},"23":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"24":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field/mod.nr"},"27":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\nmod sha256;\nmod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\nuse sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\ntrait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n","path":"std/hash/mod.nr"},"32":{"source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"35":{"source":"mod hash;\nmod aes128;\nmod array;\nmod slice;\nmod merkle;\nmod schnorr;\nmod ecdsa_secp256k1;\nmod ecdsa_secp256r1;\nmod eddsa;\nmod embedded_curve_ops;\nmod sha256;\nmod sha512;\nmod field;\nmod ec;\nmod collections;\nmod compat;\nmod convert;\nmod option;\nmod string;\nmod test;\nmod cmp;\nmod ops;\nmod default;\nmod prelude;\nmod uint128;\nmod bigint;\nmod runtime;\nmod meta;\nmod append;\nmod mem;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32\n) {\n    crate::assert_constant(proof_type);\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\n// from_field and as_field are private since they are not valid for every type.\n// `as` should be the default for users to cast between primitive types, and in the future\n// traits can be used to work with generic types.\n#[builtin(from_field)]\nfn from_field<T>(x: Field) -> T {}\n\n#[builtin(as_field)]\nfn as_field<T>(x: T) -> Field {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) + crate::as_field(y))\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T {\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    crate::from_field(crate::as_field(x) + 340282366920938463463374607431768211456 - crate::as_field(y))\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) * crate::as_field(y))\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\n","path":"std/lib.nr"},"53":{"source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n","path":"std/option.nr"},"59":{"source":"use crate::append::Append;\n\nimpl<T> [T] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    // Append each element of the `other` slice to the end of `self`.\n    // This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T where T: Append {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n","path":"std/slice.nr"},"62":{"source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        (if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (unsafe {\n                        U128::uconstrained_check_is_upper_ascii(ascii) as u8\n                    });\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        }) as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            \n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        unsafe {\n            let (q,r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        unsafe {\n            let (c,d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        unsafe {\n            let (c, d)= a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n","path":"std/uint128.nr"},"67":{"source":"mod test;\nmod coffin;\nmod stake;\n\ncontract Vanhelsing {\n    use dep::token::Token;\n    use dep::aztec::{prelude::{PublicMutable, AztecAddress, Map}};\n    use crate::coffin::{Vampire, Coffin};\n\n    #[aztec(storage)]\n    struct Storage {\n        coffins: Map<u64, PublicMutable<Coffin>>,\n        coffinId:  PublicMutable<u64>,\n        feeTo: PublicMutable<AztecAddress>,\n    }\n\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(\n        feeTo: AztecAddress,\n    ) {\n        storage.feeTo.write(feeTo);\n    }\n\n    #[aztec(public)]\n    fn createCoffin(\n        stakingToken: AztecAddress,\n        rewardsToken: AztecAddress,\n        periodInDays: Field,\n        rewardsAmount: Field,\n        nonce: Field\n    ) {\n\n        Token::at(rewardsToken).transfer_public(\n            context.msg_sender(),\n            context.this_address(),\n            rewardsAmount,\n            nonce\n        ).call(&mut context);\n        let currentcoffinId = storage.coffinId.read();\n\n        let coffin_storage = storage.coffins.at(currentcoffinId);\n        std::println(coffin_storage);\n        let mut coffin_data = coffin_storage.read(); // <======== Failed assertion\n    }\n\n}\n","path":"/home/josh/Documents/test/aztec-txe/contracts/myContract/src/main.nr"},"68":{"source":"use dep::aztec::protocol_types::{address::AztecAddress, traits::{Serialize, Deserialize}};\nuse dep::aztec::{protocol_types::{traits::{ToField, FromField}, constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL}};\nuse dep::token::Token;\nuse crate::stake::Stake;\n\nglobal STAKE_THRESHOLD = 8;\n\nstruct Vampire {\n    wallet: AztecAddress,\n    numberOfStakers: u32,\n    feeRate: U128,\n    isAlive: bool,\n}\n\nimpl Vampire {\n    pub fn is_initialized(self) -> bool {\n        !self.wallet.is_zero()\n    }\n}\n\nglobal VAMPIRE_SERIALIZED_LEN: Field = 4;\n\nimpl Deserialize<VAMPIRE_SERIALIZED_LEN> for Vampire {\n    fn deserialize(fields: [Field; VAMPIRE_SERIALIZED_LEN]) -> Vampire {\n        let wallet =  AztecAddress::from_field(fields[0]);\n        let numberOfStakers = fields[1] as u32;\n        let feeRate = U128::from_integer(fields[2]);\n        let isAlive = fields[3] as bool;\n        \n        Vampire {\n            wallet,\n            numberOfStakers,\n            feeRate,\n            isAlive\n        }\n    }\n}\n\nstruct Coffin {\n        vampire: Vampire,\n        currentFee: U128,\n        stakingToken: AztecAddress,\n        rewardsToken: AztecAddress,\n        rewardsReserve: U128,\n        periodInDays: u64,\n        rewardsPerDay: u64,\n        lastDistribution: u64,\n        firstStakeStart: u64, // start timestamp of fist stake\n        stakesEndMax: u64, // maximum end time of all stakes\n        idleDays: u64, // idle time in days\n        allStakesNumber:u64,\n        activeStakesNumber:u64,\n        isActive: bool \n}\n\n// impl FromField for Coffin {\n//     fn from_field(field: Field) -> Coffin {\n\n//     }\n// }\n\nimpl ToField for Coffin {\n fn to_field(self) -> Field {\n        self.vampire.wallet.to_field()  +  \n        self.vampire.numberOfStakers as Field  +  \n        self.vampire.feeRate.to_field()  +  \n        self.vampire.isAlive as Field  +  \n        self.currentFee.to_integer()  +   \n        self.stakingToken.to_field()   +   \n        self.rewardsToken.to_field()  + \n        self.rewardsReserve.to_integer()   + \n        self.periodInDays as Field  + \n        self.rewardsPerDay as Field  + \n        self.lastDistribution.to_field()  + \n        self.firstStakeStart as Field  + \n        self.stakesEndMax as Field  + \n        self.idleDays as Field  + \n        self.allStakesNumber as Field  + \n        self.activeStakesNumber as Field  + \n        (self.isActive as Field )*65536\n    }\n}\n\n#[test]\nfn test_to_from_field() {\n    let field = 1234567890;\n    // let coffin = Coffin::from_field(field);\n    // assert(coffin.to_field() == field);\n}\n\nglobal COFFIN_SERIALIZED_LEN: Field = 18;\n\nimpl Serialize<COFFIN_SERIALIZED_LEN> for Coffin {\n    fn serialize(Coffin: Coffin) -> [Field; COFFIN_SERIALIZED_LEN] {\n        [\n            Coffin.vampire.wallet.to_field(),\n            Coffin.vampire.numberOfStakers as Field,\n            Coffin.vampire.feeRate.to_field(),\n            Coffin.vampire.isAlive as Field,\n            Coffin.currentFee.lo,\n            Coffin.currentFee.hi,\n            Coffin.stakingToken.to_field(),\n            Coffin.rewardsToken.to_field(),\n            Coffin.rewardsReserve.lo,\n            Coffin.rewardsReserve.hi,\n            Coffin.periodInDays as Field,\n            Coffin.rewardsPerDay as Field,\n            Coffin.lastDistribution as Field  + \n            Coffin.firstStakeStart as Field,\n            Coffin.stakesEndMax as Field,\n            Coffin.idleDays as Field,\n            Coffin.allStakesNumber as Field,\n            Coffin.activeStakesNumber as Field,\n            Coffin.isActive as Field\n        ]\n    }\n}\n\nimpl Deserialize<COFFIN_SERIALIZED_LEN> for Coffin {\n    fn deserialize(fields: [Field; COFFIN_SERIALIZED_LEN]) -> Coffin {\n        let vampire = Vampire::deserialize([fields[0], fields[1], fields[2], fields[3]]);\n\n        Coffin {\n            vampire,\n            currentFee: U128 { lo: fields[4], hi: fields[5] },\n            stakingToken: AztecAddress::from_field(fields[6]),\n            rewardsToken: AztecAddress::from_field(fields[7]),\n            rewardsReserve:  U128 { lo: fields[8], hi: fields[9] },\n            periodInDays: fields[10] as u64,\n            rewardsPerDay: fields[11] as u64,\n            lastDistribution: fields[12] as u64,\n            firstStakeStart: fields[13] as u64,\n            stakesEndMax: fields[14] as u64,\n            idleDays: fields[15] as u64,\n            allStakesNumber: fields[16] as u64,\n            activeStakesNumber: fields[17] as u64,\n            isActive: fields[18] as bool,\n        }\n    }\n}\n\nimpl Coffin {\n    fn create_coffin(&mut self, coffin: Coffin) -> bool {\n        let mut created = false;\n        let mut entry = coffin;\n        if entry.is_activated() {\n            assert(!self.vampire.wallet.eq(coffin.vampire.wallet), \"Coffin exists.\");\n        } else if !created {\n            self.vampire = coffin.vampire;\n            self.currentFee = coffin.currentFee;\n            self.stakingToken = coffin.stakingToken;\n            self.rewardsToken = coffin.rewardsToken;\n            self.rewardsReserve = coffin.rewardsReserve;\n            self.periodInDays = coffin.periodInDays;\n            self.rewardsPerDay = coffin.rewardsPerDay;\n            self.lastDistribution = coffin.lastDistribution;\n            self.firstStakeStart = coffin.firstStakeStart;\n            self.stakesEndMax = coffin.stakesEndMax;\n            self.idleDays = coffin.idleDays;\n            self.allStakesNumber = coffin.allStakesNumber;\n            self.activeStakesNumber = coffin.activeStakesNumber;\n            self.isActive = true;\n            created = true;\n        }\n        created\n    }\n\n    pub fn is_activated(&mut self) -> bool {\n        self.isActive\n    }\n\n    pub fn addFunds(&mut self, rewardsAmount: Field, currentTime: u64, stake: Stake) {\n        assert(U128::from_integer(rewardsAmount) > U128::from_integer(0), \"Wrong amount\");\n        assert(self.getCoffinDaysLeft(currentTime) > 0, \"Coffin expired\");\n\n        // Calculate rewards with old rewardsPerDay till yesterday and store result\n        self.distributeRewards(currentTime, stake);\n\n        // From current time we will count rewardsPerDay with the added funds.\n        self.updateRewardsPerDayAndRewardsBalance(rewardsAmount, currentTime);\n    }\n\n    pub fn getCoffinDaysLeft(&mut self, currentTime: u64) -> u64 {\n        let coffinPeriod = self.periodInDays;\n        if (U128::from_integer(self.firstStakeStart) == (U128::from_integer(0))) {\n            coffinPeriod\n        } else {\n            let mut activeTimePassed = 0; // How long coffin was active (had stakes), the current time is not included\n            if ((U128::from_integer(self.stakesEndMax)) < U128::from_integer(currentTime)) {\n                // If last stake finished before present moment we have to count active time\n                // till the end of last stake\n                activeTimePassed = self.stakesEndMax - self.firstStakeStart + 1;\n            } else {\n                // In case there are active stakes now we just count time till current time as active, the current time is not included\n                activeTimePassed = currentTime -self.firstStakeStart;\n            }\n\n            activeTimePassed = activeTimePassed - self.idleDays;\n\n            coffinPeriod - activeTimePassed\n        }\n    }\n\n    pub fn updateRewardsPerDayAndRewardsBalance(\n        &mut self,\n        rewardsAmountAdded: Field,\n        currentTime: u64\n    ) {\n        self.rewardsReserve = self.rewardsReserve + U128::from_integer(rewardsAmountAdded);\n        let daysLeft = self.getCoffinDaysLeft(currentTime);\n        if (daysLeft > 0) {\n            self.rewardsPerDay = self.rewardsPerDay + (rewardsAmountAdded *1000) as u64 / daysLeft; // we store rewardsPerDay multiplied by 1000\n        }\n    }\n\n    pub fn checkPeriod(\n        &mut self,\n        daysLockedUp: Field,\n        minStakePeriod: Field,\n        maxStakePeriod: Field,\n        currentTime: u64\n    ) -> bool {\n        if ((U128::from_integer(daysLockedUp) < U128::from_integer(minStakePeriod))\n            | (U128::from_integer(daysLockedUp) > U128::from_integer(maxStakePeriod))) {\n            false\n        }\n        let coffinDaysLeft = self.getCoffinDaysLeft(currentTime);\n        (U128::from_integer(daysLockedUp) <= U128::from_integer(coffinDaysLeft))\n    }\n\n    pub fn addStakeNumbers(&mut self) {\n        self.activeStakesNumber += 1;\n    }\n\n    pub fn reduceStakeNumbers(&mut self) {\n        self.activeStakesNumber -= 1;\n    }\n\n\n    pub fn distributeRewards(&mut self, currentTime: u64, stake: Stake) {\n        let rewardsPerDay = self.rewardsPerDay;\n        let activeStakesNumber = self.activeStakesNumber;\n        let lastDistribution = self.lastDistribution;\n        let mut theStake = stake;\n        // We count rewards till yesterday only, because today we can receive new stakes\n        if (rewardsPerDay > 0 & activeStakesNumber > 0 & lastDistribution < (currentTime - 1)) {\n            for day in (lastDistribution + 1) .. currentTime {\n                let mut dayTotal =0; // total sum for all stakes (stakeAmount * remaining days) for current day to get then share of this total\n                // In this loop we calculate total sum for all stakes (stakeAmount * remaining days) to get then share of this total\n                if ((theStake.end >= day) & (theStake.start <= day) ) {\n                        let daysCoeff = theStake.end - day + 1;\n                        let dayStakeFactor = U128::from_integer(daysCoeff as Field) * theStake.stakeAmount ;\n                        dayTotal += dayStakeFactor.to_field();\n                }\n                if (U128::from_integer(dayTotal) > U128::from_integer(0)) {\n                    // In this loop we calculate share in this day rewards and add it to awarded field\n                    if (theStake.end >= day & theStake.start <= day) {\n                        let daysCoeff = theStake.end - day + 1;\n                        let dayStakeFactor = daysCoeff as Field * theStake.stakeAmount.to_field();\n                        let share = self.preciseDiv( dayStakeFactor, dayTotal, 2 ); // Share in percents\n                        let mut todayStakeReward = rewardsPerDay as Field * share;\n                        todayStakeReward = todayStakeReward / 100; // Round down. Remaining rewards will be sent to fee receiver\n                        theStake.awarded += U128::from_integer(todayStakeReward);\n                    }\n                }\n            }\n            self.lastDistribution = currentTime - 1;\n        }\n    }\n\n    pub fn preciseDiv(&mut self, _numerator: Field, _denominator: Field, _precision: Field) -> pub Field {\n        let mut numerator = _numerator * (10.pow_32(_precision + 1));\n        // with rounding of last digit\n        let quotient = ((numerator / _denominator) + 5) / 10;\n        quotient\n    }\n\n}\n","path":"/home/josh/Documents/test/aztec-txe/contracts/myContract/src/coffin.nr"},"71":{"source":"use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal ADDRESS_NOTE_LEN: Field = 3;\n// ADDRESS_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal ADDRESS_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[aztec(note)]\nstruct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NoteInterface<ADDRESS_NOTE_LEN, ADDRESS_NOTE_BYTES_LEN> for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/address-note/src/address_note.nr"},"93":{"source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        _contract_address: AztecAddress,\n        _function_selector: FunctionSelector,\n        _args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(_self: Self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [\n        user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n        user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<let N: u32>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N as Field)\n}\n\nunconstrained fn storage_write<let N: u32>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<let N: u32>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<let N: u32>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<let N: u32> {\n    values: [Field; N]\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"101":{"source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\ntrait CallInterface<let N: u32, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr"},"111":{"source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::{PrivateContext, UnconstrainedContext},\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{\n    public_keys::{PublicKeys, PUBLIC_KEYS_LENGTH}, stored_keys::StoredKeys,\n    constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}\n},\n    state_vars::{\n    shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter,\n    public_mutable::PublicMutable, map::Map\n}\n};\n\nmod test;\n\n// This is the number of blocks that must pass after a key rotation event until the old keys are fully phased out and\n// become invalid.\nglobal KEY_REGISTRY_UPDATE_BLOCKS = 5;\n\nglobal KEY_REGISTRY_STORAGE_SLOT = 1;\n\n// A helper function since requesting nsk_app is very common\n// TODO(#6543)\npub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// Returns all current public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_current_public_keys(context: &mut PrivateContext, account: AztecAddress) -> PublicKeys {\n    // We're going to perform historical reads from public storage, and so need to constrain the caller so that they\n    // cannot use very old blocks when constructing proofs, and hence e.g. read very old keys. We are lax and allow\n    // _any_ recent block number to be used, regardless of whether there may have been a recent key rotation. This means\n    // that multiple sets of keys are valid for a while immediately after rotation, until the old keys become phased\n    // out. We *must* be lax to prevent denial of service and transaction fingerprinting attacks by accounts that rotate\n    // their keys frequently.\n    // Note that we constrain the max block number even if the registry ends up being empty: this ensures that proof of\n    // an empty registry is also fresh.\n    let current_header = context.get_header();\n    context.set_tx_max_block_number(current_header.global_variables.block_number as u32 + KEY_REGISTRY_UPDATE_BLOCKS);\n\n    get_historical_public_keys(current_header, account)\n}\n\n// Returns historical public keys for a given account at some block determined by a block header. We read all keys at\n// once since the constraints for reading them all are actually fewer than if we read them one at a time - any read keys\n// that are not required by the caller can simply be discarded.\n// WARNING: if called with a historical header created from a fixed block this function will explicitly ignore key\n// rotation! This means that callers of this may force a user to use old keys, potentially leaking privacy (e.g. if the\n// old keys were leaked). Only call this function with a header from a fixed block if you understand the implications of\n// breaking key rotation very well.\npub fn get_historical_public_keys(historical_header: Header, account: AztecAddress) -> PublicKeys {\n    // TODO: improve this so that we always hint the correct set of keys (either registry or canonical) and hash them\n    // once instead of having two different hints and twice as many constraints due to the double hashing.\n\n    // The key registry is the primary source of information for keys, as that's where accounts store their new keys\n    // when they perform rotation. The key registry conveniently stores a hash of each user's keys, so we can read that\n    // single field and then prove that we know its preimage (i.e. the current set of keys).\n    let key_registry_hash = key_registry_hash_public_historical_read(historical_header, account);\n    if key_registry_hash != 0 {\n        let hinted_registry_public_keys = key_registry_get_stored_keys_hint(\n            account,\n            historical_header.global_variables.block_number as u32\n        );\n        assert_eq(hinted_registry_public_keys.hash().to_field(), key_registry_hash);\n\n        hinted_registry_public_keys\n    } else {\n        // If nothing was written to the registry, we may still be able to produce the correct keys if we happen to know\n        // the canonical set (i.e. the ones that are part of the account's preimage).\n        let (hinted_canonical_public_keys, partial_address) = get_public_keys_and_partial_address(account);\n        assert_eq(\n            account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n        );\n\n        hinted_canonical_public_keys\n    }\n}\n\nfn key_registry_hash_public_historical_read(historical_header: Header, account: AztecAddress) -> Field {\n    // The keys are stored in a Map that is keyed with the address of each account, so we first derive the corresponding\n    // slot for this account.\n    let keys_storage_slot = derive_storage_slot_in_map(KEY_REGISTRY_STORAGE_SLOT, account);\n\n    // The keys are stored as [ ...serialized_keys, hash ], and since arrays get allocated sequential storage slots\n    // (prior to siloing!), we simply add the length to the base slot to get the last element.\n    let hash_storage_slot = keys_storage_slot + PUBLIC_KEYS_LENGTH as Field;\n\n    historical_header.public_storage_historical_read(hash_storage_slot, CANONICAL_KEY_REGISTRY_ADDRESS)\n}\n\nunconstrained fn key_registry_get_stored_keys_hint(account: AztecAddress, block_number: u32) -> PublicKeys {\n    // This is equivalent to the key registry contract having an unconstrained getter that we call from an oracle, but\n    // PXE does not yet support that functionality so we do this manually instad. Note that this would be a *historical*\n    // call!\n\n    // TODO (#7524): call the unconstrained KeyRegistry.get_current_keys() function instead\n\n    let context = UnconstrainedContext::at_historical(CANONICAL_KEY_REGISTRY_ADDRESS, block_number);\n    let keys_storage = Map::new(\n        context,\n        KEY_REGISTRY_STORAGE_SLOT,\n        |context, slot| { PublicMutable::new(context, slot) }\n    );\n\n    let stored_keys: StoredKeys = keys_storage.at(account).read();\n    stored_keys.public_keys\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"115":{"source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"122":{"source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub fn get_key_validation_request(pk_m_hash: Field, key_index: Field) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"136":{"source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/initializer.nr"},"137":{"source":"use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"148":{"source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"174":{"source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32, let M: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32, let M: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the \n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the \n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from \n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let M: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"185":{"source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc, point::Point\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"208":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr"},"210":{"source":"struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"221":{"source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"233":{"source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x:fields[0], y: fields[1], is_infinite: fields[2] as bool},\n            sk_app: fields[3],\n        }\n    }\n}\n\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr"},"241":{"source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"283":{"source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash_with_separator,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"297":{"source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr"},"300":{"source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f);\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript = 0x2499880e2b1b831785c17286f99a0d5122fee784ce7b1c04e380c4a991da819a;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"303":{"source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"339":{"source":"// docs:start:token_all\n// docs:start:imports\nmod types;\nmod test;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n\ncontract Token {\n    // Libs\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        context::{PrivateContext, PrivateCallInterface}, hash::compute_secret_hash,\n        prelude::{\n        NoteGetterOptions, Map, PublicMutable, SharedImmutable, PrivateSet, AztecAddress,\n        FunctionSelector, NoteHeader, Point\n    },\n        encrypted_logs::{\n        encrypted_note_emission::{encode_and_encrypt_note_with_keys, encode_and_encrypt_note_with_keys_unconstrained},\n        encrypted_event_emission::{encode_and_encrypt_event, encode_and_encrypt_event_with_keys_unconstrained}\n    },\n        keys::getters::get_current_public_keys\n    };\n\n    // docs:start:import_authwit\n    use dep::authwit::auth::{assert_current_call_valid_authwit, assert_current_call_valid_authwit_public, compute_authwit_nullifier};\n    // docs:end:import_authwit\n\n    use crate::types::{\n        transparent_note::TransparentNote,\n        token_note::{TokenNote, TOKEN_NOTE_LEN, TokenNoteHidingPoint}, balances_map::BalancesMap\n    };\n    // docs:end::imports\n\n    // In the first transfer iteration we are computing a lot of additional information (validating inputs, retrieving\n    // keys, etc.), so the gate count is already relatively high. We therefore only read a few notes to keep the happy\n    // case with few constraints.\n    global INITIAL_TRANSFER_CALL_MAX_NOTES = 2;\n    // All the recursive call does is nullify notes, meaning the gate count is low, but it is all constant overhead. We\n    // therefore read more notes than in the base case to increase the efficiency of the overhead, since this results in\n    // an overall small circuit regardless.\n    global RECURSIVE_TRANSFER_CALL_MAX_NOTES = 8;\n\n    #[aztec(event)]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n    }\n\n    // docs:start:storage_struct\n    #[aztec(storage)]\n    struct Storage {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool>>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: BalancesMap<TokenNote>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128>,\n        // docs:start:storage_pending_shields\n        pending_shields: PrivateSet<TransparentNote>,\n        // docs:end:storage_pending_shields\n        public_balances: Map<AztecAddress, PublicMutable<U128>>,\n        symbol: SharedImmutable<FieldCompressedString>,\n        name: SharedImmutable<FieldCompressedString>,\n        // docs:start:storage_decimals\n        decimals: SharedImmutable<u8>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[aztec(public)]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_name() -> pub FieldCompressedString {\n        storage.name.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_name() -> pub FieldCompressedString {\n        storage.name.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_public\n        storage.decimals.read_public()\n        // docs:end:read_decimals_public\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_private\n        storage.decimals.read_private()\n        // docs:end:read_decimals_private\n    }\n\n    // docs:start:admin\n    #[aztec(public)]\n    #[aztec(view)]\n    fn admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[aztec(public)]\n    #[aztec(view)]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:total_supply\n    #[aztec(public)]\n    #[aztec(view)]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n\n    // docs:start:balance_of_public\n    #[aztec(public)]\n    #[aztec(view)]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n\n    // docs:start:set_minter\n    #[aztec(public)]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint_public\n    #[aztec(public)]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_public\n\n    // docs:start:mint_private\n    #[aztec(public)]\n    fn mint_private(amount: Field, secret_hash: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount, secret_hash);\n        let supply = storage.total_supply.read().add(U128::from_integer(amount));\n\n        storage.total_supply.write(supply);\n        // docs:start:insert_from_public\n        pending_shields.insert_from_public(&mut note);\n        // docs:end:insert_from_public\n    }\n    // docs:end:mint_private\n\n    // TODO: Nuke this - test functions do not belong to token contract!\n    #[aztec(private)]\n    fn privately_mint_private_note(amount: Field) {\n        let caller = context.msg_sender();\n        let caller_keys = get_current_public_keys(&mut context, caller);\n        storage.balances.add(caller, caller_keys.npk_m, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note_with_keys(&mut context, caller_keys.ovpk_m, caller_keys.ivpk_m, caller)\n        );\n\n        Token::at(context.this_address()).assert_minter_and_mint(context.msg_sender(), amount).enqueue(&mut context);\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn assert_minter_and_mint(minter: AztecAddress, amount: Field) {\n        assert(storage.minters.at(minter).read(), \"caller is not minter\");\n        let supply = storage.total_supply.read() + U128::from_integer(amount);\n        storage.total_supply.write(supply);\n    }\n\n    // docs:start:shield\n    #[aztec(public)]\n    fn shield(from: AztecAddress, amount: Field, secret_hash: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            // The redeem is only spendable once, so we need to ensure that you cannot insert multiple shields from the same message.\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount.to_field(), secret_hash);\n\n        storage.public_balances.at(from).write(from_balance);\n        pending_shields.insert_from_public(&mut note);\n    }\n    // docs:end:shield\n\n    // docs:start:transfer_public\n    #[aztec(public)]\n    fn transfer_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_public\n\n    // docs:start:burn_public\n    #[aztec(public)]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n\n    // docs:start:redeem_shield\n    #[aztec(private)]\n    fn redeem_shield(to: AztecAddress, amount: Field, secret: Field) {\n        let secret_hash = compute_secret_hash(secret);\n\n        // Pop 1 note (set_limit(1)) which has an amount stored in a field with index 0 (select(0, amount)) and\n        // a secret_hash stored in a field with index 1 (select(1, secret_hash)).\n        let mut options = NoteGetterOptions::new();\n        options = options.select(TransparentNote::properties().amount, amount, Option::none()).select(\n            TransparentNote::properties().secret_hash,\n            secret_hash,\n            Option::none()\n        ).set_limit(1);\n\n        let notes = storage.pending_shields.pop_notes(options);\n        assert(notes.len() == 1, \"note not popped\");\n\n        // Add the token note to user's balances set\n        // Note: Using context.msg_sender() as a sender below makes this incompatible with escrows because we send\n        // outgoing logs to that address and to send outgoing logs you need to get a hold of ovsk_m.\n        let from = context.msg_sender();\n        let from_keys = get_current_public_keys(&mut context, from);\n        let to_keys = get_current_public_keys(&mut context, to);\n        storage.balances.add(to, to_keys.npk_m, U128::from_integer(amount)).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to));\n    }\n    // docs:end:redeem_shield\n\n    // docs:start:unshield\n    #[aztec(private)]\n    fn unshield(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let from_keys = get_current_public_keys(&mut context, from);\n        storage.balances.sub(from, from_keys.npk_m, U128::from_integer(amount)).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from));\n\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:unshield\n\n    // docs:start:transfer\n    #[aztec(private)]\n    fn transfer(to: AztecAddress, amount: Field) {\n        let from = context.msg_sender();\n\n        let from_keys = get_current_public_keys(&mut context, from);\n        let to_keys = get_current_public_keys(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n\n        // We reduce `from`'s balance by amount by recursively removing notes over potentially multiple calls. This\n        // method keeps the gate count for each individual call low - reading too many notes at once could result in\n        // circuits in which proving is not feasible.\n        // Since the sum of the amounts in the notes we nullified was potentially larger than amount, we create a new\n        // note for `from` with the change amount, e.g. if `amount` is 10 and two notes are nullified with amounts 8 and\n        // 5, then the change will be 3 (since 8 + 5 - 10 = 3).\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            from,\n            amount,\n            INITIAL_TRANSFER_CALL_MAX_NOTES\n        );\n\n        storage.balances.add(from, from_keys.npk_m, change).emit(\n            encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from)\n        );\n\n        storage.balances.add(to, to_keys.npk_m, amount).emit(\n            encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to)\n        );\n\n        // We don't constrain encryption of the note log in `transfer` (unlike in `transfer_from`) because the transfer\n        // function is only designed to be used in situations where the event is not strictly necessary (e.g. payment to\n        // another person where the payment is considered to be successful when the other party successfully decrypts a\n        // note).\n        Transfer { from, to, amount: amount.to_field() }.emit(\n            encode_and_encrypt_event_with_keys_unconstrained(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to)\n        );\n    }\n    // docs:end:transfer\n\n    #[contract_library_method]\n    fn subtract_balance(\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n        account: AztecAddress,\n        amount: U128,\n        max_notes: u32\n    ) -> U128 {\n        let subtracted = storage.balances.try_sub(account, amount, max_notes);\n\n        // Failing to subtract any amount means that the owner was unable to produce more notes that could be nullified.\n        // We could in some cases fail early inside try_sub if we detected that fewer notes than the maximum were\n        // returned and we were still unable to reach the target amount, but that'd make the code more complicated, and\n        // optimizing for the failure scenario is not as important.\n        assert(subtracted > U128::from_integer(0), \"Balance too low\");\n\n        if subtracted >= amount {\n            // We have achieved our goal of nullifying notes that add up to more than amount, so we return the change\n            subtracted - amount\n        } else {\n            // try_sub failed to nullify enough notes to reach the target amount, so we compute the amount remaining\n            // and try again.\n            let remaining = amount - subtracted;\n            compute_recurse_subtract_balance_call(*context, account, remaining).call(context)\n        }\n    }\n\n    // TODO(#7729): apply no_predicates to the contract interface method directly instead of having to use a wrapper\n    // like we do here.\n    #[no_predicates]\n    #[contract_library_method]\n    fn compute_recurse_subtract_balance_call(\n        context: PrivateContext,\n        account: AztecAddress,\n        remaining: U128\n    ) -> PrivateCallInterface<25, U128, (AztecAddress, Field)> {\n        Token::at(context.this_address())._recurse_subtract_balance(account, remaining.to_field())\n    }\n\n    // TODO(#7728): even though the amount should be a U128, we can't have that type in a contract interface due to\n    // serialization issues.\n    #[aztec(internal)]\n    #[aztec(private)]\n    fn _recurse_subtract_balance(account: AztecAddress, amount: Field) -> U128 {\n        subtract_balance(\n            &mut context,\n            storage,\n            account,\n            U128::from_integer(amount),\n            RECURSIVE_TRANSFER_CALL_MAX_NOTES\n        )\n    }\n\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[aztec(private)]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier);\n    }\n    // docs:end:cancel_authwit\n\n    // docs:start:transfer_from\n    #[aztec(private)]\n    fn transfer_from(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n\n        let from_keys = get_current_public_keys(&mut context, from);\n        let to_keys = get_current_public_keys(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        storage.balances.sub(from, from_keys.npk_m, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        storage.balances.add(to, to_keys.npk_m, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to));\n    }\n    // docs:end:transfer_from\n\n    // docs:start:burn\n    #[aztec(private)]\n    fn burn(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let from_keys = get_current_public_keys(&mut context, from);\n        storage.balances.sub(from, from_keys.npk_m, U128::from_integer(amount)).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from));\n\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn\n\n    /// We need to use different randomness for the user and for the fee payer notes because if the randomness values\n    /// were the same we could fingerprint the user by doing the following:\n    ///      1) randomness_influence = fee_payer_point - G_npk * fee_payer_npk =\n    ///                              = (G_npk * fee_payer_npk + G_rnd * randomness) - G_npk * fee_payer_npk =\n    ///                              = G_rnd * randomness\n    ///      2) user_fingerprint = user_point - randomness_influence =\n    ///                          = (G_npk * user_npk + G_rnd * randomness) - G_rnd * randomness =\n    ///                          = G_npk * user_npk\n    ///      3) Then the second time the user would use this fee paying contract we would recover the same fingerprint\n    ///         and link that the 2 transactions were made by the same user. Given that it's expected that only\n    ///         a limited set of fee paying contracts will be used and they will be known, searching for fingerprints\n    ///         by trying different fee payer npk values of these known contracts is a feasible attack.\n    ///\n    /// `fee_payer_point` and `user_point` above are public information because they are passed as args to the public\n    /// `complete_refund(...)` function.\n    #[aztec(private)]\n    fn setup_refund(\n        fee_payer: AztecAddress, // Address of the entity which will receive the fee note.\n        user: AztecAddress, // A user for which we are setting up the fee refund.\n        funded_amount: Field, // The amount the user funded the fee payer with (represents fee limit).\n        user_randomness: Field, // A randomness to mix in with the generated refund note for the sponsored user.\n        fee_payer_randomness: Field // A randomness to mix in with the generated fee note for the fee payer.\n    ) {\n        // 1. This function is called by fee paying contract (fee_payer) when setting up a refund so we need to support\n        // the authwit flow here and check that the user really permitted fee_payer to set up a refund on their behalf.\n        assert_current_call_valid_authwit(&mut context, user);\n\n        // 2. Get all the relevant keys\n        let fee_payer_npk_m_hash = get_current_public_keys(&mut context, fee_payer).npk_m.hash();\n        let user_keys = get_current_public_keys(&mut context, user);\n        let user_npk_m_hash = user_keys.npk_m.hash();\n\n        // 3. Deduct the funded amount from the user's balance - this is a maximum fee a user is willing to pay\n        // (called fee limit in aztec spec). The difference between fee limit and the actual tx fee will be refunded \n        // to the user in the `complete_refund(...)` function.\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            user,\n            U128::from_integer(funded_amount),\n            INITIAL_TRANSFER_CALL_MAX_NOTES\n        );\n        storage.balances.add(user, user_keys.npk_m, change).emit(\n            encode_and_encrypt_note_with_keys_unconstrained(&mut context, user_keys.ovpk_m, user_keys.ivpk_m, user)\n        );\n\n        // 4. We create the partial notes for the fee payer and the user.\n        // --> Called \"partial\" because they don't have the amount set yet (that will be done in `complete_refund(...)`).\n        let fee_payer_partial_note = TokenNote {\n            header: NoteHeader {\n                contract_address: AztecAddress::zero(),\n                nonce: 0,\n                storage_slot: storage.balances.map.at(fee_payer).storage_slot,\n                note_hash_counter: 0\n            },\n            amount: U128::zero(),\n            npk_m_hash: fee_payer_npk_m_hash,\n            randomness: fee_payer_randomness\n        };\n        let user_partial_note = TokenNote {\n            header: NoteHeader {\n                contract_address: AztecAddress::zero(),\n                nonce: 0,\n                storage_slot: storage.balances.map.at(user).storage_slot,\n                note_hash_counter: 0\n            },\n            amount: U128::zero(),\n            npk_m_hash: user_npk_m_hash,\n            randomness: user_randomness\n        };\n\n        // 5. Now we get the note hiding points.\n        let mut fee_payer_point = fee_payer_partial_note.to_note_hiding_point();\n        let mut user_point = user_partial_note.to_note_hiding_point();\n\n        // 6. Set the public teardown function to `complete_refund(...)`. Public teardown is the only time when a public\n        // function has access to the final transaction fee, which is needed to compute the actual refund amount.\n        context.set_public_teardown_function(\n            context.this_address(),\n            FunctionSelector::from_signature(\"complete_refund(((Field,Field,bool)),((Field,Field,bool)),Field)\"),\n            [\n            fee_payer_point.inner.x, fee_payer_point.inner.y, fee_payer_point.inner.is_infinite as Field, user_point.inner.x, user_point.inner.y, user_point.inner.is_infinite as Field, funded_amount\n        ]\n        );\n    }\n\n    // TODO(#7728): even though the funded_amount should be a U128, we can't have that type in a contract interface due\n    // to serialization issues.\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn complete_refund(\n        // TODO(#7771): the following makes macros crash --> try getting it work once we migrate to metaprogramming\n        // mut fee_payer_point: TokenNoteHidingPoint,\n        // mut user_point: TokenNoteHidingPoint,\n        fee_payer_point_immutable: TokenNoteHidingPoint,\n        user_point_immutable: TokenNoteHidingPoint,\n        funded_amount: Field\n    ) {\n        // TODO(#7771): nuke the following 2 lines once we have mutable args\n        let mut fee_payer_point = fee_payer_point_immutable;\n        let mut user_point = user_point_immutable;\n\n        // TODO(#7728): Remove the next line\n        let funded_amount = U128::from_integer(funded_amount);\n        let tx_fee = U128::from_integer(context.transaction_fee());\n\n        // 1. We check that user funded the fee payer contract with at least the transaction fee.\n        // TODO(#7796): we should try to prevent reverts here\n        assert(funded_amount >= tx_fee, \"funded amount not enough to cover tx fee\");\n\n        // 2. We compute the refund amount as the difference between funded amount and tx fee.\n        let refund_amount = funded_amount - tx_fee;\n\n        // 3. We add fee to the fee payer point and refund amount to the user point.\n        fee_payer_point.add_amount(tx_fee);\n        user_point.add_amount(refund_amount);\n\n        // 4. We finalize the hiding points to get the note hashes.\n        let fee_payer_note_hash = fee_payer_point.finalize();\n        let user_note_hash = user_point.finalize();\n\n        // 5. At last we emit the note hashes.\n        context.push_note_hash(fee_payer_note_hash);\n        context.push_note_hash(user_note_hash);\n        // --> Once the tx is settled user and fee recipient can add the notes to their pixies.\n    }\n\n    /// Internal ///\n\n    // docs:start:increase_public_balance\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n    // docs:end:increase_public_balance\n\n    // docs:start:reduce_total_supply\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n\n    /// Unconstrained ///\n\n    // docs:start:balance_of_private\n    unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.balance_of(owner).to_field()\n    }\n    // docs:end:balance_of_private\n\n    #[aztec(public)]\n    fn get_total_supply() -> pub Field {\n        storage.total_supply.read().to_integer()\n    }\n\n    #[aztec(public)]\n    fn get_balance_of_public(owner: AztecAddress) -> pub Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n}\n\n// docs:end:token_all","path":"/home/josh/Documents/test/aztec-txe/contracts/token/src/main.nr"},"342":{"source":"use dep::aztec::{\n    generators::{Ga1 as G_amt, Ga2 as G_npk, Ga3 as G_rnd, G_slot},\n    prelude::{NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{\n    constants::GENERATOR_INDEX__NOTE_NULLIFIER, point::{Point, POINT_LENGTH}, scalar::Scalar,\n    hash::poseidon2_hash_with_separator, traits::Serialize\n},\n    note::utils::compute_note_hash_for_nullify, oracle::unsafe_rand::unsafe_rand,\n    keys::getters::get_nsk_app\n};\nuse dep::std::{embedded_curve_ops::multi_scalar_mul, hash::from_field_unsafe};\n\ntrait OwnedNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self;\n    fn get_amount(self) -> U128;\n}\n\nglobal TOKEN_NOTE_LEN: Field = 3; // 3 plus a header.\nglobal TOKEN_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n#[aztec(note)]\nstruct TokenNote {\n    // The amount of tokens in the note\n    amount: U128,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n\nimpl NoteInterface<TOKEN_NOTE_LEN, TOKEN_NOTE_BYTES_LEN> for TokenNote {\n    // docs:start:nullifier\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([note_hash_for_nullify, secret],GENERATOR_INDEX__NOTE_NULLIFIER)\n    }\n\n    fn compute_note_hiding_point(self) -> Point {\n        // We use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        let amount_scalar = from_field_unsafe(self.amount.to_integer());\n        let npk_m_hash_scalar = from_field_unsafe(self.npk_m_hash);\n        let randomness_scalar = from_field_unsafe(self.randomness);\n        let slot_scalar = from_field_unsafe(self.header.storage_slot);\n        // We compute the note hiding point as:\n        //     `G_amt * amount + G_npk * npk_m_hash + G_rnd * randomness + G_slot * slot`\n        // instead of using pedersen or poseidon2 because it allows us to privately add and subtract from amount\n        // in public by leveraging homomorphism.\n        multi_scalar_mul(\n            [G_amt, G_npk, G_rnd, G_slot],\n            [amount_scalar, npk_m_hash_scalar, randomness_scalar, slot_scalar]\n        )\n    }\n}\n\nimpl TokenNote {\n    // TODO: Merge this func with `compute_note_hiding_point`. I (benesjan) didn't do it in the initial PR to not have\n    // to modify macros and all the related funcs in it.\n    fn to_note_hiding_point(self) -> TokenNoteHidingPoint {\n        TokenNoteHidingPoint::new(self.compute_note_hiding_point())\n    }\n}\n\nstruct TokenNoteHidingPoint {\n  inner: Point\n}\n\nimpl TokenNoteHidingPoint {\n    fn new(point: Point) -> Self {\n        Self { inner: point }\n    }\n\n    fn add_amount(&mut self, amount: U128) {\n        self.inner = multi_scalar_mul([G_amt], [from_field_unsafe(amount.to_integer())]) + self.inner;\n    }\n\n    fn add_npk_m_hash(&mut self, npk_m_hash: Field) {\n        self.inner = multi_scalar_mul([G_npk], [from_field_unsafe(npk_m_hash)]) + self.inner;\n    }\n\n    fn add_randomness(&mut self, randomness: Field) {\n        self.inner = multi_scalar_mul([G_rnd], [from_field_unsafe(randomness)]) + self.inner;\n    }\n\n    fn add_slot(&mut self, slot: Field) {\n        self.inner = multi_scalar_mul([G_slot], [from_field_unsafe(slot)]) + self.inner;\n    }\n\n    fn finalize(self) -> Field {\n        self.inner.x\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TokenNoteHidingPoint {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Eq for TokenNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) &\n        (self.npk_m_hash == other.npk_m_hash) &\n        (self.randomness == other.randomness)\n    }\n}\n\nimpl OwnedNote for TokenNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self {\n        Self {\n            amount,\n            npk_m_hash: owner_npk_m_hash,\n            randomness: unsafe_rand(),\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn get_amount(self) -> U128 {\n        self.amount\n    }\n}","path":"/home/josh/Documents/test/aztec-txe/contracts/token/src/types/token_note.nr"},"343":{"source":"// docs:start:token_types_all\nuse dep::aztec::{\n    note::{note_getter_options::PropertySelector, utils::compute_note_hash_for_nullify},\n    prelude::{NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator}\n};\n\nglobal TRANSPARENT_NOTE_LEN: Field = 2;\n// TRANSPARENT_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TRANSPARENT_NOTE_BYTES_LEN: Field = 2 * 32 + 64;\n\n// Transparent note represents a note that is created in the clear (public execution), but can only be spent by those\n// that know the preimage of the \"secret_hash\" (the secret). This is typically used when shielding a token balance.\n// Owner of the tokens provides a \"secret_hash\" as an argument to the public \"shield\" function and then the tokens\n// can be redeemed in private by presenting the preimage of the \"secret_hash\" (the secret).\n#[aztec(note)]\nstruct TransparentNote {\n    amount: Field,\n    secret_hash: Field,\n}\n\nstruct TransparentNoteProperties {\n    amount: PropertySelector,\n    secret_hash: PropertySelector,\n}\n\nimpl NoteInterface<TRANSPARENT_NOTE_LEN, TRANSPARENT_NOTE_BYTES_LEN> for TransparentNote {\n\n    // Custom serialization to avoid disclosing the secret field\n    fn serialize_content(self) -> [Field; TRANSPARENT_NOTE_LEN] {\n        [self.amount, self.secret_hash]\n    }\n\n    // Custom deserialization since we don't have access to the secret plaintext\n    fn deserialize_content(serialized_note: [Field; TRANSPARENT_NOTE_LEN]) -> Self {\n        TransparentNote {\n            amount: serialized_note[0],\n            secret_hash: serialized_note[1],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn compute_nullifier(self, _context: &mut PrivateContext, _note_hash_for_nullify: Field) -> Field {\n        self.compute_nullifier_without_context()\n    }\n\n    // Computing a nullifier in a transparent note is not guarded by making secret a part of the nullifier preimage (as\n    // is common in other cases) and instead is guarded by the functionality of \"redeem_shield\" function. There we do\n    // the following:\n    //      1) We pass the secret as an argument to the function and use it to compute a secret hash,\n    //      2) we fetch a note via the \"get_notes\" oracle which accepts the secret hash as an argument,\n    //      3) the \"get_notes\" oracle constrains that the secret hash in the returned note matches the one computed in\n    //         circuit. \n    // This achieves that the note can only be spent by the party that knows the secret.\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl TransparentNote {\n    // CONSTRUCTORS\n    pub fn new(amount: Field, secret_hash: Field) -> Self {\n        TransparentNote { amount, secret_hash, header: NoteHeader::empty() }\n    }\n\n    // CUSTOM FUNCTIONS FOR THIS NOTE TYPE\n    // Custom serialization forces us to manually create the metadata struct and its getter\n    pub fn properties() -> TransparentNoteProperties {\n        TransparentNoteProperties {\n            amount: PropertySelector { index: 0, offset: 0, length: 32 },\n            secret_hash: PropertySelector { index: 1, offset: 0, length: 32 }\n        }\n    }\n}\n\nimpl Eq for TransparentNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) & (self.secret_hash == other.secret_hash)\n    }\n}\n\n// docs:end:token_types_all","path":"/home/josh/Documents/test/aztec-txe/contracts/token/src/types/transparent_note.nr"},"351":{"source":"use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::{Deserialize, Serialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n// VALUE_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal VALUE_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:value-note-def\n#[aztec(note)]\nstruct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN, VALUE_NOTE_BYTES_LEN> for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret,\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    /// The following method needed to be implemented because the note is passed as an argument to a contract function\n    /// --> the serialize method is called by aztec-nr when computing an arguments hash.\n    /// Note that when the note is about to be encrypted and emitted as a log the to_be_bytes function auto-implemented\n    /// by aztec macros is called instead.\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.npk_m_hash, self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value) &\n        (self.npk_m_hash == other.npk_m_hash) &\n        (self.randomness == other.randomness)\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/value-note/src/value_note.nr"}}}