{"transpiled":true,"noir_version":"0.32.0+92ff2fa2e944722e5c3fa43fb3363f093b8f1d12","name":"Vanhelsing","functions":[{"name":"createCoffin","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"stakingToken","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"rewardsToken","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"periodInDays","type":{"kind":"field"},"visibility":"private"},{"name":"rewardsAmount","type":{"kind":"field"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"7d3RjuvKdqXpd/G10WAEJ8lgvUqj0XBVuRoGCnah7GqgYfjdO3f3IjPPydCRlubYQ6Hkf7dta2WGPiup+YcyGf/+d//1H//z//q//s9/+uf/9i//+nf/6X//97/77//yX/7h3/7pX/7543/697+b/rfa/r//7b/+j3/45z/+F//6b//wP//t7/7TMm1//3f/+M//9eO/2vYff/93/+2f/vs/fvz38h//x9//8W/23/83c+39m1bKr3/T2vL938xP/Ju1929KmeZf/6iUvXz/V9sz/yqm7r+Kev6r2Pfv/6o89a+i+6+2pR7/alu+q8fy1L9an/pX21P/qj31r/Zn/tUyPfWvylP/qj71r+an/tVTr43lqdfG8tRrY3nqtbE89dpYnnptrE+9NtanXhvrU6+N9anXxvrUa2N96rWxPvXaWJ96baxPvTbWp14b21Ovje2p18b21Gtje+q1sT312tieem1sT702tqdeG9tTr43tqddGe+q10Z56bbSnXhvtqddGe+q10Z56bbSnXhvtqddGe+q10Z56bexPvTb2p14b+1Ovjf2p18b+1Gtjf+q1sT/12tifem3sT7029qdeG2Wanvtn5bl/Vp/7Z/Nz/yye+2fLc/9sfe6fbc/9s/bcP3vuVVKee5WU514l5blXSXnuVVKee5WU514l5blXSXnuVVKee5WU514l9blXSX3uVVKfe5XU514l9blXSX3uVVKfe5XU514l9blXSX3uVTI/9yqZn3uVzM+9SubnXiXzc6+S+blXyfzcq2R+7lUyP/cqmZ97lcRzr5J47lUSz71K4rlXyXObqOW5XdTy3DZqeW4ftTy3kVqe20ktz22lluf2Ustzm6nlud3U8tx2anluP7U8t6FanttRLc9tqZbn9lTLc5uq5bld1fLctmp5bl+1PLexWp7bWS3Pba2W5/ZWy3Obq+XGvsBS9uOfrftffGL3998eHFGPT/ci1vl88McU0nn0vqzHV56mOB9ct2NBy2gLWkdb0DbagtpoC9rHWlC9sXH0wgWV0RZUR1vQPNqCBrtS12mwK3WdBrtS12mwK3WdBrtS12m0K3UZ7UpdRrtSl9Gu1GW0K3UZ7UpdRrtSl9Gu1GW0K3UZ7UpdRrtS19Gu1HW0K3V1/9gv2+evE3/+Omzdp2NB62gLcr+o12n69eB1WjsLmqfRFlRGW1AdbUHz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"},{"name":"constructor","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(initializer)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"feeTo","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000006827b230"},{"kind":"string","value":"AddressNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000006827b230"},{"kind":"string","value":"AddressNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000071421477"},{"kind":"string","value":"ValueNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"minters","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"total_supply","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"pending_shields","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}},{"name":"public_balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}],"kind":"struct"}},{"name":"symbol","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}],"kind":"struct"}},{"name":"name","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}],"kind":"struct"}},{"name":"decimals","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"feeTo","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"stakingToken","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"rewardsToken","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"periodInDays","type":{"kind":"field"}},{"name":"rewardsAmount","type":{"kind":"field"}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"Vanhelsing::createCoffin_parameters"}}],"kind":"struct","path":"Vanhelsing::createCoffin_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"feeTo","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Vanhelsing::constructor_parameters"}}],"kind":"struct","path":"Vanhelsing::constructor_abi"}]}},"file_map":{"113":{"path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub fn get_key_validation_request(pk_m_hash: Field, key_index: Field) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n\n"},"131":{"path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    constants::GENERATOR_INDEX__INNER_NOTE_HASH,\n    hash::{\n    pedersen_hash, compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_inner_note_hash_from_preimage(storage_slot: Field, note_content_hash: Field) -> Field {\n    pedersen_hash(\n        [storage_slot, note_content_hash],\n        GENERATOR_INDEX__INNER_NOTE_HASH\n    )\n}\n\npub fn compute_inner_note_hash<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    compute_inner_note_hash_from_preimage(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, let N: u32, let M: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let (_, inner_nullifier) = note_with_header.compute_note_hash_and_nullifier(context);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\nfn compute_note_hash_for_read_request_from_innter_and_nonce(\n    inner_note_hash: Field,\n    nonce: Field\n) -> Field {\n    // TODO(#1386): This if-else can be nuked once we have nonces injected from public\n    if (nonce == 0) {\n        // If nonce is zero, that means we are reading a public note.\n        inner_note_hash\n    } else {\n        compute_unique_note_hash(nonce, inner_note_hash)\n    }\n}\n\npub fn compute_note_hash_for_read_request<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let inner_note_hash = compute_inner_note_hash(note);\n    let nonce = note.get_header().nonce;\n\n    compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, nonce)\n}\n\npub fn compute_note_hash_for_consumption<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    if (header.note_hash_counter != 0) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        inner_note_hash\n    } else {\n        // If a note is not transient, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the siloed_note_hash which has already been hashed with\n        // nonce and then contract address. This hash will match the existing leaf in the note hash\n        // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, header.nonce);\n        compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let M: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n    let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, note_header.nonce);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        let (_, nullifier) = note.compute_note_hash_and_nullifier_without_context();\n        nullifier\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [inner_note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"149":{"path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\ntrait CallInterface<let N: u32, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n"},"152":{"path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        _contract_address: AztecAddress,\n        _function_selector: FunctionSelector,\n        _args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(_self: Self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [\n        user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n        user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<let N: u32>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N as Field)\n}\n\nunconstrained fn storage_write<let N: u32>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<let N: u32>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<let N: u32>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<let N: u32> {\n    values: [Field; N]\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n"},"171":{"path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\n    recursion::verification_key::VerificationKey, traits::is_empty,\n    utils::field::field_from_bytes_32_trunc\n};\nuse std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    pedersen_hash(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"188":{"path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"210":{"path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"224":{"path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"235":{"path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"24":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"27":{"path":"std/hash/mod.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constraint the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::from_slice(domain_generators.as_slice());\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = crate::field::bn254::decompose_hint(scalar);\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n"},"276":{"path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x:fields[0], y: fields[1], is_infinite: fields[2] as bool},\n            sk_app: fields[3],\n        }\n    }\n}\n\n"},"287":{"path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"290":{"path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"304":{"path":"/home/g/Documents/Code/aztec-tutorials/aztec-txe/contracts/token/src/main.nr","source":"// docs:start:token_all\n// docs:start:imports\nmod types;\nmod test;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n\ncontract Token {\n    // Libs\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        hash::compute_secret_hash,\n        prelude::{NoteGetterOptions, Map, PublicMutable, SharedImmutable, PrivateSet, AztecAddress},\n        encrypted_logs::{\n        encrypted_note_emission::{\n        encode_and_encrypt_note, encode_and_encrypt_note_with_keys,\n        encode_and_encrypt_note_with_keys_unconstrained\n    },\n        encrypted_event_emission::{encode_and_encrypt_event, encode_and_encrypt_event_with_keys_unconstrained}\n    }\n    };\n\n    // docs:start:import_authwit\n    use dep::authwit::auth::{assert_current_call_valid_authwit, assert_current_call_valid_authwit_public, compute_authwit_nullifier};\n    // docs:end:import_authwit\n\n    use crate::types::{transparent_note::TransparentNote, token_note::{TokenNote, TOKEN_NOTE_LEN}, balances_map::BalancesMap};\n    // docs:end::imports\n\n    #[aztec(event)]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n    }\n\n    // docs:start:storage_struct\n    #[aztec(storage)]\n    struct Storage {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool>>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: BalancesMap<TokenNote>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128>,\n        // docs:start:storage_pending_shields\n        pending_shields: PrivateSet<TransparentNote>,\n        // docs:end:storage_pending_shields\n        public_balances: Map<AztecAddress, PublicMutable<U128>>,\n        symbol: SharedImmutable<FieldCompressedString>,\n        name: SharedImmutable<FieldCompressedString>,\n        // docs:start:storage_decimals\n        decimals: SharedImmutable<u8>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[aztec(public)]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_name() -> pub FieldCompressedString {\n        storage.name.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_name() -> pub FieldCompressedString {\n        storage.name.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_public\n        storage.decimals.read_public()\n        // docs:end:read_decimals_public\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_private\n        storage.decimals.read_private()\n        // docs:end:read_decimals_private\n    }\n\n    // docs:start:admin\n    #[aztec(public)]\n    #[aztec(view)]\n    fn admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[aztec(public)]\n    #[aztec(view)]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:total_supply\n    #[aztec(public)]\n    #[aztec(view)]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n\n    // docs:start:balance_of_public\n    #[aztec(public)]\n    #[aztec(view)]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n\n    // docs:start:set_minter\n    #[aztec(public)]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint_public\n    #[aztec(public)]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_public\n\n    // docs:start:mint_private\n    #[aztec(public)]\n    fn mint_private(amount: Field, secret_hash: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount, secret_hash);\n        let supply = storage.total_supply.read().add(U128::from_integer(amount));\n\n        storage.total_supply.write(supply);\n        // docs:start:insert_from_public\n        pending_shields.insert_from_public(&mut note);\n        // docs:end:insert_from_public\n    }\n    // docs:end:mint_private\n\n    // TODO: Nuke this - test functions do not belong to token contract!\n    #[aztec(private)]\n    fn privately_mint_private_note(amount: Field) {\n        let caller = context.msg_sender();\n        storage.balances.add(caller, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, caller, caller));\n\n        Token::at(context.this_address()).assert_minter_and_mint(context.msg_sender(), amount).enqueue(&mut context);\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn assert_minter_and_mint(minter: AztecAddress, amount: Field) {\n        assert(storage.minters.at(minter).read(), \"caller is not minter\");\n        let supply = storage.total_supply.read() + U128::from_integer(amount);\n        storage.total_supply.write(supply);\n    }\n\n    // docs:start:shield\n    #[aztec(public)]\n    fn shield(from: AztecAddress, amount: Field, secret_hash: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            // The redeem is only spendable once, so we need to ensure that you cannot insert multiple shields from the same message.\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount.to_field(), secret_hash);\n\n        storage.public_balances.at(from).write(from_balance);\n        pending_shields.insert_from_public(&mut note);\n    }\n    // docs:end:shield\n\n    // docs:start:transfer_public\n    #[aztec(public)]\n    fn transfer_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_public\n\n    // docs:start:burn_public\n    #[aztec(public)]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n\n    // docs:start:redeem_shield\n    #[aztec(private)]\n    fn redeem_shield(to: AztecAddress, amount: Field, secret: Field) {\n        let pending_shields = storage.pending_shields;\n        let secret_hash = compute_secret_hash(secret);\n        // Get 1 note (set_limit(1)) which has amount stored in field with index 0 (select(0, amount)) and secret_hash\n        // stored in field with index 1 (select(1, secret_hash)).\n        let mut options = NoteGetterOptions::new();\n        options = options.select(TransparentNote::properties().amount, amount, Option::none()).select(\n            TransparentNote::properties().secret_hash,\n            secret_hash,\n            Option::none()\n        ).set_limit(1);\n        let notes = pending_shields.get_notes(options);\n        let note = notes.get(0);\n        // Remove the note from the pending shields set\n        pending_shields.remove(note);\n\n        // Add the token note to user's balances set\n        // Note: Using context.msg_sender() as a sender below makes this incompatible with escrows because we send\n        // outgoing logs to that address and to send outgoing logs you need to get a hold of ovsk_m.\n        let from = context.msg_sender();\n        storage.balances.add(to, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, to));\n    }\n    // docs:end:redeem_shield\n\n    // docs:start:unshield\n    #[aztec(private)]\n    fn unshield(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.sub(from, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, from));\n\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:unshield\n\n    // docs:start:transfer\n    #[aztec(private)]\n    fn transfer(to: AztecAddress, amount: Field) {\n        let from = context.msg_sender();\n\n        // By fetching the keys here, we can avoid doing an extra read from the storage, since from_ovpk would\n        // be needed twice.\n        let header = context.get_header();\n        let from_ovpk = header.get_ovpk_m(&mut context, from);\n        let from_ivpk = header.get_ivpk_m(&mut context, from);\n        let to_ivpk = header.get_ivpk_m(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        storage.balances.sub(from, amount).emit(encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_ovpk, from_ivpk, from));\n        storage.balances.add(to, amount).emit(encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_ovpk, to_ivpk, to));\n\n        Transfer { from, to, amount: amount.to_field() }.emit(encode_and_encrypt_event_with_keys_unconstrained(&mut context, from_ovpk, to_ivpk, to));\n    }\n    // docs:end:transfer\n\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[aztec(private)]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier,0);\n    }\n    // docs:end:cancel_authwit\n\n    // docs:start:transfer_from\n    #[aztec(private)]\n    fn transfer_from(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n\n        // By fetching the keys here, we can avoid doing an extra read from the storage, since from_ovpk would\n        // be needed twice.\n        let header = context.get_header();\n        let from_ovpk = header.get_ovpk_m(&mut context, from);\n        let from_ivpk = header.get_ivpk_m(&mut context, from);\n        let to_ivpk = header.get_ivpk_m(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        storage.balances.sub(from, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_ovpk, from_ivpk, from));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        storage.balances.add(to, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_ovpk, to_ivpk, to));\n    }\n    // docs:end:transfer_from\n\n    // docs:start:burn\n    #[aztec(private)]\n    fn burn(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.sub(from, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, from));\n\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn\n\n    /// Internal ///\n\n    // docs:start:increase_public_balance\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n    // docs:end:increase_public_balance\n\n    // docs:start:reduce_total_supply\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n\n    /// Unconstrained ///\n\n    // docs:start:balance_of_private\n    unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.balance_of(owner).to_field()\n    }\n    // docs:end:balance_of_private\n\n    #[aztec(public)]\n    fn get_total_supply() -> pub Field {\n        storage.total_supply.read().to_integer()\n    }\n\n    #[aztec(public)]\n    fn get_balance_of_public(owner: AztecAddress) -> pub Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n}\n// docs:end:token_all"},"307":{"path":"/home/g/Documents/Code/aztec-tutorials/aztec-txe/contracts/token/src/types/transparent_note.nr","source":"// docs:start:token_types_all\nuse dep::aztec::{\n    note::{note_getter_options::PropertySelector, utils::compute_note_hash_for_consumption},\n    prelude::{NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash}\n};\n\nglobal TRANSPARENT_NOTE_LEN: Field = 2;\n// TRANSPARENT_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TRANSPARENT_NOTE_BYTES_LEN: Field = 2 * 32 + 64;\n\n// Transparent note represents a note that is created in the clear (public execution), but can only be spent by those\n// that know the preimage of the \"secret_hash\" (the secret). This is typically used when shielding a token balance.\n// Owner of the tokens provides a \"secret_hash\" as an argument to the public \"shield\" function and then the tokens\n// can be redeemed in private by presenting the preimage of the \"secret_hash\" (the secret).\n#[aztec(note)]\nstruct TransparentNote {\n    amount: Field,\n    secret_hash: Field,\n}\n\nstruct TransparentNoteProperties {\n    amount: PropertySelector,\n    secret_hash: PropertySelector,\n}\n\nimpl NoteInterface<TRANSPARENT_NOTE_LEN, TRANSPARENT_NOTE_BYTES_LEN> for TransparentNote {\n\n    // Custom serialization to avoid disclosing the secret field\n    fn serialize_content(self) -> [Field; TRANSPARENT_NOTE_LEN] {\n        [self.amount, self.secret_hash]\n    }\n\n    // Custom deserialization since we don't have access to the secret plaintext\n    fn deserialize_content(serialized_note: [Field; TRANSPARENT_NOTE_LEN]) -> Self {\n        TransparentNote {\n            amount: serialized_note[0],\n            secret_hash: serialized_note[1],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386): Ensure nullifier collisions are prevented\n    fn compute_note_hash_and_nullifier(self, _context: &mut PrivateContext) -> (Field, Field) {\n        self.compute_note_hash_and_nullifier_without_context()\n    }\n\n    // Computing a nullifier in a transparent note is not guarded by making secret a part of the nullifier preimage (as\n    // is common in other cases) and instead is guarded by the functionality of \"redeem_shield\" function. There we do\n    // the following:\n    //      1) We pass the secret as an argument to the function and use it to compute a secret hash,\n    //      2) we fetch a note via the \"get_notes\" oracle which accepts the secret hash as an argument,\n    //      3) the \"get_notes\" oracle constrains that the secret hash in the returned note matches the one computed in\n    //         circuit. \n    // This achieves that the note can only be spent by the party that knows the secret.\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl TransparentNote {\n    // CONSTRUCTORS\n    pub fn new(amount: Field, secret_hash: Field) -> Self {\n        TransparentNote { amount, secret_hash, header: NoteHeader::empty() }\n    }\n\n    // CUSTOM FUNCTIONS FOR THIS NOTE TYPE\n    // Custom serialization forces us to manually create the metadata struct and its getter\n    pub fn properties() -> TransparentNoteProperties {\n        TransparentNoteProperties {\n            amount: PropertySelector { index: 0, offset: 0, length: 32 },\n            secret_hash: PropertySelector { index: 1, offset: 0, length: 32 }\n        }\n    }\n}\n\nimpl Eq for TransparentNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) & (self.secret_hash == other.secret_hash)\n    }\n}\n\n// docs:end:token_types_all"},"309":{"path":"/home/g/Documents/Code/aztec-tutorials/aztec-txe/contracts/token/src/types/token_note.nr","source":"use dep::aztec::{\n    prelude::{AztecAddress, NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash},\n    note::utils::compute_note_hash_for_consumption, oracle::unsafe_rand::unsafe_rand,\n    keys::getters::get_nsk_app\n};\n\ntrait OwnedNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self;\n    fn get_amount(self) -> U128;\n}\n\nglobal TOKEN_NOTE_LEN: Field = 3; // 3 plus a header.\n// TOKEN_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TOKEN_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n#[aztec(note)]\nstruct TokenNote {\n    // The amount of tokens in the note\n    amount: U128,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n\nimpl NoteInterface<TOKEN_NOTE_LEN, TOKEN_NOTE_BYTES_LEN> for TokenNote {\n    // docs:start:nullifier\n    fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n    // docs:end:nullifier\n\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl OwnedNote for TokenNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self {\n        Self {\n            amount,\n            npk_m_hash: owner_npk_m_hash,\n            randomness: unsafe_rand(),\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn get_amount(self) -> U128 {\n        self.amount\n    }\n}\n\nimpl Eq for TokenNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) &\n        (self.npk_m_hash == other.npk_m_hash) &\n        (self.randomness == other.randomness)\n    }\n}"},"32":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"323":{"path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/value-note/src/value_note.nr","source":"use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::{Deserialize, Serialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_consumption},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n// VALUE_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal VALUE_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:value-note-def\n#[aztec(note)]\nstruct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN, VALUE_NOTE_BYTES_LEN> for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n\n    // docs:end:nullifier\n\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.npk_m_hash, self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value) &\n        (self.npk_m_hash == other.npk_m_hash) &\n        (self.randomness == other.randomness)\n    }\n}\n"},"43":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n"},"49":{"path":"std/slice.nr","source":"use crate::append::Append;\n\nimpl<T> [T] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    // Append each element of the `other` slice to the end of `self`.\n    // This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::unsafe::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T where T: Append {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"},"52":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (U128::uconstrained_check_is_upper_ascii(ascii) as u8);\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        } as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        let (q,r) = a.unconstrained_div(b);\n        assert_eq(q, c);\n        assert_eq(r, d);\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        let (c,d ) = a.unconstrained_div(b);\n        assert_eq((c, d), (a, U128::zero()));\n\n        // Check where b is a multiple of a\n        let (c,d) = b.unconstrained_div(a);\n        assert_eq((c, d), (U128::zero(), b));\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        let (c,d)= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::zero(), U128::zero()));\n\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        let (c,d )= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::one(), U128::zero()));\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"55":{"path":"/home/g/Documents/Code/aztec-tutorials/aztec-txe/contracts/myContract/src/main.nr","source":"mod test;\n\ncontract Vanhelsing {\n    use dep::token::Token;\n    use dep::aztec::{prelude::{PublicMutable, AztecAddress, Map}};\n\n    #[aztec(storage)]\n    struct Storage {\n        feeTo: PublicMutable<AztecAddress>,\n    }\n\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(\n        feeTo: AztecAddress,\n    ) {\n        storage.feeTo.write(feeTo);\n    }\n\n    #[aztec(public)]\n    fn createCoffin(\n        stakingToken: AztecAddress,\n        rewardsToken: AztecAddress,\n        periodInDays: Field,\n        rewardsAmount: Field,\n        nonce: Field\n    ) {\n\n        Token::at(rewardsToken).transfer_public(\n            context.msg_sender(),\n            context.this_address(),\n            rewardsAmount,\n            nonce\n        ).call(&mut context);\n\n    }\n\n}\n"},"59":{"path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/address-note/src/address_note.nr","source":"use dep::aztec::{\n    protocol_types::{address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_consumption},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal ADDRESS_NOTE_LEN: Field = 3;\n// ADDRESS_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal ADDRESS_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:address_note_def\n// Stores an address\n#[aztec(note)]\nstruct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n\nimpl NoteInterface<ADDRESS_NOTE_LEN, ADDRESS_NOTE_BYTES_LEN> for AddressNote {\n\n    fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n"},"68":{"path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/keys/getters.nr","source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::PrivateContext,\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}},\n    state_vars::{shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter}\n};\n\nglobal DELAY = 5;\n\n// docs:start:key-getters\ntrait KeyGetters {\n  fn get_npk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ivpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ovpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_tpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_npk_m_hash(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Field;\n}\n\nimpl KeyGetters for Header {\n    fn get_npk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, NULLIFIER_INDEX, self)\n    }\n\n    fn get_ivpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, INCOMING_INDEX, self)\n    }\n\n    fn get_ovpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, OUTGOING_INDEX, self)\n    }\n\n    fn get_tpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, TAGGING_INDEX, self)\n    }\n\n    fn get_npk_m_hash(self, context: &mut PrivateContext, address: AztecAddress) -> Field {\n        get_master_key(context, address, NULLIFIER_INDEX, self).hash()\n    }\n}\n// docs:end:key-getters\n\nfn get_master_key(\n    context: &mut PrivateContext,\n    address: AztecAddress,\n    key_index: Field,\n    header: Header\n) -> Point {\n    let key = fetch_key_from_registry(context, key_index, address, header);\n    if is_empty(key) {\n        // Keys were not registered in registry yet --> fetch key from PXE\n        let keys = fetch_and_constrain_keys(address);\n        // Return the corresponding to index\n        keys.get_key_by_index(key_index)\n    } else {\n        // Keys were registered --> return the key\n        key\n    }\n}\n\nfn fetch_key_from_registry(\n    context: &mut PrivateContext,\n    key_index: Field,\n    address: AztecAddress,\n    header: Header\n) -> Point {\n    let x_coordinate_map_slot = key_index * 2 + 1;\n    let y_coordinate_map_slot = x_coordinate_map_slot + 1;\n    let x_coordinate_derived_slot = derive_storage_slot_in_map(x_coordinate_map_slot, address);\n    let y_coordinate_derived_slot = derive_storage_slot_in_map(y_coordinate_map_slot, address);\n\n    let x_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        x_coordinate_derived_slot\n    );\n    let y_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        y_coordinate_derived_slot\n    );\n    let x_coordinate = x_coordinate_registry.get_value_in_private(header);\n    let y_coordinate = y_coordinate_registry.get_value_in_private(header);\n\n    Point { x: x_coordinate, y: y_coordinate, is_infinite: false }\n}\n\n// Passes only when keys were not rotated - is expected to be called only when keys were not registered yet\nfn fetch_and_constrain_keys(address: AztecAddress) -> PublicKeys {\n    let (public_keys, partial_address) = get_public_keys_and_partial_address(address);\n\n    let computed_address = AztecAddress::compute(public_keys.hash(), partial_address);\n\n    assert(computed_address.eq(address));\n\n    public_keys\n}\n\n// A helper function since requesting nsk_app is very common\n// TODO(#6543)\npub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n"},"74":{"path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"93":{"path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::{compute_siloed_nullifier, pedersen_hash},\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_contract_initialization_nullifier(context.this_address());\n    let header = context.get_header();\n    header.prove_nullifier_inclusion(init_nullifier);\n}\n\nfn compute_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    compute_siloed_nullifier(\n        address,\n        compute_unsiloed_contract_initialization_nullifier(address)\n    )\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    pedersen_hash(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"},"94":{"path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"}}}