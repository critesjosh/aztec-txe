{"transpiled":true,"noir_version":"0.33.0+47457412d9534885d98ff5ca22e9ec4f4b72f9c4","name":"Vanhelsing","functions":[{"name":"createCoffin","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"stakingToken","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"rewardsToken","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"periodInDays","type":{"kind":"field"},"visibility":"private"},{"name":"rewardsAmount","type":{"kind":"field"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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s8/n1dnn8+rs83l19vm8Ovt8Xp19Pm/OPp83Z5/Pm7PP583Z5/Pm7PO5fzTr17/j8f91TMudb2de5PmX52V9vfprVXq8n8PZ+zl9vZ/+WaCG72d29n6as/ezOHs/4uz9rM7ez+bs/Tj7fN6dfT7vzj6fD2efz4ezz+fjd/97124XHJuvt/O7/2vWwuE5+Xo7s6+303y9nf+eNJZvb0e0/9JfX2Kdv/4/X29oWZ9vSLy9odXbG9q8vaHd2xs6vL2h09cbWqbpd9/QJtP1hr595eTbG5q9vaHm7Q0t3t6QeHtDq7c3tHl7Q5/8pH78K47P/yvOj/8r5unz/4r58/+K9vl/xfL5f4V8/l+xfv5fsX3+X/H5/7rnz//XPX/+v+72+f+62+f/626f/6+7ff6/7vb5/7rbf/6vu71adJtX7TKsrFlL25y9n93Z+zmcvZ/T1/tZJmfv5z9/1v3dLxLa87/3eZ06IXdpvt7O4uvtiK+3s/p6O5uvt7P7ejuHr7dzuno7Mvl6O74+lcXXp7L4+lQWX5/K4utTWXx9KouvT2Xx9aksvj6VV1+fyquvT+XV16fy6utTefX1qbz6+lRefX0qr74+lVdfn8qrr0/lzden8ubrU3nz9am8+fpU3nx9Km++PpU3X5/Km69P5c3Xp/Lm61N59/WpvPv6VN59fSrvvj6Vd1+fyruvT+Xd16fy7utTeff1qbz7+lQ+fH0qH74+lQ9fn8qHr0/lw9en8uHrU/nw9al8+PpUPnx9Kh++PpVPX5/Kp69P5dPXp/Lp61P59PWpfPr6VD59fSqfvj6VT1+fyqerT2WZXH0qy+TqU1kmV5/KMrn6VJbJ1aeyTK4+lWVy9aksk6tPZZlcfSrL5OtTefb1qTz7+lSefX0qz74+lWdfn8qzr0/l2den8uzrU3n29ak8+/pUbr4+lZuvT+Xm61O5+fpUbr4+lZuvT+Xm61O5+fpUbr4+lZuvT+XF16eyr9/2ia/f9omv3/aJr9/2ia/f9omv3/aJr9/2ia/f9omv3/aJr9/2ia/f9omv3/aJr9/2ia/f9omv3/aJr9/2ia/f9omv3/aJr9/2ia/f9omv3/aJr9/2ia/f9omv3/aJr9/2ia/f9omv3/aJr9/2ia/f9omv3/aJr9/2ia/f9omv3/aJr9/2ia/f9omv3/aJr9/2ia/f9omv3/aJr9/2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"},{"name":"constructor","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(initializer)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"feeTo","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000006827b230"},{"kind":"string","value":"AddressNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000006827b230"},{"kind":"string","value":"AddressNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000006827b230"},{"kind":"string","value":"AddressNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000071421477"},{"kind":"string","value":"ValueNote"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"reject_all","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"approved_actions","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"minters","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"total_supply","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"pending_shields","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}},{"name":"public_balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}],"kind":"struct"}},{"name":"symbol","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}],"kind":"struct"}},{"name":"name","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}],"kind":"struct"}},{"name":"decimals","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"coffins","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"coffinId","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"feeTo","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"stakingToken","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"rewardsToken","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"periodInDays","type":{"kind":"field"}},{"name":"rewardsAmount","type":{"kind":"field"}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"Vanhelsing::createCoffin_parameters"}}],"kind":"struct","path":"Vanhelsing::createCoffin_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"feeTo","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Vanhelsing::constructor_parameters"}}],"kind":"struct","path":"Vanhelsing::constructor_abi"}]}},"file_map":{"103":{"path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"},"105":{"path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::{PrivateContext, UnconstrainedContext},\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{\n    public_keys::{PublicKeys, PUBLIC_KEYS_LENGTH}, stored_keys::StoredKeys,\n    constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}\n},\n    state_vars::{\n    shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter,\n    public_mutable::PublicMutable, map::Map\n}\n};\n\nmod test;\n\n// This is the number of blocks that must pass after a key rotation event until the old keys are fully phased out and\n// become invalid.\nglobal KEY_REGISTRY_UPDATE_BLOCKS = 5;\n\nglobal KEY_REGISTRY_STORAGE_SLOT = 1;\n\n// A helper function since requesting nsk_app is very common\n// TODO(#6543)\npub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// Returns all current public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_current_public_keys(context: &mut PrivateContext, account: AztecAddress) -> PublicKeys {\n    // We're going to perform historical reads from public storage, and so need to constrain the caller so that they\n    // cannot use very old blocks when constructing proofs, and hence e.g. read very old keys. We are lax and allow\n    // _any_ recent block number to be used, regardless of whether there may have been a recent key rotation. This means\n    // that multiple sets of keys are valid for a while immediately after rotation, until the old keys become phased\n    // out. We *must* be lax to prevent denial of service and transaction fingerprinting attacks by accounts that rotate\n    // their keys frequently.\n    // Note that we constrain the max block number even if the registry ends up being empty: this ensures that proof of\n    // an empty registry is also fresh.\n    let current_header = context.get_header();\n    context.set_tx_max_block_number(current_header.global_variables.block_number as u32 + KEY_REGISTRY_UPDATE_BLOCKS);\n\n    get_historical_public_keys(current_header, account)\n}\n\n// Returns historical public keys for a given account at some block determined by a block header. We read all keys at\n// once since the constraints for reading them all are actually fewer than if we read them one at a time - any read keys\n// that are not required by the caller can simply be discarded.\n// WARNING: if called with a historical header created from a fixed block this function will explicitly ignore key\n// rotation! This means that callers of this may force a user to use old keys, potentially leaking privacy (e.g. if the\n// old keys were leaked). Only call this function with a header from a fixed block if you understand the implications of\n// breaking key rotation very well.\npub fn get_historical_public_keys(historical_header: Header, account: AztecAddress) -> PublicKeys {\n    // TODO: improve this so that we always hint the correct set of keys (either registry or canonical) and hash them\n    // once instead of having two different hints and twice as many constraints due to the double hashing.\n\n    // The key registry is the primary source of information for keys, as that's where accounts store their new keys\n    // when they perform rotation. The key registry conveniently stores a hash of each user's keys, so we can read that\n    // single field and then prove that we know its preimage (i.e. the current set of keys).\n    let key_registry_hash = key_registry_hash_public_historical_read(historical_header, account);\n    if key_registry_hash != 0 {\n        let hinted_registry_public_keys = key_registry_get_stored_keys_hint(\n            account,\n            historical_header.global_variables.block_number as u32\n        );\n        assert_eq(hinted_registry_public_keys.hash().to_field(), key_registry_hash);\n\n        hinted_registry_public_keys\n    } else {\n        // If nothing was written to the registry, we may still be able to produce the correct keys if we happen to know\n        // the canonical set (i.e. the ones that are part of the account's preimage).\n        let (hinted_canonical_public_keys, partial_address) = get_public_keys_and_partial_address(account);\n        assert_eq(\n            account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n        );\n\n        hinted_canonical_public_keys\n    }\n}\n\nfn key_registry_hash_public_historical_read(historical_header: Header, account: AztecAddress) -> Field {\n    // The keys are stored in a Map that is keyed with the address of each account, so we first derive the corresponding\n    // slot for this account.\n    let keys_storage_slot = derive_storage_slot_in_map(KEY_REGISTRY_STORAGE_SLOT, account);\n\n    // The keys are stored as [ ...serialized_keys, hash ], and since arrays get allocated sequential storage slots\n    // (prior to siloing!), we simply add the length to the base slot to get the last element.\n    let hash_storage_slot = keys_storage_slot + PUBLIC_KEYS_LENGTH as Field;\n\n    historical_header.public_storage_historical_read(hash_storage_slot, CANONICAL_KEY_REGISTRY_ADDRESS)\n}\n\nunconstrained fn key_registry_get_stored_keys_hint(account: AztecAddress, block_number: u32) -> PublicKeys {\n    // This is equivalent to the key registry contract having an unconstrained getter that we call from an oracle, but\n    // PXE does not yet support that functionality so we do this manually instad. Note that this would be a *historical*\n    // call!\n\n    // TODO (#7524): call the unconstrained KeyRegistry.get_current_keys() function instead\n\n    let context = UnconstrainedContext::at_historical(CANONICAL_KEY_REGISTRY_ADDRESS, block_number);\n    let keys_storage = Map::new(\n        context,\n        KEY_REGISTRY_STORAGE_SLOT,\n        |context, slot| { PublicMutable::new(context, slot) }\n    );\n\n    let stored_keys: StoredKeys = keys_storage.at(account).read();\n    stored_keys.public_keys\n}\n"},"124":{"path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32, let M: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32, let M: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the \n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the \n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from \n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let M: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"130":{"path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"137":{"path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub fn get_key_validation_request(pk_m_hash: Field, key_index: Field) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n\n"},"147":{"path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"},"155":{"path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"192":{"path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"22":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\nstruct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint { \n        EmbeddedCurvePoint {\n            x: self.x,\n            y: -self.y,\n            is_infinite: self.is_infinite\n        }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite) | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\nstruct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n// This is a hack as returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\nfn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint\n) -> EmbeddedCurvePoint\n// docs:end:embedded_curve_add\n{\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n    EmbeddedCurvePoint { x, y, is_infinite: point_array[2] == 1 }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n"},"227":{"path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x:fields[0], y: fields[1], is_infinite: fields[2] as bool},\n            sk_app: fields[3],\n        }\n    }\n}\n\n"},"23":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"236":{"path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash_with_separator,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"24":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"245":{"path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"254":{"path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc, point::Point\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"27":{"path":"std/hash/mod.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\nmod sha256;\nmod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\nuse sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\ntrait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n"},"278":{"path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f);\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript = 0x2499880e2b1b831785c17286f99a0d5122fee784ce7b1c04e380c4a991da819a;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"},"289":{"path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"293":{"path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n"},"306":{"path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"307":{"path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"32":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"320":{"path":"/mnt/user-data/grego/repos/aztec-txe/contracts/token/src/main.nr","source":"// docs:start:token_all\n// docs:start:imports\nmod types;\nmod test;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n\ncontract Token {\n    // Libs\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        context::{PrivateContext, PrivateCallInterface}, hash::compute_secret_hash,\n        prelude::{\n        NoteGetterOptions, Map, PublicMutable, SharedImmutable, PrivateSet, AztecAddress,\n        FunctionSelector, NoteHeader, Point\n    },\n        encrypted_logs::{\n        encrypted_note_emission::{encode_and_encrypt_note_with_keys, encode_and_encrypt_note_with_keys_unconstrained},\n        encrypted_event_emission::{encode_and_encrypt_event, encode_and_encrypt_event_with_keys_unconstrained}\n    },\n        keys::getters::get_current_public_keys\n    };\n\n    // docs:start:import_authwit\n    use dep::authwit::auth::{assert_current_call_valid_authwit, assert_current_call_valid_authwit_public, compute_authwit_nullifier};\n    // docs:end:import_authwit\n\n    use crate::types::{\n        transparent_note::TransparentNote,\n        token_note::{TokenNote, TOKEN_NOTE_LEN, TokenNoteHidingPoint}, balances_map::BalancesMap\n    };\n    use dep::aztec::oracle::debug_log::debug_log_format;\n\n    // docs:end::imports\n\n    // In the first transfer iteration we are computing a lot of additional information (validating inputs, retrieving\n    // keys, etc.), so the gate count is already relatively high. We therefore only read a few notes to keep the happy\n    // case with few constraints.\n    global INITIAL_TRANSFER_CALL_MAX_NOTES = 2;\n    // All the recursive call does is nullify notes, meaning the gate count is low, but it is all constant overhead. We\n    // therefore read more notes than in the base case to increase the efficiency of the overhead, since this results in\n    // an overall small circuit regardless.\n    global RECURSIVE_TRANSFER_CALL_MAX_NOTES = 8;\n\n    #[aztec(event)]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n    }\n\n    // docs:start:storage_struct\n    #[aztec(storage)]\n    struct Storage {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool>>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: BalancesMap<TokenNote>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128>,\n        // docs:start:storage_pending_shields\n        pending_shields: PrivateSet<TransparentNote>,\n        // docs:end:storage_pending_shields\n        public_balances: Map<AztecAddress, PublicMutable<U128>>,\n        symbol: SharedImmutable<FieldCompressedString>,\n        name: SharedImmutable<FieldCompressedString>,\n        // docs:start:storage_decimals\n        decimals: SharedImmutable<u8>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[aztec(public)]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_name() -> pub FieldCompressedString {\n        storage.name.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_name() -> pub FieldCompressedString {\n        storage.name.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_public\n        storage.decimals.read_public()\n        // docs:end:read_decimals_public\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_private\n        storage.decimals.read_private()\n        // docs:end:read_decimals_private\n    }\n\n    // docs:start:admin\n    #[aztec(public)]\n    #[aztec(view)]\n    fn admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[aztec(public)]\n    #[aztec(view)]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:total_supply\n    #[aztec(public)]\n    #[aztec(view)]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n\n    // docs:start:balance_of_public\n    #[aztec(public)]\n    #[aztec(view)]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n\n    // docs:start:set_minter\n    #[aztec(public)]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint_public\n    #[aztec(public)]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_public\n\n    // docs:start:mint_private\n    #[aztec(public)]\n    fn mint_private(amount: Field, secret_hash: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount, secret_hash);\n        let supply = storage.total_supply.read().add(U128::from_integer(amount));\n\n        storage.total_supply.write(supply);\n        // docs:start:insert_from_public\n        pending_shields.insert_from_public(&mut note);\n        // docs:end:insert_from_public\n    }\n    // docs:end:mint_private\n\n    // TODO: Nuke this - test functions do not belong to token contract!\n    #[aztec(private)]\n    fn privately_mint_private_note(amount: Field) {\n        let caller = context.msg_sender();\n        let caller_keys = get_current_public_keys(&mut context, caller);\n        storage.balances.add(caller, caller_keys.npk_m, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note_with_keys(&mut context, caller_keys.ovpk_m, caller_keys.ivpk_m, caller)\n        );\n\n        Token::at(context.this_address()).assert_minter_and_mint(context.msg_sender(), amount).enqueue(&mut context);\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn assert_minter_and_mint(minter: AztecAddress, amount: Field) {\n        assert(storage.minters.at(minter).read(), \"caller is not minter\");\n        let supply = storage.total_supply.read() + U128::from_integer(amount);\n        storage.total_supply.write(supply);\n    }\n\n    // docs:start:shield\n    #[aztec(public)]\n    fn shield(from: AztecAddress, amount: Field, secret_hash: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            // The redeem is only spendable once, so we need to ensure that you cannot insert multiple shields from the same message.\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount.to_field(), secret_hash);\n\n        storage.public_balances.at(from).write(from_balance);\n        pending_shields.insert_from_public(&mut note);\n    }\n    // docs:end:shield\n\n    // docs:start:transfer_public\n    #[aztec(public)]\n    fn transfer_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            debug_log_format(\"assert_current_call_valid_authwit_public\", []);\n            debug_log_format(\"from {0}\", [from.to_field()]);\n            debug_log_format(\n                \"on_behalf_of/msg_sender {0}\",\n                [context.msg_sender().to_field()]\n            );\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_public\n\n    // docs:start:burn_public\n    #[aztec(public)]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n\n    // docs:start:redeem_shield\n    #[aztec(private)]\n    fn redeem_shield(to: AztecAddress, amount: Field, secret: Field) {\n        let secret_hash = compute_secret_hash(secret);\n\n        // Pop 1 note (set_limit(1)) which has an amount stored in a field with index 0 (select(0, amount)) and\n        // a secret_hash stored in a field with index 1 (select(1, secret_hash)).\n        let mut options = NoteGetterOptions::new();\n        options = options.select(TransparentNote::properties().amount, amount, Option::none()).select(\n            TransparentNote::properties().secret_hash,\n            secret_hash,\n            Option::none()\n        ).set_limit(1);\n\n        let notes = storage.pending_shields.pop_notes(options);\n        assert(notes.len() == 1, \"note not popped\");\n\n        // Add the token note to user's balances set\n        // Note: Using context.msg_sender() as a sender below makes this incompatible with escrows because we send\n        // outgoing logs to that address and to send outgoing logs you need to get a hold of ovsk_m.\n        let from = context.msg_sender();\n        let from_keys = get_current_public_keys(&mut context, from);\n        let to_keys = get_current_public_keys(&mut context, to);\n        storage.balances.add(to, to_keys.npk_m, U128::from_integer(amount)).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to));\n    }\n    // docs:end:redeem_shield\n\n    // docs:start:unshield\n    #[aztec(private)]\n    fn unshield(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let from_keys = get_current_public_keys(&mut context, from);\n        storage.balances.sub(from, from_keys.npk_m, U128::from_integer(amount)).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from));\n\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:unshield\n\n    // docs:start:transfer\n    #[aztec(private)]\n    fn transfer(to: AztecAddress, amount: Field) {\n        let from = context.msg_sender();\n\n        let from_keys = get_current_public_keys(&mut context, from);\n        let to_keys = get_current_public_keys(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n\n        // We reduce `from`'s balance by amount by recursively removing notes over potentially multiple calls. This\n        // method keeps the gate count for each individual call low - reading too many notes at once could result in\n        // circuits in which proving is not feasible.\n        // Since the sum of the amounts in the notes we nullified was potentially larger than amount, we create a new\n        // note for `from` with the change amount, e.g. if `amount` is 10 and two notes are nullified with amounts 8 and\n        // 5, then the change will be 3 (since 8 + 5 - 10 = 3).\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            from,\n            amount,\n            INITIAL_TRANSFER_CALL_MAX_NOTES\n        );\n\n        storage.balances.add(from, from_keys.npk_m, change).emit(\n            encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from)\n        );\n\n        storage.balances.add(to, to_keys.npk_m, amount).emit(\n            encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to)\n        );\n\n        // We don't constrain encryption of the note log in `transfer` (unlike in `transfer_from`) because the transfer\n        // function is only designed to be used in situations where the event is not strictly necessary (e.g. payment to\n        // another person where the payment is considered to be successful when the other party successfully decrypts a\n        // note).\n        Transfer { from, to, amount: amount.to_field() }.emit(\n            encode_and_encrypt_event_with_keys_unconstrained(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to)\n        );\n    }\n    // docs:end:transfer\n\n    #[contract_library_method]\n    fn subtract_balance(\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n        account: AztecAddress,\n        amount: U128,\n        max_notes: u32\n    ) -> U128 {\n        let subtracted = storage.balances.try_sub(account, amount, max_notes);\n\n        // Failing to subtract any amount means that the owner was unable to produce more notes that could be nullified.\n        // We could in some cases fail early inside try_sub if we detected that fewer notes than the maximum were\n        // returned and we were still unable to reach the target amount, but that'd make the code more complicated, and\n        // optimizing for the failure scenario is not as important.\n        assert(subtracted > U128::from_integer(0), \"Balance too low\");\n\n        if subtracted >= amount {\n            // We have achieved our goal of nullifying notes that add up to more than amount, so we return the change\n            subtracted - amount\n        } else {\n            // try_sub failed to nullify enough notes to reach the target amount, so we compute the amount remaining\n            // and try again.\n            let remaining = amount - subtracted;\n            compute_recurse_subtract_balance_call(*context, account, remaining).call(context)\n        }\n    }\n\n    // TODO(#7729): apply no_predicates to the contract interface method directly instead of having to use a wrapper\n    // like we do here.\n    #[no_predicates]\n    #[contract_library_method]\n    fn compute_recurse_subtract_balance_call(\n        context: PrivateContext,\n        account: AztecAddress,\n        remaining: U128\n    ) -> PrivateCallInterface<25, U128, (AztecAddress, Field)> {\n        Token::at(context.this_address())._recurse_subtract_balance(account, remaining.to_field())\n    }\n\n    // TODO(#7728): even though the amount should be a U128, we can't have that type in a contract interface due to\n    // serialization issues.\n    #[aztec(internal)]\n    #[aztec(private)]\n    fn _recurse_subtract_balance(account: AztecAddress, amount: Field) -> U128 {\n        subtract_balance(\n            &mut context,\n            storage,\n            account,\n            U128::from_integer(amount),\n            RECURSIVE_TRANSFER_CALL_MAX_NOTES\n        )\n    }\n\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[aztec(private)]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier);\n    }\n    // docs:end:cancel_authwit\n\n    // docs:start:transfer_from\n    #[aztec(private)]\n    fn transfer_from(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n\n        let from_keys = get_current_public_keys(&mut context, from);\n        let to_keys = get_current_public_keys(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        storage.balances.sub(from, from_keys.npk_m, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        storage.balances.add(to, to_keys.npk_m, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to));\n    }\n    // docs:end:transfer_from\n\n    // docs:start:burn\n    #[aztec(private)]\n    fn burn(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let from_keys = get_current_public_keys(&mut context, from);\n        storage.balances.sub(from, from_keys.npk_m, U128::from_integer(amount)).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from));\n\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn\n\n    /// We need to use different randomness for the user and for the fee payer notes because if the randomness values\n    /// were the same we could fingerprint the user by doing the following:\n    ///      1) randomness_influence = fee_payer_point - G_npk * fee_payer_npk =\n    ///                              = (G_npk * fee_payer_npk + G_rnd * randomness) - G_npk * fee_payer_npk =\n    ///                              = G_rnd * randomness\n    ///      2) user_fingerprint = user_point - randomness_influence =\n    ///                          = (G_npk * user_npk + G_rnd * randomness) - G_rnd * randomness =\n    ///                          = G_npk * user_npk\n    ///      3) Then the second time the user would use this fee paying contract we would recover the same fingerprint\n    ///         and link that the 2 transactions were made by the same user. Given that it's expected that only\n    ///         a limited set of fee paying contracts will be used and they will be known, searching for fingerprints\n    ///         by trying different fee payer npk values of these known contracts is a feasible attack.\n    ///\n    /// `fee_payer_point` and `user_point` above are public information because they are passed as args to the public\n    /// `complete_refund(...)` function.\n    #[aztec(private)]\n    fn setup_refund(\n        fee_payer: AztecAddress, // Address of the entity which will receive the fee note.\n        user: AztecAddress, // A user for which we are setting up the fee refund.\n        funded_amount: Field, // The amount the user funded the fee payer with (represents fee limit).\n        user_randomness: Field, // A randomness to mix in with the generated refund note for the sponsored user.\n        fee_payer_randomness: Field // A randomness to mix in with the generated fee note for the fee payer.\n    ) {\n        // 1. This function is called by fee paying contract (fee_payer) when setting up a refund so we need to support\n        // the authwit flow here and check that the user really permitted fee_payer to set up a refund on their behalf.\n        assert_current_call_valid_authwit(&mut context, user);\n\n        // 2. Get all the relevant keys\n        let fee_payer_npk_m_hash = get_current_public_keys(&mut context, fee_payer).npk_m.hash();\n        let user_keys = get_current_public_keys(&mut context, user);\n        let user_npk_m_hash = user_keys.npk_m.hash();\n\n        // 3. Deduct the funded amount from the user's balance - this is a maximum fee a user is willing to pay\n        // (called fee limit in aztec spec). The difference between fee limit and the actual tx fee will be refunded \n        // to the user in the `complete_refund(...)` function.\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            user,\n            U128::from_integer(funded_amount),\n            INITIAL_TRANSFER_CALL_MAX_NOTES\n        );\n        storage.balances.add(user, user_keys.npk_m, change).emit(\n            encode_and_encrypt_note_with_keys_unconstrained(&mut context, user_keys.ovpk_m, user_keys.ivpk_m, user)\n        );\n\n        // 4. We create the partial notes for the fee payer and the user.\n        // --> Called \"partial\" because they don't have the amount set yet (that will be done in `complete_refund(...)`).\n        let fee_payer_partial_note = TokenNote {\n            header: NoteHeader {\n                contract_address: AztecAddress::zero(),\n                nonce: 0,\n                storage_slot: storage.balances.map.at(fee_payer).storage_slot,\n                note_hash_counter: 0\n            },\n            amount: U128::zero(),\n            npk_m_hash: fee_payer_npk_m_hash,\n            randomness: fee_payer_randomness\n        };\n        let user_partial_note = TokenNote {\n            header: NoteHeader {\n                contract_address: AztecAddress::zero(),\n                nonce: 0,\n                storage_slot: storage.balances.map.at(user).storage_slot,\n                note_hash_counter: 0\n            },\n            amount: U128::zero(),\n            npk_m_hash: user_npk_m_hash,\n            randomness: user_randomness\n        };\n\n        // 5. Now we get the note hiding points.\n        let mut fee_payer_point = fee_payer_partial_note.to_note_hiding_point();\n        let mut user_point = user_partial_note.to_note_hiding_point();\n\n        // 6. Set the public teardown function to `complete_refund(...)`. Public teardown is the only time when a public\n        // function has access to the final transaction fee, which is needed to compute the actual refund amount.\n        context.set_public_teardown_function(\n            context.this_address(),\n            FunctionSelector::from_signature(\"complete_refund(((Field,Field,bool)),((Field,Field,bool)),Field)\"),\n            [\n            fee_payer_point.inner.x, fee_payer_point.inner.y, fee_payer_point.inner.is_infinite as Field, user_point.inner.x, user_point.inner.y, user_point.inner.is_infinite as Field, funded_amount\n        ]\n        );\n    }\n\n    // TODO(#7728): even though the funded_amount should be a U128, we can't have that type in a contract interface due\n    // to serialization issues.\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn complete_refund(\n        // TODO(#7771): the following makes macros crash --> try getting it work once we migrate to metaprogramming\n        // mut fee_payer_point: TokenNoteHidingPoint,\n        // mut user_point: TokenNoteHidingPoint,\n        fee_payer_point_immutable: TokenNoteHidingPoint,\n        user_point_immutable: TokenNoteHidingPoint,\n        funded_amount: Field\n    ) {\n        // TODO(#7771): nuke the following 2 lines once we have mutable args\n        let mut fee_payer_point = fee_payer_point_immutable;\n        let mut user_point = user_point_immutable;\n\n        // TODO(#7728): Remove the next line\n        let funded_amount = U128::from_integer(funded_amount);\n        let tx_fee = U128::from_integer(context.transaction_fee());\n\n        // 1. We check that user funded the fee payer contract with at least the transaction fee.\n        // TODO(#7796): we should try to prevent reverts here\n        assert(funded_amount >= tx_fee, \"funded amount not enough to cover tx fee\");\n\n        // 2. We compute the refund amount as the difference between funded amount and tx fee.\n        let refund_amount = funded_amount - tx_fee;\n\n        // 3. We add fee to the fee payer point and refund amount to the user point.\n        fee_payer_point.add_amount(tx_fee);\n        user_point.add_amount(refund_amount);\n\n        // 4. We finalize the hiding points to get the note hashes.\n        let fee_payer_note_hash = fee_payer_point.finalize();\n        let user_note_hash = user_point.finalize();\n\n        // 5. At last we emit the note hashes.\n        context.push_note_hash(fee_payer_note_hash);\n        context.push_note_hash(user_note_hash);\n        // --> Once the tx is settled user and fee recipient can add the notes to their pixies.\n    }\n\n    /// Internal ///\n\n    // docs:start:increase_public_balance\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n    // docs:end:increase_public_balance\n\n    // docs:start:reduce_total_supply\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n\n    /// Unconstrained ///\n\n    // docs:start:balance_of_private\n    unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.balance_of(owner).to_field()\n    }\n    // docs:end:balance_of_private\n\n    #[aztec(public)]\n    fn get_total_supply() -> pub Field {\n        storage.total_supply.read().to_integer()\n    }\n\n    #[aztec(public)]\n    fn get_balance_of_public(owner: AztecAddress) -> pub Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n}\n\n// docs:end:token_all"},"334":{"path":"/mnt/user-data/grego/repos/aztec-txe/contracts/token/src/types/token_note.nr","source":"use dep::aztec::{\n    generators::{Ga1 as G_amt, Ga2 as G_npk, Ga3 as G_rnd, G_slot},\n    prelude::{NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{\n    constants::GENERATOR_INDEX__NOTE_NULLIFIER, point::{Point, POINT_LENGTH}, scalar::Scalar,\n    hash::poseidon2_hash_with_separator, traits::Serialize\n},\n    note::utils::compute_note_hash_for_nullify, oracle::unsafe_rand::unsafe_rand,\n    keys::getters::get_nsk_app\n};\nuse dep::std::{embedded_curve_ops::multi_scalar_mul, hash::from_field_unsafe};\n\ntrait OwnedNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self;\n    fn get_amount(self) -> U128;\n}\n\nglobal TOKEN_NOTE_LEN: Field = 3; // 3 plus a header.\nglobal TOKEN_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n#[aztec(note)]\nstruct TokenNote {\n    // The amount of tokens in the note\n    amount: U128,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n\nimpl NoteInterface<TOKEN_NOTE_LEN, TOKEN_NOTE_BYTES_LEN> for TokenNote {\n    // docs:start:nullifier\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([note_hash_for_nullify, secret],GENERATOR_INDEX__NOTE_NULLIFIER)\n    }\n\n    fn compute_note_hiding_point(self) -> Point {\n        // We use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        let amount_scalar = from_field_unsafe(self.amount.to_integer());\n        let npk_m_hash_scalar = from_field_unsafe(self.npk_m_hash);\n        let randomness_scalar = from_field_unsafe(self.randomness);\n        let slot_scalar = from_field_unsafe(self.header.storage_slot);\n        // We compute the note hiding point as:\n        //     `G_amt * amount + G_npk * npk_m_hash + G_rnd * randomness + G_slot * slot`\n        // instead of using pedersen or poseidon2 because it allows us to privately add and subtract from amount\n        // in public by leveraging homomorphism.\n        multi_scalar_mul(\n            [G_amt, G_npk, G_rnd, G_slot],\n            [amount_scalar, npk_m_hash_scalar, randomness_scalar, slot_scalar]\n        )\n    }\n}\n\nimpl TokenNote {\n    // TODO: Merge this func with `compute_note_hiding_point`. I (benesjan) didn't do it in the initial PR to not have\n    // to modify macros and all the related funcs in it.\n    fn to_note_hiding_point(self) -> TokenNoteHidingPoint {\n        TokenNoteHidingPoint::new(self.compute_note_hiding_point())\n    }\n}\n\nstruct TokenNoteHidingPoint {\n  inner: Point\n}\n\nimpl TokenNoteHidingPoint {\n    fn new(point: Point) -> Self {\n        Self { inner: point }\n    }\n\n    fn add_amount(&mut self, amount: U128) {\n        self.inner = multi_scalar_mul([G_amt], [from_field_unsafe(amount.to_integer())]) + self.inner;\n    }\n\n    fn add_npk_m_hash(&mut self, npk_m_hash: Field) {\n        self.inner = multi_scalar_mul([G_npk], [from_field_unsafe(npk_m_hash)]) + self.inner;\n    }\n\n    fn add_randomness(&mut self, randomness: Field) {\n        self.inner = multi_scalar_mul([G_rnd], [from_field_unsafe(randomness)]) + self.inner;\n    }\n\n    fn add_slot(&mut self, slot: Field) {\n        self.inner = multi_scalar_mul([G_slot], [from_field_unsafe(slot)]) + self.inner;\n    }\n\n    fn finalize(self) -> Field {\n        self.inner.x\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TokenNoteHidingPoint {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Eq for TokenNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) &\n        (self.npk_m_hash == other.npk_m_hash) &\n        (self.randomness == other.randomness)\n    }\n}\n\nimpl OwnedNote for TokenNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self {\n        Self {\n            amount,\n            npk_m_hash: owner_npk_m_hash,\n            randomness: unsafe_rand(),\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn get_amount(self) -> U128 {\n        self.amount\n    }\n}"},"335":{"path":"/mnt/user-data/grego/repos/aztec-txe/contracts/token/src/types/transparent_note.nr","source":"// docs:start:token_types_all\nuse dep::aztec::{\n    note::{note_getter_options::PropertySelector, utils::compute_note_hash_for_nullify},\n    prelude::{NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator}\n};\n\nglobal TRANSPARENT_NOTE_LEN: Field = 2;\n// TRANSPARENT_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TRANSPARENT_NOTE_BYTES_LEN: Field = 2 * 32 + 64;\n\n// Transparent note represents a note that is created in the clear (public execution), but can only be spent by those\n// that know the preimage of the \"secret_hash\" (the secret). This is typically used when shielding a token balance.\n// Owner of the tokens provides a \"secret_hash\" as an argument to the public \"shield\" function and then the tokens\n// can be redeemed in private by presenting the preimage of the \"secret_hash\" (the secret).\n#[aztec(note)]\nstruct TransparentNote {\n    amount: Field,\n    secret_hash: Field,\n}\n\nstruct TransparentNoteProperties {\n    amount: PropertySelector,\n    secret_hash: PropertySelector,\n}\n\nimpl NoteInterface<TRANSPARENT_NOTE_LEN, TRANSPARENT_NOTE_BYTES_LEN> for TransparentNote {\n\n    // Custom serialization to avoid disclosing the secret field\n    fn serialize_content(self) -> [Field; TRANSPARENT_NOTE_LEN] {\n        [self.amount, self.secret_hash]\n    }\n\n    // Custom deserialization since we don't have access to the secret plaintext\n    fn deserialize_content(serialized_note: [Field; TRANSPARENT_NOTE_LEN]) -> Self {\n        TransparentNote {\n            amount: serialized_note[0],\n            secret_hash: serialized_note[1],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn compute_nullifier(self, _context: &mut PrivateContext, _note_hash_for_nullify: Field) -> Field {\n        self.compute_nullifier_without_context()\n    }\n\n    // Computing a nullifier in a transparent note is not guarded by making secret a part of the nullifier preimage (as\n    // is common in other cases) and instead is guarded by the functionality of \"redeem_shield\" function. There we do\n    // the following:\n    //      1) We pass the secret as an argument to the function and use it to compute a secret hash,\n    //      2) we fetch a note via the \"get_notes\" oracle which accepts the secret hash as an argument,\n    //      3) the \"get_notes\" oracle constrains that the secret hash in the returned note matches the one computed in\n    //         circuit. \n    // This achieves that the note can only be spent by the party that knows the secret.\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl TransparentNote {\n    // CONSTRUCTORS\n    pub fn new(amount: Field, secret_hash: Field) -> Self {\n        TransparentNote { amount, secret_hash, header: NoteHeader::empty() }\n    }\n\n    // CUSTOM FUNCTIONS FOR THIS NOTE TYPE\n    // Custom serialization forces us to manually create the metadata struct and its getter\n    pub fn properties() -> TransparentNoteProperties {\n        TransparentNoteProperties {\n            amount: PropertySelector { index: 0, offset: 0, length: 32 },\n            secret_hash: PropertySelector { index: 1, offset: 0, length: 32 }\n        }\n    }\n}\n\nimpl Eq for TransparentNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) & (self.secret_hash == other.secret_hash)\n    }\n}\n\n// docs:end:token_types_all"},"343":{"path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/value-note/src/value_note.nr","source":"use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::{Deserialize, Serialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n// VALUE_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal VALUE_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:value-note-def\n#[aztec(note)]\nstruct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN, VALUE_NOTE_BYTES_LEN> for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret,\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    /// The following method needed to be implemented because the note is passed as an argument to a contract function\n    /// --> the serialize method is called by aztec-nr when computing an arguments hash.\n    /// Note that when the note is about to be encrypted and emitted as a log the to_be_bytes function auto-implemented\n    /// by aztec macros is called instead.\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.npk_m_hash, self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value) &\n        (self.npk_m_hash == other.npk_m_hash) &\n        (self.randomness == other.randomness)\n    }\n}\n"},"53":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n"},"59":{"path":"std/slice.nr","source":"use crate::append::Append;\n\nimpl<T> [T] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    // Append each element of the `other` slice to the end of `self`.\n    // This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T where T: Append {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"},"62":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        (if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (unsafe {\n                        U128::uconstrained_check_is_upper_ascii(ascii) as u8\n                    });\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        }) as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            \n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        unsafe {\n            let (q,r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        unsafe {\n            let (c,d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        unsafe {\n            let (c, d)= a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"65":{"path":"/mnt/user-data/grego/repos/aztec-txe/contracts/myContract/src/main.nr","source":"mod test;\nmod coffin;\nmod stake;\n\ncontract Vanhelsing {\n    use dep::token::Token;\n    use dep::aztec::{prelude::{PublicMutable, AztecAddress, Map}};\n    use crate::coffin::{Vampire, Coffin};\n\n    #[aztec(storage)]\n    struct Storage {\n        coffins: Map<u64, PublicMutable<Coffin>>,\n        coffinId: PublicMutable<u64>,\n        feeTo: PublicMutable<AztecAddress>,\n    }\n\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(feeTo: AztecAddress) {\n        storage.feeTo.write(feeTo);\n    }\n\n    #[aztec(public)]\n    fn createCoffin(\n        stakingToken: AztecAddress,\n        rewardsToken: AztecAddress,\n        periodInDays: Field,\n        rewardsAmount: Field,\n        nonce: Field\n    ) {\n        Token::at(rewardsToken).transfer_public(\n            context.msg_sender(),\n            context.this_address(),\n            rewardsAmount,\n            nonce\n        ).call(&mut context);\n\n        let currentcoffinId = storage.coffinId.read();\n\n        let coffin_storage = storage.coffins.at(currentcoffinId);\n        let mut coffin_data = coffin_storage.read(); // <======== Failed assertion\n    }\n}\n"},"70":{"path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/address-note/src/address_note.nr","source":"use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal ADDRESS_NOTE_LEN: Field = 3;\n// ADDRESS_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal ADDRESS_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[aztec(note)]\nstruct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NoteInterface<ADDRESS_NOTE_LEN, ADDRESS_NOTE_BYTES_LEN> for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n"},"72":{"path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\ntrait CallInterface<let N: u32, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n"},"82":{"path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        _contract_address: AztecAddress,\n        _function_selector: FunctionSelector,\n        _args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(_self: Self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [\n        user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n        user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<let N: u32>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N as Field)\n}\n\nunconstrained fn storage_write<let N: u32>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<let N: u32>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<let N: u32>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<let N: u32> {\n    values: [Field; N]\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n"}}}