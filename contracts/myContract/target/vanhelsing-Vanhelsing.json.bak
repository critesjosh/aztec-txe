{"noir_version":"0.33.0+61d6f251ea67204af2d17175f120e17f2e9e9156","name":"Vanhelsing","functions":[{"name":"constructor","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(initializer)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"feeTo","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"createCoffin","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"stakingToken","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"rewardsToken","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"periodInDays","type":{"kind":"field"},"visibility":"private"},{"name":"rewardsAmount","type":{"kind":"field"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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O5KU3etrJCm719dIUnavr5Gk7F5fI0nZvX5Bcnevc3b3+gRJTvd6nte4lSdIUrrXur1CktK9vkYiIPkdScru9aqjt7XckaTsXl8jSdm9vkaSsnt9jSRl9/oSScnoXhUkGd2rgiSje1WQdPAl8zo/UtSiIFn369ddvnzdYpnO9WzO1rM7W091tp7jm9fz8eTtstlyX88yOVvP7Gw9xdl6FmfrEWfrWb99PeeWtU3bk/VsztazO1tPdbaew9d6ZHK2ntnZeoqz9SzO1iPO1uPs/izO7s/i7P4szu7P4uz+vDq7P6/O7s+rs/vz6uz+vDq7P6/O7s+NA0hLuc6JkGnpuZ55vp5LzWX6UivJzwUdzhbUOG7TcEGztwUVbwtavC1IvC1o9bagzduCdm8L8nan3rzdqXdvd+rd251693an3r3dqXdvd+rd2516/+5/9soTnzo5W893/0grDr+Ks/WsztazOVvP7mw9PXzH8mU9ot2AtnJ+cn38qvxWfy7ncLWcY/K1nNnXcoqv5Sy+liO+lrN+93KubzuUebkvZ/O1nN3Xcqqv5RyellOnyddyZl/L+e67clnORFG+/CLhtZzF13LE13JWX8vZfC1n97Wc6ms5770r//V3zNM3/B3zN/wd5Rv+juUb/g75hr9j/Ya/Y/uGv2P/hr+jfsPf8Q3/zss3/Dsv3/DvvHzDv/PyDf/Oyzf8Oy/f8O+8fMO/8/IN/87LN/w7L9/w73zp8O+8PBrFMmtvPDmuD57vDmaZXa2muFrN4mo14mo1q6vVbK5W0+Fu+I++dTg/Xmkk23051ddyDlfLkcnXcmZfyym+lrP4Wo74Ws7qazmbr+X4uiuLr7uy+Lorr77uyquvu/Lq6668+rorr77uyquvu/Lq6668+rorr77uyquvu/Lm6668+borb77uypuvu/Lm6668+borb77uypuvu/Lm6668+bor777uyruvu/Lu6668+7or777uyruvu/Lu6668+7or777uyruvu3L1dVeuvu7K1dddufq6K1dfd+Xq665cfd2Vq6+7cvV1V66+7sqHr7vy4euufPi6Kx++7sqHr7vy4euufPi6Kx++7sqHr7vy4equfEyu7srH5OqufEyu7srH5OqufEyu7srH5OqufEyu7srH5OqufEyu7srH5OuuPPu6K8++7sqzr7vy7OuuPPu6K8++7sqzr7vy7OuuPPu6K8++7srF1125+LorF1935eLrrlx83ZWLr7ty8XVXLr7uysXXXbn4uisvvu7Ki6+78uLrrrz4uisvvu7Ki6+78uLrruzru32Hr+/2Hb6+23f4+m7f4eu7fYev7/Ydvr7bd/j6bt/h67t9h6/v9h2+vtt3+Ppu3+Hru32Hr+/2Hb6+23f4+m7f4eu7fYev7/Ydvr7bd/j6bt/h67t9h6/v9h2+vtt3+Ppu3+Hru32Hr+/2Hb6+23f4+m7f4eu7fYev7/Ydvr7bd/j6bt/h67t9h6/v9h2+vtt3+Ppu3+Hru32Hr+/2Hb6+23f4+m7f4eu7fce3f7evyPnmjGWavy7nfqlM83nCpkxfDuUu+5OL9/Ucc6+Pzy3L08891ytFubTu52prfUxW5Cnnl2/7Or79a4tpSX/7NzLzkp4h/U2kC6S/ifQC6W8iLZC+Lv0ksiYksp7DyddPPYlsEPmNyA6R34hkzDCviWTMGvVcgtTlRuTImAleE8no3V8TyeixXxNJ6IXX6bx0neqdiEDkNyIJPatCJKFnVYgk9KyviNRpSuhH1nLWAWt5QiShH1GIJNxrtuU417uWO5GEe41CxPNeMy/nlDLv61cin2v3vCtoa/fcOWhr99wOKGufPe+b2to973Da2j1nY23tnlOstnZxvfb55do979bzvDzWvt3X7npfVdbuel9V1v7d++oicq5nL6/XPk9LvZYxiXz56Pr8N6/K9atX81ebd8565Jn120+zsZx1TjRrSTTrkmhWSTTrmmjWLdGse6JZE/mmksg3LYl805LINy2JfNOSyDd9+xlflrMm8k3LUL7pmK9Zj+M+61C+SZl1KN+kzDqUb3o9qwzlm5RZh/JNyqxD+SZl1qF802PWX74LdM4qiWYdyTeV6bhmnff7rCP5Jm3WkXyTNutIvkmbdSTfpMy6juSbtFlH8k3arCP5pq+zlnKfdSzfND1mXe6zjrS/Lsv5eyTzItN91pH2V23WkfZXbdaR9ldl1m2k/VWbdaT9VZt1pP1Vm3Wk/XWR9Zp1ve+v337iqeWsI/US2qxD+SZl1qF8kzLrUL5JmXUo3/R61m8/aW6dzk9ej/p61uXjE35eu8z1S/YuP9deAq99Cbx2Cbz2NfDat8Br3wOvvQZe+xF37d9+tlTPtQfeV4/A++oReF/99jOQeq498L56BN5Xj8D76hF4Xz3i7qvzFHdfnae4++o8xd1XP2qHwGuPu6/OU9x9dZ7i7qvzFHdfnae4++o8Bd5X58D76hx4X50D76tz4H31289Q6rn2wPvqHHhfnQPvq3PgfXUOvK+WwPtq8byvlusVhktZ5vvaPe+r2to976va2j3vq9raPe+r2to976va2j3vq9raPe+rZdmuta/Tfe2e91Vl7YvnfVVbu+t9VVm7631VWbvrfVVZu+t9VVm76311W6+178d97a73VWXtrvdVZe2u91Vl7a731ddrF9f7qrJ21/uqsnbX++qXtT/pCcT1vqqs3fW+qqz9u/fVbT6/A7bJ9nrt8zRf73me5Je13y8Wub5cJvLsH8eWZdA9y6A1y6BHkkG//ZAQs0HnYQY9ziXLOt23l28/HsRs0CXLoJJl0HGckTLoOM5IGbSHM7qO4NtEVmXQ+biK//moj22g8VXVab7AfPz3l5cy/rj+c4IafoIj+gRdTlqxnWAOP0EJP8ESfgIJP8EafoIt/ATh9+Qt/J68ud+T1/qYYJ+16+t+HflRj8dalp82cHe/gfcd1/1u33dc99ag77jufUTfcSXXuO4dSt9x3duZvuO69z59x3VvlPqOm8tV1VyuquZyVTWXq6q5XFWXA+0CjZvLVdVcrqrmclU1l6uquVzVkctVHblc1ZHLVR25XFWX4wwDjZvLVR25XNWRy1UduVzVkcpVlSmVqypTKldVprH23TJv58I//lPu446176rjjrXvquOOte+q446176rjjrXvauPOY+276rhj7bvquGO1Geq4Y7UZ6riSa9xcrmrO5armXK5qzuWq5lyuquRyVSWXqyq5XFXJ5aq6HHUaaNxcrqrkclUll6squVxVyeWqllyuasnlqpZcrmrJ5aoW7xtR+fKV3A8P+Mv1nxN431vUCcT7DaXsXyao27+6/nNi7/eU/hN7v630n1jSTew9svWf2Htq6z+x+/2y+8Tu99fuE3uPb90nXr0nuP4Tp/NcazrPtabzXF1OHI01cTrPtabzXO4PI+0/cTrP5f6w0+4Tuz8ctf/EY3muj8c851o+ngk8itizWnV/8mrnccdyWx+PaKfHuOU+7ljb8IdZPj/94z/rfdyx9mB13LE2YHXcsXZfbVz3x5p2HnewfVcbd7B9Vxt3sH1XG1dyjTtWv6GOm8tVuT/WtPO4uWyG+3M+O4+by2a4PwnyH45b6xXvj2n6Ou794kXm61WpIvdw7P7YSEs2g21xXdkMth92ZTNYJdGVzWDGoicb9+diWrIZzLJ0ZTNYjdKVzWCdS1c2iffwWuTntR970p1M4h38JZllkrxkjmvdx/2EvsX9kXV2ZBL/a5qneXp89nJnk9gPa2zcn6xmySaxH1bZJPbDKpvEflhlI7BpsknsblQ2iXtilU3ijKmySe2L92vKj4nvbFL74tds3J+NZ8kmtS9W2KT2xQqb1L5YYSOwabJJ7YsVNql9scImtS9W2OCL22zwxU027k83tGSDL26zwRe32eCL22wENk02+OI2m8y++MuUX4/YvNhk9sUam8y+WGOT2RcrbCSzL9bYZPbFGpvMvlhjk9kXa2wENk02mX2xxgZf3GaDL26zwRe32eCLm2wGO0u5Lxt8cZsNvrjNJvUevj7YrPudTeo9/DWbwc5Y/YdsHp9dfnzc72xS34sVNqnvxQqb1B2FwkZg02STuqNQ2KT2Nwqb1P5GYZO6o1DYpO4oXrMZ7QDkrmzwxW02+OI2G3xxm41kYfM5bhqr+zluGvf6OW4aQ/o5bhqP+TluGtv417ijnVGtjZvG3H2Om8avfY6bxoJ9jiu5xs3lqvKcE/7XuKMdU3xs2zXu/mTcwTYibdzBblUfH/nz8mWa7t/FOQa7VWnjDnar0sYdLABq4w4WALVxBwuAr8eVabR9Vxl3tH1XGXewAKiNO1YA3M+V7Ot9VMkz6lhu6uWoYzmpl6OO5aJejjqWg3o56lju6dWogx0k/3LUsVzTy1HHckwvR83jlgY7aPzlqHksxGDHgL8cNY+FGOyQ7uWx8KUs223cwc7dVscdy0qo445lJ9Rxx7IU6riSa9yxXJQ67mgb0Vqvcbd7eTrYQbfquIPdqpb5GndZ7q5qsGNF1XEHu1Vp444V+tRxxwp+6rhjhT913MH2XWXcwQ7SVMcdLABq4w4WALVxR3NV9fGy++nJuJJr3NFclTLuaK5KGXc0V6WMO5ir+njIdY0r97w72JmN2riDHcOojjuYq9LGHcxVaeMO5qq0cSXXuIO5Km3cwVyVNu5grkobN5erWnO5qsEOVFXHzeWqBjv2VB03l6sa7HBSddxcrmqwI0TVcXO5qsEO+lTHzeWqBjuOUx03l6sa7NBMddwOrkp2OcddZVPGLVM9ry6lVHXceX6MO6/ll+s/J5DwE6zhJ9jCT7CHn6CGn+CIPkGP8xmNJ5jDT1DCTxB+T+5x1qHxBO735Ov35T/+e5+16+t+2sC5HvffrqjuN/C+47rf7fuO694a9B3XvY/oOu7h3nT0Hde9Q+k7rns703dc996n77iSa9xcrurI5aqOXK7qyOWqjlSuap1Suap1SuWq1imVq1qnVK5qnSTXuKlc1TqlclXrlMpVrVMqV7VOuVzVnMtVzblc1ZzLVc25XNUsucbN5armXK5qzuWqylj7bpm3c+Ef/yn3ccfad9Vxx9p31XHH2nfVccfad9Vxx9p31XHH2nfVccfad9Vxx2oz1HHHajO0cZdcrmrJ5aqWXK5qyeWqepywHGncXK5qyeWqllyuasnlqpZcrkpyuSrJ5aokl6uSXK6qxwnLkcbN5aokl6uSXK5KcrkqyeWqVu8bUfnyldxS5JfrPyfwvrfoE3i/ofyzs2VeX/85sfd7Sv+Jvd9Wuk+8ec9r/Sf2Htn6T+w9tfWf2P1+2X1i9/tr94m9x7f+E3tPcP0nTue5tnSea0vnufZ0nmtP57n2dJ7L/WGk/SeWdBOn81zuD0ftP/FYnquU6zznssyPIvasVt2fvNp53LHcVin79Bj3dkL26v480X847rqcx41//Ge9jzvWHqyOO9YGrI471u6rjjvW1quOO9i+q4072L6rjTvYvquM6/5Y087jjtVvqOPmclXujzXtPG4um+H+nM/O46ayGZv7kyD/4bi1XvH+mKav494vVl4ftbk/NtKSzWBbXFc2g+2HXdkIbJpsBjMWXdkM5kK6shnMsnRlM1iN0pXNYJ1LTzbujz98I5tazpXUck8M7k9KNCPj/hy6N5I5rseqx/2Evs39kXV2ZBL/a5qneXp89nJnk9gPq2wS+2GVTWI/rLJJ7IdVNon9sMbG/WlwlmwSuxuVTeKeWGWTOGOqbCQzm/2a8mPiO5vUvlhhk9oXK2xS+2KFTWpfrLBJ7Ytfs3F/np8lm9S+WGGT2hcrbFL7YoWNwKbJBl/cZoMvbrPBF7fZ4IvbbPDFTTYrvrjNBl/cZpPZF3+Z8usRmxebzL5YYyOwabLJ7Is1Npl9scYmsy/W2GT2xRqbzL5YYTPYecJ92WT2xRobfHGbDb64zUZg02SDL26zwRe32eCL22zwxU02g515+w/ZrA82635nk3oPV9ikvhc/Prv8+Ljf2aS+FytsUt+LFTapO4rXbGrqjkJhk7qjUNik9jcKm9T+RmEjsGmySd1RKGzwxW02+OI2G3xxmw2+uMlmtEOb22w+x01jdT/HTeNeP8dNY0g/x5Vc46axjZ/jpnGCn+OmMXef46bxa5/jprFgP8bd85xA/jluKle15zkn/HPcwTaiY9uucfcn4w62ESnjzoPdqo56/Lx8maZyH3ewW5U27mC3Km3cwQKgNq7kGnewAKiNO9q+q4w72r6rjDtYANTGHSsA7qdj3m/HX++DHZn+ctSx3NTLUcdyUi9HHctFvRxV8ow6lnt6OepYzunlqGO5ppejjuWYXo6axy0NdtD4y1HzWIjBjgF/OarkGXUsC7E8Fr6UZbuPO5aNUMcdy0qo445lJ9Rxx7IU2riDnWGtjjuWi1LHHW0jWus17nYvTwc76FYdd7Bb1TJf4y7L3VUNdqyoOu5gtypt3LFCnzruWMFPHVdyjTvYvquNO9i+q407WADUxh0sAGrjjuaq6uNl99N93MEOpVTHHc1VKeOO5qqUcUdzVcq4Mta4Mj/GlXveHezMRnXcwVyVNu5grkobdzBXpY07mKtSxt0Hc1XauIO5Km3cwVyVNu5grkobV3KNm8tVDXagqjpuLlc12LGn6ri5XNVgh5Oq4+ZyVYMdIaqOm8tVDXbQpzpuLlc12HGc6ri5XNVgh2Zq4775vLjPv2P9hr9j+4a/Y/+Gv6N+w99xvP3vqG8+7erz7+jgGbfpPAln20SUf6rzcqzXRy+Pc3O2+uTidb/+5a37umofPR3T+dFzmbSr5/1ax/Z1GZ9cClyeclng8pSLwOUplxUuT7lscHnKZYfLUy4VLk+5HHB5xqXH8YNDcsHvPueC333OBb/7nIvA5SkX/O5zLvjd51zwu8+54Hefc8HvPuVS8LvPueB3n3PB7z7ngt99zkXg8pQLfvc5F/zucy743edc8LvPueB3n3JZ8LvPueB3n3PB7z7ngt99zkXg8pQLfvc5F/zucy743edc8LvPueB3n3IR/O5zLvjd51zwu8+54HefcxG4POWC333OBb/7nAt+9zkX/O5zLvjdp1xW/O5zLvjd51zwu8+54HefcxG4POWC333OBb/7nAt+9zkX/O5zLvjdp1w2/O5zLvjd51zwu8+54HefcxG4POWC333OBb/7nAt+9zkX/O5zLvjdp1x2/O5zLvjd51zwu8+54HefcxG4POWC333OBb/7nAt+9zkX/O5zLvjdp1wqfvc5F/zucy743edc8LvPuQhcnnLB7z7ngt99zgW/+5wLfvc5F/zuUy4Hfvc5F/zucy743edc8LvPuQhcnnLB7z7ngt99zgW/+5wLfvc5F/zuMy7HhN99zgW/+5wLfvc5F/zucy4Cl6dc8LvPueB3n3PB7z7ngt99zgW/+5QL71drcMHvPueC333OBb/7nIvA5SkX/O5zLvjd51zwu8+54Hefc8HvPuXC+9UaXPC7z7ngd59zwe8+5yJwecoFv/ucC373ORf87nMu+N3nXPC7T7nwfrUGF/zucy743edc8LvPuQhcnnLB7z7ngt99zgW/+5wLfvc5F/zuUy68X63BBb/7nEtav1uk/Lx4mebXy5Bpnn9eK9P6mLDsTy7e15P3Xh+fW5ann1vPjy3KpXU/V1trfVwqTwWvpx4fFOTrxZ+Sp7XyeSUXJM8medoAllfytNkyr+RpY3NeydM2Ap4l/5QmbSnhQZr1pCxfP/WnNHnfw+lfmrTVjH9paIfcSkOLYyhNPZcgdblLI0jjVRpaEbfS0F64lYaWwU6adTovXad6l4Y2wK00tAFepcn7lmL/0tAGuJUG82woTTnBreWJNJhnt9JgA+yk2ZbjBLeWmzR5X97qXxpswN+QZl5O3DLv61dpPiFS33eASNHeAaIA8d9DxH93gIhT7gCRQrgDRKrbDhBJV38L4vwKYt6X+v4jiPPygLjdIZJYOkAksXSAmDaxLCInmL28XsY8LfXiMYk8iru5Pl3IXK7vUc5fu40TugD9+6GnTUSW0NMmKEvoaROXJfS0Cc0SetpEZwg972uuLaGnTYyW0NMmTEvoJFID6AL074dOIjWATiI1gE4iNYBOIjWATiL9bujHlPdF9JbQSaTvgH7M10KO4w6dRGoAnURqAF2A/v3QSaQG0EmkBtBJpAbQSaTvhf7LGZAndBLp90OfSaRvgF6m44I+73foJFID6CRSA+gkUgPoAvTvh04iNYBOIjWATiJ9M/RS7tBJpG8JR9MD+nKDXvDpb4C+LOeXwuZFpjt0fLoBdHy6AXQB+vdDx6cbQMenG0DHpxtAx6e/A7pcMy7rE5/Ok6Pvh77w5MgAOonUADqJ1AA6idQAugD926HnfcPxOp0jrkd9vYzl4xN+XrvM9ctDifITYtqw0xNi2vDSE2LaMNIRYt432/aEmDYs9ISY1vz3hJjWzPeEKED89xDTPv7pCZHE0gEiiaUDRBJLB4gkln8PMe/bN3tCJLF0gEhi6QCRxNIBogDx30MksXSASGLpAJHE0gEiiaUDRBLLv4eY90XBPSGSWDpAJLF0gEhi6QBRgPjvIZJYOkAksXSASGLpAJHE0gEiieXfQ8z7St+eEEksHSCSWDpAJLF0gChA/PcQSSwdIJJY/gbEMp8vq1jKMt8hklg6QCSxdIBIYvn3EPO+grYnRBJLB4gklg4QSSx/B+KyXRDX6Q5RgPjvIZJYOkAksXSASGLpAJHE0gEiieVfQ5zzvqL0H0Hc1gviftwhklg6QCSxdIBIYukAUYD47yGSWDpAJLF0gEhi+YcQ70/75ryvyOwJkcTy7yHmfYXlNp9nkW+yvV7GRyQ5J/ywM79AvF8sch1yLvLkBpr3/ZVmxNNmITPiaYOTGXGB+DcTTxvJzIinzW/vI36c7GSdnrjDtGHPjHjaZGhGPG2MtCJeyJzfTZzM+d3ER8qcZXm86VfKL1d/DjtS3FOHlUzDjmQASz1fUzN/1KLa1cf126zzUR9hpPGammm+bjQf/72WX67/RDmSszNGOZJls0U51IsIjVGOZLKMUQ7lnmxRDuXNbFEKKHuhHKk8N0Y5UitujJK00w0laacbStLO30W51gfKfdaur/s1Zj0eK19+VnhCNLLhTo6y4U7osuFOQrPhLnA34U72s+FOULThTqq04U4EteFOXjXhvpJXbbiTV224k1dtuJNXbbgL3E24k1dtuJNXbbiTV224k1dtuJNXTbhv5FUb7uRVG+7kVRvu5FUb7gJ3E+7kVRvu5FUb7uRVG+7kVRvu5FUT7jt51YY7edWGO3nVhjv+/S3cy0cT8PPyj/+UO3f8uw13/LsNd/y7DXf8uwn3in+34Y5/t+GOf7fhzvMmG+4CdxPu5FUb7uRVG+7kVRvu5FUb7uRVE+4HedWGO3nVhjt51YY7edWGu8DdhDt51YY7edWGO3nVhjt51YY7edWCe5nIqzbcyas23MmrNtzJqzbcBe4m3PGRf5N7+XKUfinyy/WfKLGGvVDO7H5/F+X+BWXd/tX1n+jZAM3Qsweaoae2NUNPc2uGnvLWDD2+2ww9Pt0KfaHFNUNPkWuGnjRrhp40a4ZeQG+FnjRrhp40a4aeNGuGnjRrhp40a4V+Ic2aoSfNmqEnzb4F/cedfP55+ceP9+P3Os7f1FiIsjbcBe7v4b5PD+7lzh07/x7u63J++sd/1jt3vLwNd4y8CXfBxdtwx8LbcMe/23DHv9twF7ibcOchlA13nkDZcCev2nAnr5pwX8lNNtzJTTbcyU023PGR7+Fe6/Xc45imr9zvFy9yjbmI3Mv6FdMZQCQcagCRsLMBROJZjX+RNgJKAJFIMwFEIvoEEInnSwFEEkTyLxIW3F6kWs5113IvhXhNvXuJeNO0A4mO63ebj/vLwAsvpfYvETc6e4nmaZ4en73cROLlvxFEomkIIBJNQwCRaBoCiCSI5F8kMlIAkUhJAUTidxsCiESxGkAkGgcPIu0X7g/0N5F4fXMEkWgcAohE4xBAJBqHACIJIvkXicYhgEg0DgFEonEIIBKNQwCRaBzci7TwAu4IItE4BBCJxiGASDQOAUQSRPIvEo1DAJFoHAKIROPgQKQvuL++u/4SicYhgEg0Dv5FmmkcAohE4xBAJBqHACLROAQQSRDJv0g0DgFEonEIIBKNQwCRaBwCiETj4F+kQuMQQCQahwAi0TgEEInGIYBIWHAPIq0Pkdb9LhIW3L9IC8bBg0iPzy4/Pu53kTAOAUTCOAQQSRDJv0g8qgggEo8qAohETgogEjkpgEg8qvAvkvCoIoBINA4BRKJxCCASjUMAkQSR/ItE4/DdIn1yp0Sw4U4vYMOdqG/DnfRuwn0lkNtwJ2PbcCc223AnCdtwF7ibcCev2nAnr9pwJ6+acN/wke/hfmzbxX1/wh0facOdffVN3Ovx8/Jlmu6HuG3sqzbc2VdtuNMD23CnBzbhvtMD23DHv9twx7/bcKcHtuEucH8H9/1sZ/b1zpys+v3Myanfz5yM+v3Myaffz5xs+u3MK7n0+5mTSb+fOXn0+5mTRb+fucD825mTib6fOZno+5mTib6fOZno25kfZKK3MF8eBJeybHfu5CIb7mQjG+7kIxvuAncT7jyvs+FOPrXgLhM+8k3c13px38qdOz7Shjv76nu4L/PFfVnWO3f2VRvu7Ks23Ol+bbjT/9pwpwM24T7j3224499tuNMD23CnB7bhLnB/D/d6rnz5CKd37uRVG+7kVRvu5FUb7uRVG+7k1fdwl/nBXe79O++pN+JOXrXhTl614U5eteEucDfhTl614U5eteFOXrXhTl614U5eNeG+kFdtuJNXbbiTV224k1dtuAvcTbiTV224k1dtuJNXbbiTV224k1dNuAt51YY7edWGO3nVhjt51YY7/v093JXvDQv+/U3c63RxP44bd95NbsQdP2PDHT9jwx0/Y8Nd4G7Cnf7dhjv+3YY7/t2GO/27DXf6dxPuG3n1Pdw/aJ/cl0Xu3MmrNtzJqzbcyas23AXuJtzJqzbcyas23MmrNtzJqzbcyatv4r48zhdb5xv3nbxqw528asOdvGrDnbxqw13gbsKdvPom7q/PS93Jqzbcyas23MmrNtzJqybcK3nVhjt51YY7edWGO3nVhrvA3YQ7edWGO3nVhjt51YY7edWGO3nVhPtBXrXhTl614U5eteFOXrXhLnA34U5eteFOXrXhTm6y4U5usuC+TuQmG+7kJhvu5CYb7vjIt3Avx3ZCKcc+3bnjI22489zDhjv+3YY7/t2E+4x/t+GOf7fhjn+34c5zDxvuAncT7uTVt3Bfpulc+fLxR+/cyas23MmrNtzJqzbcyasm3At51YY7efVNPrJe5y1NU7lzJ6/acCev2nAXuJtwJ6/acCev2nAnr9pwJ6/acCevmnBfyKs23MmrNtzJqzbcyas23AXuJtzJqzbcyas23MmrNtzJqzbcyasm3IW8asOdvGrDnbxqw528asNd4G7Cnbxqw528asOdvGrCfcW/v4d7rfPPy8sx/fJ9j2cLXy/cZb3/MuWK2Q8gEskggEjEiAAiCSL5F4mAEkAk0kwAkYg+AUTiuZ4HkR4LL8cTkXgI6F+kjcYhgEg0DgFEonEIIBKNQwCRBJEciPT47PLj434XicYhgEg0DgFEonEIIBKNQwCRaBz8i7TTOAQQicYhgEg0DgFEonEIIJIgkn+RaBwCiETjEEAkGocAItE4BBCJxsG/SJXGIYBINA4BRKJxCCASjUMAkQSR/ItETrIX6TjOa4/j/mbpSkpyLxEZybtEBwnJvUTkI/cSkY7cS0Q2ci+RIJF3iXgS614insO6l4h2wb1EtAvuJaJdcC7RNtEuuJeIdsFeonmap8dnL3eR6BcCiETDEEAkQST/ItEyBBCJniGASDQNAUSiawggEm2Df5Fm+oYAItE4eBCpXEuZZLqLROMQQCQahwAiCSL5F4nGIYBINA4BRKJxcGbBn4lE4+BMpGc5icbBv0iFxiGASDQOAUSicQggEo1DAJEEkfyLROMQQCQahwAi0TgEEInGIYBINA7+RVpoHAKIROMQQCQahwAi0TgEEEkQyb9INA4BRKJxCCASjUMAkWgcAohE4+BfJKFxCCASjUMAkWgcAohE4xBAJEEk/yKRk+xFquVcdy31LhEpyYFEcgKs23aXiIzkXaKVhOReIlyde4kEibxLxDMk9xLxBMm9ROQi9xKRi9xLRC7yLtFGLnIvEc+N3EvEUyP3EtEuOJConlPW4950b4JE3iWiXXAvEe2Ce4loF9xLRLvgXiLaBe8S7bQL7iWiXXAvEe2Ce4loF9xLJEjkXSLaBfcS0S64l4h2wb1EtAvuJaJd8C5RpV1wLxHtgnuJaBfcS0S74F4iQSLvEtEuuJeI6OpeIqKre4mIrt4lOoiu7iUiurqXSJDob0okx0Oitf5y/SdKzHE3lDwi64aSPNANJb69G0r8dSeU+4QP7oYSv9oNJY9EuqHk0UU3lALKXihJO91Qkna6oSTtdENJ2vm7KJf1gVKqdv2Xrq/8uOLXRm6fiEYm3GdylA13QpcNdxKaDXfinA13gbsJd4KiDXdSpQ13IqgNd/KqDXfyqgn3Ql614U5eteFOXrXhTl614S5wN+FOXrXhTl614U5eteFOXrXhTl414b6QV9/DXab92ZgXd/KqDXfy6nu4L/VBcHlyn8G/v4f7tp5fOvz4z3Lnjn+34Y5/t+GOf7fhjn9/E/fjhDJ/PNS7cRf8uw13/LsNd/y7DXeeN72J+6Of2cs9rwr+/T3c635dXo/1zh0/8xbuZZ6nn5eXuSw37it+xoY7fsaGO37Ghjt+xoa7wN2EO/27DXf8uw13+ncb7vTvNtzJqybcN/KqDXfyqg138uqbuG/LxX2TO3fyqg13gbsJd/KqDXfyqg138qoNd/KqDXfyqgn3nbxqw528asOdvGrDnbxqwx3//hbu2u/p7fh3G+74dxvu+Pf3cK/l+j3sut7794p/t+GOf7fhjn+34Y5/t+EucDfhzvMmG+7kVRvu5FUb7uRVG+7kVRPuB3nVhjt59U3cX39v+CCv2nAnr9pwF7ibcCev2nAnr9pwJ6/acCev2nAnr1pwrxN51YY7edWGO3nVhjt51Ya7wN2EO3nVhjv+/T3c1+v3sOe1/nIe9v3iRa4xF5FyFwmz71+kmWQQQCRiRACRyBwBRCKgBBBJEMm/SESfACLxXC+ASDwE9C9SwYLbi1TLue5a6l0iDLh7iejt7CU6jvOdd8eTapVXVruXiLf9OpBonq4jZX/8PXeRaBoCiCSI5F8kmoYAItE0BBCJpiGASGSkACKRkvyLxFvEI4hEsRpAJBoHDyLt18Uf6O8i0TgEEEkQyb9INA4BRKJxCCASjUMAkWgcAohE4+BfpJXGIYBINA4BRKJxCCASjUMAkQSR/ItE4xBAJBqHACLROAQQicYhgEg0Dv5F2mgcHIj0BXcpcheJxiGASDQOAUSicQggkiCSf5FoHAKIROMQQCQahwAi0TgEEInGwb9IO41DAJFoHAKIROMQQCQahwAiCSL5F4nGIYBINA7+RapYcA8irQ+R1v0uEhY8gEiCSA5E2ssl0o+P+10kjEMAkTAOAUTiUUUAkXhUEUAkHlX4F+kgJwUQiZwUQCQeVQQQiUcVAUQSRPpmkT65UyK8iftRz8u3+cnPO72ADXeivg130rsNdwK5BfdjImPbcCc223AnCdtwJ9zacBe4m3Anr9pwJ6/acCev2nAnr76H+7bOF/e13LmTV024z+RVG+7kVRvu5FUb7uRVG+4CdxPu5FUb7uRVG+7kVRvu5FUT7oXc9BbuZb5+b+njP+XOndxkw53cZMOd3GTDXeBuwp3cZMOd3GTDndxkw53cZMOd53wm3Bfyqg138qoNd/KqDXfyqg13gbsJd/KqDXfyqg138qoNd/JqB+6fKImgvVAKqbIbSoJiN5Rkv24osbdv2e57ntp7CF44gEgY5wAi4bIDiIR/9y/SSjIIIBKZI4BIpJkAIvHYy4NIj4WX44lIgkj+RaJxCCASjUMAkWgcAohE4xBAJBoHDyK9PEn+2GgcAohE4xBAJBqHACLROAQQSRDJv0g0DgFEonEIIBKNQwCRaBwCiETj4F+kncYhgEg0DgFEonEIIBKNQwCRBJH8i0TjEEAkGocAItE4BBCJxiGASDQO/kWq5CR7kY7jPBn8ONa7RKQk9xIJEnmXiITkXiLykXuJSEfuJSIbuZeIZORdooMnse4l4jmse4loF9xLRLvgXiJBIu8S0S64l4h2wV6ieZqnx2cvd5HoFwKIRMMQQCQ6Bu8izdPH/6BSAJVoGiKoRNkQQSX6hggqCSoFUInWIYJKFA8eVCrXUiaZnqhE8xBBJaqHCCrRPQRQaaZ7iKAS3UMElegePKj0xYk/VYnuwZlKz/LSLKgUQCW6hwgq0T1EUInuIYJKdA8RVKJ7CKBSoXuIoBLdQwSV6B4iqET3EEElQaUAKtE9RFCJ7iGCSnQPEVSie4igEt1DAJUWuocIKtE9RFCJ7iGCSnQPEVQSVAqgEt1DBJXoHiKoRPcQQSW6hwgq0T0EUEnIS/Yq1XKuu5b6RCPSkgON5ARYt+2JRoJG7jUiKfnXCG/nXyOcnXuNVp4p+deIJ0r+NSIf+deIfORfI0Ej9xqRj/xrxHMk/xrxFMm/RvQMDjSq50fX40nvvdIzuNdoo2fwrxE9g3+N6Bn8a0TP4F8jQSP3GtEz+NeInsG/RvQM/jWiZ/CvET2De412egb/GtEz+NeInsG/RvQM/jUSNHKvET2Df43oGfxrRM/gXyN6Bv8a0TO416jSM/jXiAzrXyMyrH+NBI3ca0SG9a8RGda9Rv9/9v42y3EcaboA9/KugASdX4ubvU/kPBIVWQHKq6ahMHfg/stzms2kX6sUzAwSeAbfm9jmp0bHsni33ubn1fP27bWSf65+TBvcITWeNrjXaDxt8FW78bTBu6f/Mm2Zz+enZSm79yBluj6JSynuZ+U0z+X6bJ3X8tf1D5bBO6JULIN3OYlYftGEZTOWHfkcOcuOXJScZUceTc7SYNmMZfB+JRXL4D1IKpbknnYsyT3tWJJ7/i3L9Xix3Gfv+mO/xjzO9UeBOc+EJBF4EpUIPPFLBJ6sJgJvgNeAJwWKwBMZReDJlyLwhFEReJKrBnwhuYrAk1xF4EmuIvAkVxF4A7wGPMlVBJ7kKgJPchWBJ7mKwJNcNeAXkqsIPMlVBJ7kKgJPchWBN8BrwJNcReBJriLwJFcReJKrCDzJVQPeSK4i8CRXEXiSqwg8Pv4j4Mt8nX7z9UergMfHi8Dj40Xg8fEi8Ph4DfgVHy8Cj48XgcfHi8CzAyUCb4DXgCe5isCTXEXgSa4i8CRXEXiSqwb8RnIVgSe5isCTXEXgSa4i8AZ4DXiSqwg8yVUEnuQqAk9yFYEnuWrA7yRXEXiSqwg8yVUEnuQqAm+A14DHTv5L8OXbWfyl2F/XP1jiEJuxjP5O8UAs928sj+1/uv7BnlVQx56FUMeeFlfHniJXx54uV8ce/61jj1+XsT8pdXXs6XV17Mm1OvbkWh17g72MPblWx55cq2NPrtWxJ9fq2JNrVezLRK7VsSfX6tiTaz/CvpTz+eRlmV9f93h+gaNMhFoReAP8Z8Dv0wt8qYDH1n8G/Lpcz7IuRwU8nl4EHkOvAT/j5kXgsfIi8Ph4EXh8vAi8AV4Dnm0pEXj2pETgSa4i8CRXDfhCgBKBJ0CJwBOgROCxk58BfxzXRsg5Td/B/7x4sfnJZDGrlPcF75lBJYxqBpVwtRlUYvMmgUoLQSWDSqSaDCoRgTKoxIZTBpUMlRKohBPXq3SU55McpdIP8e77+Brx7uoAGp3XF5/PyvvFC6+5TqARn3V6jeZpnl73Xn6qxMuEU6hE55BBJTqHDCrROWRQyVApgUpkpQwqkZYyqMT3HTKoRMuaQSW6hwgq7RfuL/Q/VeJ10ClUonvIoBLdQwaV6B4yqGSolEAluocMKtE9ZFCJ7iGDSnQPGVSie0igEi/0TqES3UMGlegeMqhE95BBJUOlBCrRPWRQie4hg0p0DwFU+oa7FKuoRPeQQSW6hwQqHXQPGVSie8igEt1DBpXoHjKoZKiUQCW6hwwq0T1kUInuIYNKdA8ZVKJ7SKDSSfeQQSW6hwwq0T1kUInuIYNKOPEIKq0vlda9ohJOPL5Ky4R7iKDS697lz+1+qIR7yKAS7iGDSoZKCVRi5yKDSuxcZFCJvJRBJfJSBpXYuUig0szORQaV6B4yqET3kEEluocMKhkqJVCJ7uG3VXqAp04QgachEIEn9IvAk+M14AvRXASetC0CT4AWgScTi8Ab4DXgSa4i8CRXEXiSqwb8gp38DPhz2y7wew08dlIEnsX1Q+CP83H5Mk2lAp7FVQSexVUEnlpYBJ5aWAPeqIVF4PHxIvD4eBF4amEReAP8J8Dvz+fe1wp0UqsAOolVAJ20KoBOUhVAJ6X+PvSVhCqATjoVQCeZCqCTSgXQDei/D51wJIBOOBJAJxwJoBOOfh/6Rjj6CPTlRXApy1YBT0ASgSckicATlETgDfAa8GzhicCTVDXgd+zkh8CvxwV+q3xFY8dOisCzuH4G/DJf4Jelklx3FlcReBZXEXiqYBF46mAReCphDfgDHy8Cj48XgacWFoGnFhaBN8B/BvzxHHOxqQae5CoCT3IVgSe5isCTXEXgSa6fAW/zC7xV+njefa8CT3IVgSe5isCTXEXgDfAa8CRXEXiSqwg8yVUEnuQqAk9ylYC3ieQqAk9yFYEnuYrAk1xF4A3wGvAkVxF4kqsIPMlVBJ7kKgJPctWAn0muIvAkVxF4kqsIPMlVBB4f/xnwzg+MbcbHfwj8MV3gz/MneF54rgKPqxGBx9WIwONqROAN8Brw9PEi8Ph4EXh8vAg8fbwIPH28BvxCcv0M+C/cT/DLYhXwJFcReJKrCDzJVQTeAK8BT3IVgSe5isCTXEXgSa4i8CTXD4FfXmeSrfNP8EZyFYEnuYrAk1xF4EmuIvAGeA14kuuHwL8/adWM5CoCT3IVgSe5isCTXDXgV5KrCDzJVQSe5CoCT3IVgTfAa8CTXEXgSa4i8CRXEXiSqwg8yVUDfiO5isCTXEXgSa4i8CRXEXgDvAY8yVUEnuQqAk+AEoEnQGnA7wQoEXgClAg8AUoEHjv5EfDl3J5QyrlPFfDYSRF4NkJE4PHxIvD4eA34Ax8vAo+PF4HHx4vAsxEiAm+A14AnuX6mMpim6+D+r/9rBTzJVQSe5CoCT3IVgSe5asCfJFcReJLrh+zkcZ3QNE2Vt+KcJFcReJKrCLwBXgOe5CoCT3IVgSe5isCTXEXgSa4S8OtEchWBJ7mKwJNcReBJriLwBngNeJKrCDzJVQSe5CoCT3IVgSe5asDPJFcReJKrCDzJVQSe5CoCb4DXgCe5isCTXEXgSa4a8AUf/xnwx/F88nJOf/0ipHLzsl64y7pXVML0Z1CJhJBBJeJEBpUMlRKoRFDJoBKpJoNKRKAMKrHTF0Gl61HmctZUYlswgUoL3UMGlegeMqhE95BBJbqHDCoZKgVQ6XXv8ud2P1Sie8igEt1DBpXoHjKoRPeQQSW6hwQqGd1DBpXoHjKoRPeQQSW6hwwqGSolUInuIYNKdA8ZVKJ7yKAS3UMGlegeEqi00j1kUInuIYNKdA8ZVKJ7yKCSoVIClchLepXO83ntea4VjUhL8TUiK4XXaCMpxdeInBRfI1JSfI3ISPE1MjQKrxF7s/E1Ymc2vkb0DPE1omeIrxE9Q3iNdnqG+BrRMwTYnZjm6XXvpaISTUMGlegaMqhkqJRAJfqGDCrROGRQic4hg0q0DhlUondIoNJB85BBJbqHCCqV/bq3TRWV6B4yqET3kEElQ6UEKtE9ZFCJ7iGDSnQPwZx4VSW6hwx5ie4hgUon3UMGlegeMqhE95BBJbqHDCoZKiVQie4hg0p0DxlUonvIoBLdQwaV6B7iq7RNdA8ZVKJ7yKAS3UMGlegeMqhkqJRAJbqHDCrRPWRQie4hg0p0DxlUontIoNJM95BBJbqHDCrRPWRQie4hg0qGSglUIi/pVTrK80mObw/y0oi0FEAjewI8tq2iEVkpvEaFpBRfI7xdfI0MjcJrxJ5SfI3YUYqvEfkovkbko/gakY/Ca7SQj+JrxD5SfI3YRYqvET1DAI2OJ5LjrPTei6FReI3oGeJrRM8QXyN6hvga0TPE14ieIbxGRs8QXyN6hvga0TPE14ieIb5GhkbhNaJniK8RPUN8jegZ4mtEzxBfI3qG8Bqt9AzxNaJniK8RPUN8jegZ4mtkaBReI3qG+BqRYeNrRIaNrxEZNrxGGxk2vkZk2PgaGRr9S43sfGm0/n39gyUeuR1L9szasSQXtGOJf2/HEp/djOWOH27HEt/ajiV7JO1YspfRjqXBshlLck87luSedizJPe1Yknv+LctlfbE09/pv1V/5c8U/C7qdkKQBf5CoROCJXyLwZDUReIKdCLwBXgOeyCgCT74UgSeMisCTXEXgSa4a8CfJVQSe5CoCT3IVgSe5isAb4DXgSa4i8CRXEXiSqwg8yVUEnuQqAb9PJNfPgLdpr435Ak9yFYEnuX4G/HK8CC61jxp8/GfAb+vzyb/+WCrg8fEi8Ph4EXh8vAg8Pv5D4M8nlHmfz5/gZ3y8CDw+XgQeHy8Czw7Uh8C/upq9VJLrjI//DPhjvy4/zrUCHlfzEfBlnqfn3eey/ARfcDUi8LgaEXhcjQg8rkYE3gCvAU8fLwKPjxeBp48XgaePF4EnuWrALyRXEXiSqwg8yfVD4LflAr9ZBTzJVQTeAK8BT3IVgSe5isCTXEXgSa4i8CRXDXgjuYrAk1xF4EmuIvAkVxF4fPxHwLtf4TN8vAg8Pl4EHh//GfBHub6mfayVPn7Fx4vA4+NF4PHxIvD4eBF4A7wGPDtQIvAkVxF4kqsIPMlVBJ7kqgG/kVxF4EmuHwLv/MB4I7mKwJNcReAN8BrwJFcReJKrCDzJVQSe5CoCT3LVgN9JriLwJFcReJKrCDzJVQTeAK8BT3IVgcfHfwb8en1Ne16Pv07T/nnxYvPz3otZ5ejtHdOfQKWDhJBBJeJEBpXIHhlUIqhkUMlQKYFKRKAMKrHTl0EltgUTqHTixPUqHeX5JMe3B3lphA+PrxEdnl6j83xOedZ6Vl6CHV6jg7cHB9Bonq6zaP/8PRWV6BwyqGSolEAlOocMKtE5ZFCJziGDSmSlDCqRlhKoxHvJU6hEy5pBJbqHCCrt18Vf6Csq0T1kUMlQKYFKdA8ZVKJ7yKAS3UMGlegeMqhE95BApUL3kEEluocMKtE9ZFCJ7iGDSoZKCVSie8igEt1DBpXoHjKoRPeQQSW6hwQqLXQPAVT6hrsUq6hE95BBJbqHDCrRPWRQyVApgUp0DxlUonvIoBLdQwaV6B4yqET3kEAlo3vIoBLdQwaV6B4yqET3kEElQ6UEKtE9ZFCJ7iGBSitOPIJK60ulda+ohBPPoJKhUgCV9nKp9Od2P1TCPWRQCfeQQSV2LjKoxM5FBpXYuUig0kZeyqASeSmDSuxcZFCJnYsMKhkq/bJKD/DUCR8Cfx7Py7e59l88DYEIPKFfBJ4cLwJPNNeA30nbIvAEaBF4MrEIPDFXBN4ArwFPchWBJ7mKwJNcReBJrp8Bv63zBX6ttJM7yVUD/iC5isCTXEXgSa4i8CRXEXgDvAY8yVUEnuQqAk9yFYEnuWrAnwSoj4Av8/WFpq8/Vn4RehKgROAJUCLwBCgReAO8BjwBSgSeACUCT4ASgSdAicCz9ScBf04kVxF4kqsIPMlVBJ7kKgJvgNeAJ7mKwJNcReBJriLwJNcG4B8sCaPNWM7ky3YsiYztWJIC27HE5n5k0W964O8544kzqISBzqASbjuDSvj4BCoVEkIGlcgeGVQi1WRQiY2wCCpdjzKXs6aSoVIClegeMqhE95BBJbqHDCrRPWRQie4hgkrvD6I/F7qHDCrRPWRQie4hg0p0DxlUMlRKoBLdQwaV6B4yqET3kEEluocMKtE9JFDJ6B4yqET3kEEluocMKtE9ZFDJUCmBSnQPGVSie8igEt1DBpXoHjKoRPeQQKWVvKRX6TyfU57nWtGItBRfI0Oj8BqRlOJrRE6KrxEpKb5GZKT4GpGQwmu0sTcbXyN2ZuNrRM8QXyN6hvgaGRqF14ieIb5G9AwBdiemeXrde6moRNOQQSW6hgwq0TYkUGmnb8igEo1DBpXoHDKoROuQQSVDpQQq0TxkUInuIYJKZb/ubVNFJbqHDCrRPWRQie4hgUoH3UMGlegeMqhE9xDMiVdVontIkJcOQ6UEKtE9ZFCJ7iGDSnQPGVSie8igEt1DApVOuocMKtE9ZFCJ7iGDSnQPGVQyVEqgEt1DBpXoHjKoRPeQQSW6hwwq0T2EV2meJrqHDCrRPWRQie4hg0p0DxlUMlRKoBLdQwaV6B4yqET3kEEluocMKtE9JFBpJi/pVTrK80mObw/y0oi0FEAjewI8tq2ikaFReI1ISvE1wtvF1whnF16jwp5SfI3YUYqvEfkovkbko/gaGRqF14h8FF8j9pHia8QuUnyN6BkCaHQ8b32cld670DOE12ihZ4ivET1DfI3oGeJrRM8QXyNDo/Aa0TPE14ieIb5G9AzxNaJniK8RPUN4jYyeIb5G9AzxNaJniK8RPUN8jQyNwmtEzxBfI3qG+BrRM8TXiJ4hvkb0DOE1WukZ4mtEho2vERk2vkaGRuE1IsPG14gMG1+jjrz3vK1P6vO2z39d/X/Tbh252H8xbUdeYz6O66lPO72rz/l6Dex5nO6/v3ku17+/eS1/Xf9gabBsxrKjtVvOsqM1Vs6yoz5XzrKj3lXOsiePJma59+QA1Sw7+l6TnGVH3a2cJbmnHUuDZTOW5J5/y3I9Xiy/dxv164/9GvM4158l105IEoEnUYnAE79E4MlqGvAHwU4EnhQoAk9kFIEnX4rAG+A14EmuIvAkVxF4kqsIPMlVBJ7kqgF/klxF4EmuIvAkVxF4kqsIvAFeA57kKgJPchWBJ7mKwJNcReBJrhLw80RyFYEnuYrAk1xF4EmuIvAGeA14kqsIPMlVBJ7kKgJPctWAn/HxHwFf5uuElK8/WgU8Pl4EHh8vAm+A14DHx4vA4+NF4PHxIvD4eBF4dqA04As7UCLwJFcReJKrCDzJVQTeAK8BT3IVgSe5isCTXEXgSa4i8CRXDfiF5CoCT3IVgSe5isCTXEXgDfAa8CRXEXiSqwg8yVUEnuQqAk9y1YA3kqsIvAH+34Ev387iL8X+uv7BEofYjiVL4L9luX9jeWz/0/UP9qyCMvYrC6GOPS2ujj1Fro49Xa6OvcFexh6/rmNPqatjT6+rY0+u1bEn18rYb+RaHXtyrY49uVbHnlyrY2+wl7En1+rYk2t17Mm1Ovbk2o+wL+V8PnlZ5tfXPa4vcGyEWg34nUT7IfD79AJfKuCx9Z8Bvy7Pu3/98aiAN8BrwGPoReBx8yLwWHkReHy8CDw+XgP+wMeLwLMtJQLPnpQIPMlVBN4ArwFPgBKBJ0CJwBOgNOBP7ORnwB/HtRFyTtN38D8vXmx+MlnMKuX9iffMoBJGNYNKhkoJVGLzJoNKBJUMKpFqMqhEBMqgEhtO8VUqE7tTGVQyVJKrdBR7XHuUo6IRPjy8Rry7OoBG5/XF57PyfvHCa64TaMRnnV6jeZqn172Xikp0DhlUonPIoBKdQwaV6BwSqMQLkFOoRFbKoBJpKYNKfN8hg0qGSglUonuIoNJ+PfgX+opKdA8ZVKJ7yKAS3UMGlegeEqjEK6xTqET3kEEluocMKtE9ZFDJUCmBSnQPGVSie8igEt1DBpXoHjKoRPeQQCVeQp5CJbqHDCrRPWRQie4hgErfcJdiFZUMlRKoRPeQQSW6hwwq0T1kUInuIYNKdA8JVFrpHjKoRPeQQSW6hwwq0T1kUMlQKYFKdA8ZVKJ7yKAS3UMGlegeMqhE95BApQ0nHkGl9aXSuldUMlRKoBLuIYJKr3uXP7f7oRLuIYNKuIcEKu3sXGRQiZ2LDCqxc5FBJfJSBpUMlRKoxM5FBpXYucigEt1DBpXoHjKoRPeQQKWD7iGDSnQPv63SAzx1ggg8DYEIvAFeA54cLwJPNBeBJ22LwBOgReDJxBrwJzFXBJ7kKgJPchWBJ7mKwGMnPwP+3LYL/F4Dj52UgF8mFtcPgT/Ox+XLNJUKeBZXEXgWVxF4A7wGPLWwCDy1sAg8Pl4EHh8vAk8trAE/Uwt/BPz+fO59rUAntQqgk1gF0EmrAugG9N+HTkoVQCehCqCTTgXQSaYC6KTS34deSKT/7/ehE44E0AlHAugG9N+HTjgSQCccfQT68iL49RG+VcATkETgCUki8AQlDfiFsCQCzxaeCDxJVQQeO/kh8Otxgd8qX9FYsJMa8Mbi+hnwX7sZT/DLUkmuxuIqAs/iKgJPFSwCb4DXgKcSFoHHx4vA4+NF4KmFReCphTXgV5Lrh8AfzzG/2oEaeJKrCDzJVQSe5CoCb4DXgCe5fga8zS/wVunjefe9CjzJVQSe5CoCT3LVgN9IriLwJFcReJKrCDzJVQTeAK8BT3IVgSe5isCTXEXgSa4i8CRXDfid5CoCT3IVgSe5isCTXEXgDfAa8CRXEXiSqwg8yVUEnuQqAk9y1YA/ekqu5/Z86jJ9u3X96jId9ry6lMMFP88v8PNa/rr+wbKnMKpm2VO+VLPsKTKqWRosm7HsKdipWfaU1dQse4pfapY9JSo1y55CkpjlSe5px5Lc044lueffsrxO8Pr68z571x/7NeZxVn7ZdRKSROAN8BrwxC8ReLKaCDzBTgSeFCgCT2SUgLeJfCkCTxgVgSe5isCTXEXgDfAa8CRXEXiSqwg8yVUEnuQqAk9y1YCfSa4i8CRXEXiSqwg8yVUE3gCvAU9yFYEnuYrAk1xF4EmuIvAkVw34QnIVgSe5isCTXEXgSa4i8AZ4DXh8/EfAl/n1LPNmFfD4eBF4fLwG/IKPF4HHx4vA4+NF4PHxIvAGeA14dqBE4NmBEoEnuYrAk1xF4EmuGvBGchWBJ7mKwJNcReBJriLwBngNeJKrCDzJVQSe5CoCT3IVgSe5asCvJFcReJKrCDzJVQSe5CoCb4DXgCe5isCTXDXgN+zkvwRfvh0JX4r9df2DJQ6xHUuWwH/L8j+9Z/D99Q/2rII69iyEOva0uDr2FLk69nS5MvY7/lvHHr+uY0+pq2NPr6tjb7CXsSfX6tiTa3XsybU69uRaHXtyrYz9Qa7VsSfX6tiTa3XsybU69gb7T7Av5Xw+eVnm19c9ri9wHIRaEXgS7YfA79MLfKmAx9Z/Bvy67M+7r8vxE/yJpxeBx9CLwOPmReCx8iLwBngNeHy8CDw+XgSebSkRePakROBJrhLw60RyFYEnQInAE6BE4A3wGvDYyc+AP45rI+Scpu/gf1682PxkspiVikp4zwwqYVQTqDTjajOoxOZNBpUIKhlUItVkUMlQKYFKbDhlUIndqQQq8UL7ACod5fkkR6n0Q7z7PoFGdHh6jc7ri89n5f3iK6+5jq8R7wcOoNE8zdPr3ktFJTqHDCrROWRQyVApgUp0DhlUonPIoBJZKYNKpKUMKvF9hwQq8dLmFCrRPURQab9wf6GvqET3kEEluocMKhkqJVCJ7iGDSnQPGVSie8igEt1DBpXoHhKoxGu3U6hE95BBJbqHDCrRPWRQyVApgUp0DxlUonvIoBLdQwaV6B4yqET3EEClb7hLsZ8qbXQPGVSie8igEt1DBpXoHjKoZKiUQCW6hwwq0T1kUInuIYNKdA8ZVKJ7SKDSTveQQSW6hwwq0T1kUInuIYNKhkoJVKJ7yKASTjyCSutLpXX/qdKBE8+gEu4hgkqve5c/t/uhkqFSApVwDxlUYucig0rsXGRQiZ2LDCqRlxKodJKXMqjEzkUGldi5yKAS3UMGlQyVEqhE95BBJbqHDCrRPfy2Sg/w1Aki8DQEEvDbROgXgSfHi8ATzUXgSdsi8AZ4DXgysQg8MVcEnuQqAk9yFYEnuWrAz9jJz4A/t+0Cv9fAG+A14FlcPwT+OB+XL9NUKuBZXEXgWVw14Au1sAg8tbAIPLWwCDw+XgTeAK8BTy0sAk8t/BHw+/O597UCndQqgE5iFUAnrf4+9IWkKoBOShVAJ6EKoJNOBdAN6L8PnVQqgE4iFUAnHAmgE45+H7oRjgTQCUcC6ISjj0BfXgSXsmwV8AQkEXgDvAY8QUkEnrAkAs8Wngg8SVUDfsVOfgj8elzgt8pXNFbspAg8i+tnwC/zBX5ZKsl1ZXEVgWdxFYGnCtaA36iDReCphEXg8fEi8Ph4EXgDvAY8tbAIPMn1Q+CP55iLTTXwJFcReJKrCDzJVQN+J7mKwJNcPwPe5hd4q/TxvPteBZ7kKgJvgNeAJ7mKwJNcReBJriLwJFcReJKrBvxBchWBJ7mKwJNcReBJriLwBngNeJKrCDzJVQSe5CoCT3IVgSe5asCfJFcReJKrCDzJVQSe5CoCb4DXgCe5isDj4zU/MD7x8R8Cf0wX+PP8AX7nhecq8LgaEXgDvAY8rkYEnj5eBJ4+XgQeHy8Cj4/XgJ/p40Xg6eNF4EmuH/rVX7lelLgsVgFPchWBN8BrwJNcReBJriLwJFcReJKrCDzJVQO+kFxF4EmuHwK/vM4kW+cKeJKrCDzJVQTeAK8BT3IVgSe5isCTXD8E/v1Jq3shuYrAk1w14BeSqwg8yVUEnuQqAk9yFYE3wGvAk1xF4EmuIvAkVxF4kqsIPMlVA95IriLwJFcReJKrCDzJVQTeAK8BT3IVgSe5isCTXEXgSa4a8CsBSgSeACUCT4ASgSdAicAb4DXgsZMfAV/O7QmlnPtUAY+dFIFnI0QDfsPHi8Dj40Xg8fEi8Ph4EXgDvAY8GyEi8GyEiMCTXD9TGUzTdXD/1/+1Ap7kKgJPctWA30muIvAkVxF4kqsIPMn1Q3byuE5omqZSAW+A14AnuYrAk1xF4EmuIvAkVxF4kqsG/EFyFYEnuYrAk1xF4EmuIvAGeA14kqsIPMlVBJ7kKgJPchWBJ7lqwJ8kVxF4kqsIPMlVBJ7kKgJvgNeAJ7mKwJNcReBJriLwJFcReJKrBPwx4eM/A/44nk9ezumvX4RUbl7WC3dZ94pKmP4MKhkqJVCJOJFBJbJHBpUIKhlUItVkUIkIlEClmZ2+CCpdjzKXs6YS24IZVKJ7yKAS3UMGlQyVEqhE95BBJbqHCCq97l3+3O6HSnQPGVSie8igEt1DApUK3UMGlegeMqhE95BBJbqHDCoZKiVQie4hg0p0DxlUonvIoBLdQwaV6B4SqLTQPWRQie4hg0p0DxlUonvIoJKhUgKV6B4yqET3kEEl8pJepfN8XnueP19UfRhpKb5GZKX4GpGU4mtEToqvkaFReI3ISPE1IiHF14i92fgasTMbXyN6hvAarfQM8TWiZ4ivET1DfI3oGQLsTkzz9Lr3UlHJUCmBSnQNGVSibcigEn1DBpVoHDKoROeQQKWN1iGDSvQOGVSiecigEt1DBJXKft3bpopKhkoJVKJ7yKAS3UMGlegeMqhE95BBJbqHYE68ptJO95AgL+10DxlUonvIoBLdQwaVDJUSqET3kEEluocMKtE9ZFCJ7iGDSnQPCVQ66B4yqET3kEEluocMKtE9ZFDJUCmBSnQPGVSie8igEt1DBpXoHjKoRPeQQKWT7iGDSnQPGVSie8igEt1DBpUMlRKoRPeQQSW6hwwqkZf0Kh3l+STHtwd5avT1f0cjvUb2BHhsW0UjslJ8jUhK8TXC28XXCGcXXyP2lOJrxI5SfI3IR+E1mslH8TUiH8XXiHwUXyP2keJrZGgUXiN6hgAaHU8kx1npvWd6hvga0TPE14ieIb5G9AzhNSr0DPE1omeIrxE9Q3yN6Bnia2RoFF4jeob4GtEzxNeIniG+RvQM8TWiZwiv0ULPEF8jeob4GtEzxNeIniG+RoZG4TWiZ4ivET1DfI3oGeJrRIYNr5GRYeNrRIaNrxEZNr5GZNj4GuG9/61Gdr40Wv++/sESj9yOJXtm7ViSC5qxXPHv7Vjis9uxxA+3Y4lvbcfSYNmMJXsZ7ViSe9qxJPe0Y0nuaceS3NOM5Ubu+bcsl/XF0tzrv1V/5c8V/yzoNkKSCDyJSgSe+CUCb4DXgCfYicCTAkXgiYwi8ORLEXjCqAb8TnIVgSe5isCTXEXgSa4i8AZ4DXiSqwg8yVUEnuQqAk9yFYEnuWrAHyRXEXiSqwg8yfUz4G3aa2O+wJNcReAN8B8BvxwvgkvtowYf/xnw2/p88q8/lgp4fLwIPD5eA/7Ex4vA4+M/BP58Qpn3+ayAx8eLwOPjReAN8Brw7EB9CPyrq9lLJbme+PjPgD/26/LjXP8JvkwTruYj4Ms8T8+7z2WpgMfViMDjakTgDfAa8LgaEXi+VyMCTx8vAo+PF4Gnj9eAn+njReBJriLwJFcReJKrCLwB/jPgX88yb1YBT3IVgSe5isCTXEXgSa4i8CRXDfhCchWBJ7mKwJNcReBJriLwBngNeJKrCDw+/v8JvsL3BR4frwG/4ONF4PHxnwF/lOtr2sda6eMXfLwIPD5eBN4ArwGPjxeBZwdKBJ4dKBF4kqsIPMlVA95IriLwJFcReJKrCDzJ9UPgnR8YmwFeA57kKgJPchWBJ7mKwJNcReBJrhrwK8lVBJ7kKgJPchWBJ7mKwBvgNeBJriLwJFcReJKrBvyGj/8M+PV6lnk9/jpN++fFi83Pey9mpaISpj+DSiSEDCoRJzKoZKiUQCWCSgaVSDUZVCICZVCJnb4MKrEtmEClHSeuV+kozyc5vj3ISyNDo+ga8WbrABqd53PKs9az8hLsBBrxWafXaJ6us2j//D0VlegcMqhE55BBJTqHDCrROWRQic4hgUq8PTyFSqSlDCrxfYcMKtGyZlDJUCmASvt18Rf6ikp0DxlUonvIoBLdQwaV6B4yqET3EF+leaJ7yKAS3UMGlegeMqhE95BBJUOlBCrRPWRQie4hg0p0DxlUonvIoBLdQwKVZrqHDCrRPWRQie4hgErfcJdiFZXoHjKoZKiUQCW6hwwq0T1kUInuIYNKdA8ZVKJ7SKBSoXvIoBLdQwaV6B4yqET3kEElQ6UEKtE9ZFCJ7iGDSnQPGVSie0ig0oITj6DS+lJp3Ssq4cQzqIR7iKDSXi6V/tzuh0q4hwwq4R4yqMTORQKVjJ2LDCqxc5FBJfJSBpXISxlUMlRKoBI7FxlUonv4bZUe4KkTPgT+PJ6Xb3Ptv3gaAhF4Qr8G/EqOF4EnmovAk7ZF4AnQIvAGeA14Yq4IPMlVBJ7kKgJPchWBJ7lqwG8k18+A39b5Ar9W2smN5CoCT3IVgSe5isAb4DXgSa4i8CRXEXiSqwg8yVUEnuSqAb+TXEXgCVAfAf8nIT3vPm+VX4TuBCgReAO8BjwBSgSeACUCT4ASgSdAicAToDTgDwKUCDxbfyLwJFcReJKrCLwBXgOe5CoCT3IVgSe5isCTXEXgSa4a8CfJtQH4B0vCaDuW5Mt2LImM7VgaLJuxxOZ+5msnTQ/8PfHEGVTCQMdXqUy47Qwq4eMzqERCyKAS2SODSoZKCVRiIyyCStejzOWsqcSuWQaV6B4yqET3kEEluocEKs10DxlUonuIoNL7g+jLTPeQQSW6hwwqGSolUInuIYNKdA8ZVKJ7yKAS3UMGlegeEqhU6B4yqET3kEEluocMKtE9ZFDJUCmBSnQPGVSie8igEt1DBpXoHjKoRPeQQKWF7iGDSnQPGVQyVJKrdJ7PKc9zrWhEWoqvEVkpvkYkpfgakZPia0RKCq+RkZHia0RCiq8Re7PxNWJnNr5GhkbhNaJniK8RPcP/C68RPUN8jegZ9BrN0zy97r1UVKJpSKDSSteQQSXahgwq0TdkUInGIYNKhkoJVKJ1yKASvUMGlWgeMqhE9xBBpbJf97apohLdQwKVNrqHDCrRPWRQie4hg0p0DxlUMlSK5cSrKtE9JMhLG91DBpXoHjKoRPeQQSW6hwQq7XQPGVSie8igEt1DBpXoHjKoZKiUQCW6hwwq0T1kUInuIYNKdA8ZVKJ7SKDSQfeQQSW6hwwq0T1kUInuIYNKhkoJVKJ7yKAS3UMGlegeMqhE95BBJbqHBCqddA8ZVKJ7yKCSoZJcpaM8n+T49iAvjUhLATSyJ8Bj2yoakZXia0RSiq7RMuHt4muEs4uvEXtK8TViRym+RoZG4TUiH8XXiHwUXyPyUXyN2EeKrxG7SOE1mukZAmh0PG99nEdFI3qG+BrRM8TXiJ4hvkaGRuE1omeIrxE9Q3yN6Bnia0TPEF8jeobwGhV6hvga0TPE14ieIb5G9AzxNTI0Cq8RPUN8jegZ4mtEzxBfI3qG+BrRM4TXaKFniK8RPUN8jegZ4mtkaBReIzJsfI3IsPE1IsPG14gMG14j68l7H8f11KedrqLz9arQ8zh9jfby0ujYnOu/yurjcflXJ1oq4Hsy1KHAH9MF/jwr4HtyYKnA92SrUoHvySulAt+TAUoFvqdmPhP4tae6PRV4fLwIPD5eBL6nb9WlAm+A14AnuX4G/BfuJ/ivTbQKeJKrCDzJVQSe5CoCT3LVgN9IriLwJFcReJKrCDzJVQTeAP8Z8Mu12f3VRFbAk1xF4EmuIvAkVxF4kqsIPMlVA34nuX4I/PwCv6wV8CRXEXiSqwg8yVUE3gCvAU9yFYEnuYrAk1xF4EmuIvAkVw34g+QqAk9yFYEnuYrAk1xF4A3wGvAkVxF4kqsIPMlVBJ7kKgJPctWAP0muIvAkVxF4ApQIvAFeA54AJQJPgBKBJ0BJwNuEnfwI+HJuTyjl3KcKeOykCDwbISLw+HgReAO8Bjw+XgQeHy8Cj48XgWcjRASejRAN+Jnk+hHwyzQ9x1y+/q8V8CRXEXiSqwg8yVUE3gCvAU9yFYEnuX7ITh7XCU3TVCrgSa4i8CRXEXiSqwZ8IbmKwJNcReBJriLwJFcReAO8BjzJVQSe5CoCT3IVgSe5isCTXDXgF5KrCDzJVQSe5CoCT3IVgTfAa8CTXEXgSa4i8CRXEXiSqwg8yVUD3kiuIvAkVxF4kqsIPD7+M+CP4/nk5Zz++kVI5eZlvR68rJUvWhqmP4NKJIQMKhEnMqhE9kig0kpQyaASqSaDSkSgDCqx0xdBpcMulc6aSoZKCVSie8igEt1DBpXoHjKoRPeQQSW6hwgqve5d/tzunyptdA8ZVKJ7yKAS3UMGlegeMqhkqJRAJbqHDCrRPWRQie4hg0p0DxlUontIoNJO95BBJbqHDCrRPWRQie4hg0qGSglUonvIoBLdQwaV6B4yqET3kEEluocEKh3kJb1K5/m89jwrL6o+SEvxNTI0Cq8RSSm+RuSk+BqRkuJrREaKrxEJKbxGJ3uz8TViZza+RvQM8TWiZ4ivkaFReI3oGeJrRM+g12ie5ul176WiEk1DBpXoGjKoRNsQX6V1om/IoBKNQwaV6BwyqETrkEElQ6UEKtE8ZFCJ7iGCSuV6lMmmikp0DxlUonvIoBLdQwKVZrqHDCrRPWRQie4hmBOvqkT3EEylWl6aDZUSqET3kEEluocMKtE9ZFCJ7iGDSnQPCVQqdA8ZVKJ7yKAS3UMGlegeMqhkqJRAJbqHDCrRPWRQie4hg0p0DxlUontIoNJC95BBJbqHDCrRPWRQie4hg0qGSglUonvIoBLdQwaV6B4yqET3kEEluocEKhl5Sa/SUexx7VGOikakpQAa2RPgsW0VjQyNwmtEUoqvEd4uvkY4u/AarewpxdeIHaX4GpGP4mtEPoqvkaFReI3IR/E1Yh8pvkbsIsXXiJ4hgEbHE8lxVnrvlZ4hvEYbPUN8jegZ4mtEzxBfI3qG+BoZGoXXiJ4hvkb0DPE1omeIrxE9Q3yN6BnCa7TTM8TXiJ4hvkb0DPE1omeIr5GhUXiN6Bnia0TPEF8jeob4GtEzxNeIniG8Rgc9Q3yNyLDxNSLDxtfI0Ci8RmTY+BqRYeNrhPf+txrZ+dJoPf66/v9YnnjkdizZM2vHklzQjiX+vR1Lg2Uzlvjhdizxre1YskfSjiV7Ge1Ykntasdwmck87luSedizJPe1Yknv+LctlfbG0w7v+W/VX/lzxj4JumwzwGvAkKhF44pcIPFlNBJ5gJwJPCtSAn4mMIvDkSxF4wqgIPMlVBN4ArwFPchWBJ7mKwJNcReBJriLwJFcN+EJyFYEnuYrAk1xF4EmuIvAGeA14kutnwNu018Z8gSe5isCTXD8Dfnk9iy2Vj5oFH/8Z8Nv6fPKvP5YKeHy8CDw+XgQeHy8Cb4D/DPjzCWXe57MCHh8vAo+PF4HHx4vAswP1IfCvrmYvleRq+PjPgD/26/LjXCvgDfCfAF/meXpcXuayVMDjakTgcTUi8LgaEXhcjQg836vRgF/p40Xg8fEi8PTxIvD08SLwBngNeJKrCDzJVQSe5Poh8Ntygd+sAp7kKgJPctWA30iuIvAkVxF4kqsIPMlVBN4ArwFPchWBJ7mKwJNcReBJrhrwOz7+I+Ddr/Dt+HgReHy8CLwB/jNfWi3X17SPtdLH7/h4EXh8vAg8Pl4EHh8vAs8OlAb8wQ6UCDzJVQSe5CoCT3IVgTfAa8CTXEXgSa4fAu/8wPgguYrAk1xF4EmuGvAnyVUEnuQqAk9yFYEnuYrAG+A14EmuIvAkVxF4kqsIPMlVBJ7kKgG/TyRXEXh8/GfAr9fXtOf1+Os07Z8XLzY/772YlYpKhkoJVCIhZFCJOJFBJbJHBpUIKhlUItUkUGkmAmVQiZ2+DCqxLZhBJZy4XqWj2OPaoxwVjfDh4TXizdYBNDrP55RnrWflJdgJNOKzTq/RPF1n0f75eyoq0TlkUInOIYFKvLY7hUp0DhlUonPIoBJZKYNKhkoJVOL7DhlUomXNoBLdQwSV9uviL/QVlegeMqhE95BAJaN7yKAS3UMGlegeMqhE95BBJUOlBCrRPWRQie4hg0p0DxlUonvIoBLdQwKVVrqHDCrRPWRQie4hg0p0DxlUMlRKoBLdQwCVvuEuxSoq0T1kUInuIYNKdA8ZVKJ7SKDSRveQQSW6hwwq0T1kUInuIYNKhkoJVKJ7yKAS3UMGlegeMqhE95BBJbqHBCrtdA8ZVKJ7yKASTjyCSutLpXWvqIQTz6AS7iGCSnu5VPpzu3+qdOAeMqiEe8igEjsXGVRi5yKDSoZKCVQiL2VQibyUQSV2LjKoxM5FBpXoHn5bpf8Df1InfAj8eTwv3+bKf/EnDYEIPKFfBJ4cLwJvgNeAJ22LwBOgReDJxCLwxFwReJKrBPwxkVxF4EmuIvAkVxF4kutnwG/rfIFfSwW8AV4DnuQqAk9yFYEnuYrAk1xF4EmuGvAzyVUEnuQqAk9yFYEnuYrAE6A+Ar7M1xeavv5oFfAEKBF4ApQIPAFKBJ4ApQFfCFAi8AQoEXgClAg8AUoE3gCvAU9yFYEnuYrAk1xF4EmuIvAkVw34heQqAk9yFYEnuYrAk1wbgH+wNFg2Y0m+bMeSyNiOJSmwGUvD5n5k0W964O9heOIMKmGgM6iE286gkqFSApVICBlUIntkUIlUk0ElNsIiqHTYpdJZU4ldswQqrXQPGVSie8igEt1DBpXoHjKoZKgUQKX3B9EfK91DBpXoHjKoRPeQQSW6hwwq0T0kUGmje8igEt1DBpXoHjKoRPeQQSVDpQQq0T1kUInuIYNKdA8ZVKJ7yKAS3UMClXa6hwwq0T1kUInuIYNKdA8ZVDJUSqASeUmv0nk+pzzPtaIRaSm+RmSl8BodJKX4GpGT4mtESoqvERkpvkaGRuE1Ym82vkbszMbXiJ4hvkb0DPE1omcIr9FJzxBfI3oGvUbzNE+vey8VlWgaMqhE15BBJUOlBCrRN2RQicYhg0p0DhlUonXIoBK9Q3yVzonmIYNKdA8RVCrXo0w2VVSie8igEt1DBpUMlRKoRPeQQSW6hwwq0T1EUOmbE6+qRPcQTKVqXqJ7SKDSTPeQQSW6hwwq0T1kUInuIYNKhkoJVKJ7yKAS3UMGlegeMqhE95BBJbqHBCoVuocMKtE9ZFCJ7iGDSnQPGVQyVEqgEt1DBpXoHjKoRPeQQSW6hwwq0T0kUGmhe8igEt1DBpXoHjKoRPeQQSVDpQQqkZf0Kh3FHtce5ahoRFoKoJE9AR7bVtGIrBReIyMpxdcIbxdfI0Oj8BqxpxRfI3aU4mtEPoqvEfkovkbko/AareSj+BqxjxRfI3aR4mtEzxBAo+N56+Os9N6roVF4jegZ4mtEzxBfI3qG+BrRM8TXiJ4hvEYbPUN8jegZ4mtEzxBfI3qG+BoZGoXXiJ4hvkb0DPE1omeIrxE9Q3yN6BnCa7TTM8TXiJ4hvkb0DPE1omeIr5GhUXiN6Bnia0SGja8RGTa+RmTY8BodZNj4GpFh42v06+uRra9b/xnvnUbz9BJ0Xl+C7nv1Ocrj2n3+hvzP6S4/rrX1ed91nv+69oHlBEsFyzmBpYZlBksNSwFLDcsClhoWA0sNyzoklvUyUOt6ONd+/c12PcT2glGO4wlxA+L/DnEH4v8OcUy/3RjimO68JcRlmsb08o0hjun8G0P8/ZxwPqufeVtdiPNcrnZmXstf7cxjgiX9BJZ+gjX9BFv6Cfb0ExzpJzizTzBP6SeY00+Qfk2e06/Jc/Q1eT1eE+zzXxPUdtD2y4we53pd/diK+ho3+gLeeNzoq33jcaNbg8bjRvcRjceNbjrajluiO5TG40a3M43Hje59Go8b3Sg1HtfGGncsV1XGclVlLFdVxnJVZSxXtYzlqpaxXNUylqtaxnJVv/9WS+24Y7mqZSxXtYzlqpaxXNUylquysVyVjeWqbCxXZWO5qt9/o6R23LFclY3lqmwsV7V2te6W+frN6dcfrTJuV+uuP25X664/blfrrj9uV+uuP25X664/blfrrj9uV+uuP25XbYY/bldthjvuNpar2sZyVdtYrmoby1X9/vsktOOO5aq2sVzVNpar2sZyVdtYrmofy1XtY7mqfSxXtY/lqn7/9GztuGO5qn0sV7WP5ar2sVzVPparOoIvROXbL5BLsb/GfUwQfG35FxME/0Ap+7cJjs35T+799Y+Jg3+mfGDi4B8r7Sc+g+e1D0wcPLJ9YOLgqe0DE0dfL9tPHH19bT9x8Pj2gYmDJ7gPTDyc5zqH81znaJ5rnkbzXPM0mueao59E+oGJR/Nc82TDTTya55qjn6T6gYm78lylXDcvy7fXYjyr1Tn6Ma2tx+3KbZWyT69xy89xox8++h/HXZfnaelffzwq43a1BvvjdrUA++N2tfr643a19Prj9rXuuuP2te664/a17nrjRj/WtPW4XfUb/rhjuarox5q2HncsmxH9nM/W445lM6KfBPkfxz2OK96f0/R93J8XLzY/z5VYzCrhOPqxkVI2fS1xbdn0tR62ZWOwuWXTl7Foy6YvF9KWTV+WpS2bvmqUtmz66lyasol+/OEH2Rzl+RbZo1QSQ/STEnVkop9D90Ey5/UgZ+WEvjn6kXVCMuP+a5qneXrde6mwGdcP+2zG9cM+m3H9sM9mXD/ssxnXD7tsop8GJ2Uzrrvx2YzbE/tsxs2YPhsbmM1+Dfk1cIXNyL7YYzOyL/bYjOyLPTYj+2KPzci+2GET/Tw/KZuRfbHHZmRf7LEZ2Rd7bAw2t2zwxfds8MX3bPDF92zwxfds8MW3bA588T0bfPE9m4F98bchvx+x+WIzsC922RhsbtkM7ItdNgP7YpfNwL7YZTOwL3bZDOyLPTZ9nSfcmM3Avthlgy++Z4MvvmdjsLllgy++Z4MvvmeDL75ngy++Y1P6OvP2P7JZX2zWvcJm5DXcYzPyZ/Hr3uWYK2xG/iz22Iz8WeyxGbmjcNjMI3cUHpuROwqPzcj+xmMzsr/x2BhsbtmM3FF4bPDF92zwxfds8MX3bPDFt2w6O7T5ns1j3FGs7mPcUdzrY9xRDOljXBtr3FFs42PcUZzgY9xRzN1j3FH82mPcUSzY/407zAnkj3HHclXDnBP+GLevhejctmvcvTZuXwuRN6719VF1Hufj8mWaSmXcvj6q3HH7+qhyx+0rALrj2ljj9hUA3XE7W3e9cTtbd71x+wqA7rhdBcD9eev95/HXpa8j09+P2pWbej9qV07q/ahduaj3o9o4o3blnt6P2pVzej9qV67p/ahdOab3o47jlvo6aPz9qONYiL6OAX8/qo0zalcWYnk9959Njsq4XdkIf9yurIQ/bld2wh+3K0vhjtvXGdb+uF25KH/czhai9bjG3SrlaV8H3frj9vVRtczXuMtScVV9HSvqj9vXR5U7blehzx+3q+Dnj2tjjdvXuuuO29e6647bVwB0x+0rALrjduaqjtfL7qfKuH0dSumP25mr8sbtzFV543bmqrxxratxbX6Na5W829eZjf64fbkqd9y+XJU7bl+uyh23L1fljLtMfbkqd9y+XJU7bl+uyh23L1fljmtjjTuUq1r6OlDVH3coV7X0deypP+5Yrqqvw0n9ccdyVX0dIeqPO5ar6uugT3/csVxVX8dx+uOO5ar6OjTTHXfp7Cug779GtvR1ssmf74ld455nZdy+1l133L7WXXfczr7x6o3b2TdevXE7++mFN25nP73wxu1s3XXG7ev8C3/czn564Y3bV5vhjtvZN2/KdUzP1+dSZVwba9zOvs/sjdvZ95m9cTv7PrM3bmffZ/bG7ez7zM64W2ffZ/bG7ez7zN64nX2feXn9FuHbzV/jduaqvHFtrHE7c1XeuJ25Km/czlyVN+5QvxJbOjsmxBu3s2NC3HGH+u39sg/12/tlH+q398tuY4071G/vl87OvHHHHeq398s+lqsa60SjZawTjZaxTjRaxjrRaBnrRKNlrBONlrFONFrGOtFoGetEo2WsE42W3k40csbt7Ygfb9yxbEZvR/x449pY445lM/o6BMZ7h+7S1yEw3rjW1yEw/ridvTLYG7ezVwZ743b2ymBv3K7WXX/czl4Z7I3b2SuDvXE7e2WwN25f8X6arp8rf/1fK+P2Fe+9cTs7BMYdt682wx23rzbDHbevNsMd1/paiN6/zN36OgTGH7czV+WN25mr8sbtrKvyxu2sq3LGLZ11Vd64nXVV3riddVXeuJ11Vd64Nta4Y7mqMparKmO5qjKWqypjuaplLFe1jOWqlrFc1TKWq1psrHHHclXLWK5qGctVLWO5qr4OLHbH7evAYn/cvtbd43jevJzTX7v3lZuX9RqyrJUNpb5ON27Mpq8VvS2bvpb/tmz68gpt2fRlLNqy6cuFNGXT11nPjdn01Rr9NzaHXWzOGpu+Kqa2bEb2xR4bg80tm5F9scdmZF/ssRnZF7/uXY65wmZkX+yxGdkXO2z6Oq27MZuRfbHHZmRf7LEZ2Rd7bAw2t2xG9sUem5F9sccGX3zPBl98zwZffMumr/PWG7PBF9+zwRffs8EX37Mx2NyywRffs8EX37PBF9+y6evk8//E5rwe5DzXCplx3Y1HZlxv45EZ19l4ZAwyN2TGdTUemXE9jUdmXEfjkRm35/PIjNvyOWROPPAdGTzwHRk88B0ZPPAdGRu3h5jm6XXvpcJm4G7PZTNwt+eyGbjbc9kMvOftshl4z9ths3b2uoy2bAbe83bZDLzn7bIZeM/bZWMDsyn7dW+bKmxG9sUem5F9scdmZF/ssRnZF3tsRvbFDpu+Xnjy//8aXmWDL771N329SqUxG3zxPRuDzS0b+uJ7NvTF92zoi+/Z0Bffs6EvvmXT2Str2rLBF9+zwRffs8EX37Mx2NyywRffs8EX37PBF9+zwRffs8EX37Lp7KVDbdngi+/Z4Ivv2eCL79kYbG7Z4Ivv2eCL79ngi2/ZdPb6n//C5ijPI4qPclTIjOtuDns+9rFtFTLjehuPzLjOxiMz7vrkkRl3dfLIjNvZeGTGbWwcMgO/G8gjg5+5I4OfuSODn7kjY5C5ITNuS+ORGdgDH+uTzFnJ2gO/DcgjM7AHdsgM7IHfkxn4PUAemYE9sENmYA/skBnYAztkDDI3ZAb2wA4ZPPAdGTzwHRk88B0ZPPANmYHf+eORwQPfkcED35HBA9+RMcjckMED35HBA9+RwQPfkcED35AZ+O1HHhmc3h0ZnN4dGZzeHRmDzA2Z6Ku2nS8y6/EXmccE0VdXf4LoTZA7Qfg3uPgTRF9v/Qmir4v+BNHXL3+C6OuMP0H05O9PED2h+xOkX5PDv/nCnyD7mryFf4uEP0H0NXlZXxPY4bh271XQW/jXNzQeN/pq33hcG2vc6D6i8bjRTUfjcaM7lMbjRrczjceN7n3ajhv+tQKNxx3LVYU//L/xuGO5qvBH9DcedyxXFf4g/cbjjuWqwh9333jcsVxV+EPpG487lqsKf3R843H7clU2XS9as2WqjGtjjduXq1qO13Mvtf+Y+1p3v+74unmpjNvXuuuNG/7Q68bj9rXuuuP2te5u5/NR5n0+K+P2te664/a17rrj9rXuuuP21WZsL8+8l4qrWvpad4/9uvw415/jhj9Y9z+NW+br7OkyV86e3sKfltt43K4+mf1xu/pk9sft6pPZH7erntkft6u864/b1brrjhv+0ODG43aVd/1xx3JV4c/sbTyujTVuZ65qW65xN6uM25mr8sbtzFV543bmqrxxO3NVzrjhj6FtPG5nrsobtzNX5Y3bmavyxrWxxh3LVYU/hLXxuJ3t3jubJuGPvmw8bme79964fe3eH+Xa8DzWSt4Nf/Jk43G7Wnf9cfvavXfH7Wv33h23r98iuOP29Z1Id9zOvpvhjBv+mMnG4/blqtxxx3JV4U95bDyuDfU1sqMzV+WN25mr8sbtzFV543bmqrxxx/rGa/hDPxuP25mr8sbtzFV543bmqrxxbaxxx3JV4Y9AbTzuWK4q/OGqTcfdOzsFdL02POf1+OsXnj8vXmx+3nsxKxU2fS3Sbdn0taK3ZWOwuWXTl1doy6YvY9GWTV8upC2bvixLWzZ9tUZN2XR2NGtbNuOu4Uexx7VHOSpkxl3BHTKdnVL3X8ic14OctZTZ2YF2LcmM+69pnq5f9P35eypsxvXDPptx/bDPZlw/7LMZ1w+7bDo73K8tm3G9jc9mXHfjsxm3J/bZGGxu2Yzsi/fr4q+BK2xG9sUem5F9scdmZF/ssRnZFztsbGRf7LEZ2Rd7bEb2xR6bkX2xx8Zgc8sGX3zPBl98zwZffM8GX3zPBl98y6avw3Ebs8EX37PBF9+zGdgXfxuyFKuwMdjcshnYF7tsBvbFLpuBfbHLZmBf7LIZ2Bd7bPo63rgxm4F9sctmYF/sssEX37Mx2NyywRffs8EX37PBF9+zwRffs8EX37Lp7MTm/8ZmfbFZ9wqbkddwj83In8WvQ9/LMVfYjPxZ7LEZ+bPYYdPZocVt2YzcUXhsRu4oPDYj+xuPjcHmls3IHYXHZuSOwmMzii9+jNuZ1T2P6+ZzTd3O3KszbmfnPbvjduYxvXE7s43euJ05QW9cG2vczvyaN25nFswbtzNX5Y07lqs6h3JVxzSUqzo6O837646vm5fKuH25KnfcvlyVO66NNW5frsodty9X5Y7bl6tyx+3LVbnj9uWqvHE7OzjaHXcsVzV3ZTPKfNXqX3+0yrg21rhd2Qx/3K5shj9uVzbDH7crm+GP25XNcMctXdkMf9yubIY/blfljT/uWK6q2FjjjuWq+nozgz/uWK6qr/cn+OOO5ar6esuBP25iV/WYILFRekyQ2Ps8JrD0EyR2KI8JRv6p1/ufCB4jH1/usRn5+HKXzcg/9fLYjPxTL48NP2W/Z2OwuWUz8k+9PDYj/9TrsIvNWWMz8hEIHpuRfbHHZmRf7LAZ+fhyl83IvthjwxEI/z82lZ8kH0MfX+6xMdjcsuEIhHs2HIFwz4ajwe7ZcDTYPRuOBrtlM/Tx5R4bjga7Z4MvvmeDL75nY7C5ZYMvvmeDL75ngy++Z4MvvmeDL75ls+OL79ngi+/Z4Ivv2Yzrb87rQc5zrZAZ1914ZMb1Nh6ZcZ2NR2ZcX+OQGfhFAB6ZcT2NR2ZcR+ORGbfn88gYZG7I4IHvyOCB78jgge/I4IHvyAzc7U3z9Lr38pNNb28faMpm4G7PZTNwt+eyGXjP22VjsLllM/Cet8tm4D1vl83Ae94um4H3vF02I/visl/3tukHm7O390c0ZTOyL/bYjOyLPTYj+2KPjcHmlg2++J4NvvjO35ydvXqjLRt88T0b+uJbNp29AaQtG/riezb0xfds6Ivv2Rhsbtngi+/Z4Ivv2eCL79ngi+/Z4Itv2fT1yprGbPDF92zwxfds8MX3bAw2t2zwxfds8MX3bPDF92zwxfds8MW3bPp66VBjNvjiezb44ns24/qbozyPKD7KUSEzrrs57PnYx7ZVyIzrbTwy4zobh8zA7wjyyIy7Onlkxu1sPDIGmRsyA/sZhwx+5o4MfuaODH7mjsy4PY1DZuA3AnlkBvbAx/PWx1nJ2gO/DcgjM7AHdsgYZG7IDOyBHTIDe2CHzMAe2CEzsAd2yAzsgd+TGfjtPx4ZPPAdGTzwHRk88B0Zg8wNGTzwHRk88B0ZPPAdGTzwHRk88A2Zgd/045HBA9+RwQPfkcED35HB6d2RwendkcHp3ZHB6d2RwendkPn9N9l8dc/XrZfpPZl1n58Xr/u6ereezusL83OZnKuLPd/Mt0yOQDbNTzVtWl8Tlr1y8b4+T7Hbv73w78/393+OV57g1m/fYv+69KHNgjY6bex56bruFW0MbcJqs6JNWG02tAmrzY42YbU50CasNifaRNXm999rhTb/WpsZbcJqQy8QVxt6gRDafPudyEsbQ5uw2tALKLW5us69pg29gFCb5XyrDb1AXG3oBeJqQy+g02abnpS36fynNjZN9AJxtaEXiKsNvUBcbegF4mpjaKPzaReKbZ4q2tALxNWGXiCuNvQCcbWhF4irDb1AWG1meoG42tALxNWGXiCuNvQCMbSp9AK//15btPnX2tALKLV5vuFjKzVt6AWE2hzbW23oBeJqQy8QVxt6AeH+zfVdjm0tP7Up9AJxtaEXiKsNvUBcbegF4mpjaBNWG3qBuNrQC8TVpkG+sf2qhVbbPCTT8by6lOIeqzSV/Ynw68/H5ly/lPV4Ei/bX8cw/d+8Ld55HWreY7rmPc/KvMtg89pg866DzbsNNu8+2LzHYPP2tv4689pg62+L93SnmrcMNm9n/upryue8y2KVeW2weTvzV+68nfkrd97O/JU7b2f+yp23M3/lzbt25q/ceTvzV+68nfmrZbn6uuXbmeyveXvzV968Nti8vfkrb97e/JU3b2/+ypu3N381v+Zd1sq8vfkrZ96tN3/lzdubv/Lm7c1fefP25q+8eW2weXvzV968vfkrb97e/JU372D+ahvMX+2D+at9MH+1D+av9sH81W6DzTuYv9oH81f7YP5qH8xf7YP5q2Mwv3EM5jeOwfxGi3e+ppp3ML9x9LUelXN7/o6pnPtUmbev9cid9+wr7/vz9rX++vP2tf768/a1/vrz9rX++vP2tf768/aV9/15+8r7/ryd5f1pev6Ye5nKXpm3s7zvzDtPne2nuPN21m+483bWb7jzdtZvuPNaZ+vRcX2/fZpKZd7e/JU3b2/+ypu3N3/lzdtbf+XN21t/5cw799ZfefP21l958/bWX3nz9tZfefPaYPMO5q/mwfzVPJi/mgfzV/Ng/qoM5q/KYP6qDOavymD+qsWZyanmHcxflcH8VRnMX5XB/FVn5yG783Z2HrI/b2fr73E8Tw0v5/TX/n7l5mW9pixrZbOps8OTG8PpbGVvC6czG9AWTmeeoS2czgxGWziduZGmcDo7SroxnM56pP8G53qULz9fg9NZ6dQWztAO2YNjwLmHM7RD9uAM7ZA9OEM75Ne9y5/b/YAztEP24AztkB04nR0G3hjO0A7ZgzO0Q/bgDO2QPTgGnHs4QztkD87QDtmDg0N+AweH/AYODvkeTmfHuTeGg0N+AweH/AYODvkNHAPOPRwc8hs4OOQ3cHDI93A6O1b9P8E5z+e157lW0Azscjw0A3scD83ADsdDY6C5QzOwu/HQDOxtPDQDOxsPzcDNn4dm4N7PQXPghm/R4IZv0eCGb9Hghm/R2MC1xDRPr3svFTgjt30unJHbPhfOyG2fC2fk/XAXzsj74R6c3l7H0RbOyPvhLpyR98NdOCPvh7twbGQ4Zb/ubVMFztAO2YMztEP24AztkD04QztkD87QDvk9nNLZC1X+/1/Kq3BwyLc+p3T2qpbGcHDIb+AYcO7h0CG/gUOH/AYOHfIbOHTIb+DQId/D6e2VOG3h4JDfwMEhv4GDQ34Dx4BzDweH/AYODvkNHBzyGzg45DdwcMj3cHp7qVFbODjkN3BwyG/g4JDfwDHg3MPBIb+Bg0N+AweHfA+nt5cL/Rc4R3k+yfHtQV5oBnY5h21PNNtWQTOwx/HQDOxwPDQDr1IemoHXKA/NwB2Oh2bgBsdBM/Kbhzw0+JpbNPiaWzT4mls0Bpo7NAO3Nh6akd3wsT7RnJXkPfK7hjw0I7thB83Ibvg9mpHfMuShGdkNO2hGdsMOmpHdsIPGQHOHZmQ37KDBDd+iwQ3fosEN36LBDd+hGfmNQh4a3PAtGtzwLRrc8C0aA80dGtzwLRrc8C0a3PAtGtzwHZqRX67kocHy3aLB8t2iwfLdojHQ3KEJv3jb+UKz/n39Y4Twi6w/QvhqyB0h/uth/BHCr7v+COHXR3+E8OuYP0L49cYfIXwV4I8QPrL7I+RfneO/VsMfIf/qHP8VFf4I4VfnZX2NYO71ztunS/x3QzSeN/y633heG2ze8I6i8bzh7UfjecN7lcbzhjc2jecN74KazrvEf2dB43nH8ldL/DcLNJ53LH+1TDbYvGP5qyX+Kf2N5x3LXy3xz9JvPO9g/ir+ifeN5x3MX8U/l77xvJ35K5uud7p9fThV5rXB5u3MXy3H68GX2n/Pna2/2/r80szXH0tl3s7WX2/e+OdpN563s/XXnbez9Xc7n4e3zPt8VubtbP115+1s/XXn7Wz9deftrN/YXv55LxV/VTpbf4/9uvw415/zxj+x9z/NW+brXOsyV861XuIfw9t43r4+n/15+/p89uft6/PZn7ev/tmft6/868/b1/rrzhv/POLG8/aVf/15B/NX8Y8DbjyvDTZvb/5qW655/zztj3l781fevL35K2/e3vyVN29v/sqZN/4Jt43n7c1fefP25q+8eXvzV968Nti8g/mr+Oe7Np63t/19Zz8l/pmajeftbX/fm7ez/f2jXPuhx1rJv/GPtGw8b1/rrz9vZ/v77ryd7e+783b2+wV33s6+P+nO29v3N5x54x9g2XjezvyVO+9g/ir++ZGN57Wxvm+29+avvHl781fevL35K2/e3vyVN+9g34+Nf6Bo43l781fevL35K2/e3vyVN68NNu9g/ir+8aqN5x3MX8U/uLXtvL2dL7pe+6Hzevz1+9CfFy82P++9mFV+TNrbYaRt4XS2sreFY8C5h9OZZ2gLpzOD0RZOZ26kLZzOrEtbOJ31SC3hWG+HvraFM/BSfpTnkxzfHuSFZuCF3EHT27l3/wXNeT7P6DkrkdN6OyKvJZqB/0HN0/VTwD9/TwXOwM7YhzOwM/bhDOyMfTgDO2MXTm/HBbaFM7DH8eEM7HJ8OAN3xz4cA849nKEd8n5d/DVxBc7QDtmDM7RD9uAM7ZA9OEM7ZAfOMrRD9uAM7ZA9OEM7ZA/O0A7Zg2PAuYeDQ34DB4f8Bg4O+Q0cHPIbODjkezidHbnbGA4O+Q0cHPIbOCM75G9TlmIVOAacezgjO2QXzsgO2YUzskN24YzskF04IztkD05nhyY3hjOyQ3bhjOyQXTg45DdwDDj3cHDIb+DgkN/AwSG/gYNDfgMHh3wPp7djoP8bnPUFZ90rcIZeyj04Q38gv06TL39u9wPO0B/IHpyhP5AdOL2dg9wWztCVhQdn6MrCgzO0z/HgGHDu4QxdWXhwhq4sPDjDOOTHvL2Z3vN4Xr7NNX1787HOvL0dIe3O25vb9ObtzUB68/bmCb15bbB5e3Nu3ry9mTFv3t78lTfvYP7qGMxfnYP5q96OCN/W+Zp3reSj3k79duftzF+589pg83bmr9x5O/NX7ryd+St33s78lTtvZ/7KmXft7TRqd96x/NU69eU3ynz17V9/tMq8Nti8ffkNf96+/IY/b19+w5+3L7/hz9uX33DnnfvyG/68ffkNf96++hx/3sH81WyDzTuYv+rsvQ/+vIP5q87ezuDPO5i/6uwdCv68mf3VY4TMlukxQmYX9BjB8o+Q2as8Rhj6N2Lvf124Dn00ugdn6KPRXThD/0bMgzP0b8Q8OPwW/g0cA849nKF/I+bBGfo3YtejzOWswRn6FAUPztAO2YMztEN24Ax9NLoLZ2iH7MHhFIX/g1P5RfM69tHoHhwDzj0cTlF4A4dTFN7A4ZyxN3A4Z+wNHM4Zu4cz9tHoHhzOGXsDB4f8Bg4O+Q0cA849HBzyGzg45DdwcMhv4OCQ38DBId/D2XDIb+DgkN/AwSG/gTOwzznP5y+Yz3OtoBnY5XhoBvY4HpqBHY6HZmB/46AZ+T0DHpqBvY2HZmBn46EZuPnz0Bho7tDghm/R4IZv0eCGb9Hghm/RjNz2TfP0uvfyE053LzdoCmfkts+FM3Lb58IZeT/chWPAuYcz8n64C2fk/XAXzsj74S6ckffDXThDO+SyX/e26Sec7l5P0RTO0A7ZgzO0Q/bgDO2QPTgGnHs4OOQ3cHDI9z6ntzd7tIWDQ34Dhw75Fs7W2wtG2sKhQ34Dhw75DRw65DdwDDj3cHDIb+DgkN/AwSG/gYNDfgMHh3wPp7NX4jSGg0N+AweH/AYODvkNHAPOPRwc8hs4OOQ3cHDIb+DgkN/AwSHfw+nspUaN4eCQ38DBIb+BM7DPOcrzSY5vD/JCM7DLOWx7otm2CpqBPY6HZmCH46AZ+Q1EHpqB1ygPzcAdjofGQHOHZmRf46DB19yiwdfcosHX3KIZuLdx0Iz8viEPzchu+Hje+jgryXvkdw15aEZ2ww4aA80dmpHdsINmZDfsoBnZDTtoRnbDDpqR3fB7NCO/W8hDgxu+RYMbvkWDG75FY6C5Q4MbvkWDG75Fgxu+RYMbvkWDG75DM/J7hDw0uOFbNLjhWzS44Vs0WL5bNFi+WzRYvls0WL5bNFi+OzQtXpOzXIf5f+34rQ6a+Zyvs+LO4/TRvF7SN5Vjc65fyno8Ll/KVirzLp3Ne0zXvOdZmXcbbN59sHmPweY9x5q3xcs+Us07DzZvb+uvN+9g62+LF2ekmncdbN7O/NXXlM95l8Uq83bmr9x5O/NX7ryd+Stv3rMzf+XO25m/cuftzF+583bmr9x5bbB5O/NXy3L1dcs6V+btzV958/bmr7x5e/NX3ry9+av38+5Tb/7Km7c3fzW/5l3Wyry9+Stv3t78lTevDTZvb/7Km7c3f+XN25u/8ubtzV958/bmr5x55978lTfvYP5qHsxfzYP5qxZHvqeadzB/NQ/mr+bB/NU8mL+aB/NXZTB/VQbzV2Uwf1VssHkH8xtlML9RBvMbZTC/sfS1HpVzex5BWc59qszb13rkz9tX3vfn7Wv99efta/315+1r/fXn7Wv99efta/315+0r77vzWl9535+3s7w/Tc+fOy9f/9fKvJ3lfXfezvZT3HltsHk76zfceTvrN9x5e/NXx/X99mkqlXl781fevL35K2fetTd/5c3bW3/lzdtbf+XN21t/5c1rg83bW3/lzdtbf+XNO5i/WgfzV+tg/mobzF9tg/mrbTB/tQ3mrzYbbN7B/NU2mL/aBvNX22D+ahvMX+2D+at9MH/V2XnI/ryD+avOzkMux/F8lnJOf+3vV25e1mvKslY2mzo7PLkxnM5W9rZwOrMBTeF0doZzYzidGYy2cDpzI23hdGZd2sKxkeFcb1+Zy1mD01np1BbO0A7ZgzO0Q/bgDO2QPThDO2QHTmencP9HOK97lz+3+wFnaIfswRnaIXtwhnbIHhwDzj2coR2yB2doh+zBGdohe3CGdsgenKEd8ns4R2fnqDeGg0N+AweH/AYODvkNHAPOPRwc8hs4OOQ3cHDIb+DgkN/AwSHfw+nsJPzGcAb2Oef13Oe5VtAYaO7QDOxxPDQDOxwPzcD+xkMzsLvx0AzsbRw0nZ1B3xTNwM2fh2bg3s9Dgxu+RWOguUODG75Fgxu+RTNy2zfN0+veSwXOyG2fC2fkts+Ds4zc9rlwRt4Pd+GMvB/uwhl5P9yFY8C5hzPyfrgLZ+T9cBfO0A65XI8y2VSBM7RD9uAM7ZAdOL29yaQtnKEdsgdnaIfswcEhv4FjwLn1OZ29qqUxHBzyGzh0yG/g0CG/gUOHfA+nt3fRtIVDh/wGDh3yGzg45DdwDDj3cHDIb+DgkN/AwSG/gYNDfgMHh3wPp7e3CbWFg0N+AweH/AYODvkNHAPOPRwc8hs4OOQ3cHDIb+DgkN/AwSHfw+ntfVBt4Qzsc47yPPL4KEcFjQ2MxrYnmm2roBnY43hoBnY4HpqBVykHzcjvH/LQDNzheGgGbnA8NCP7GgeNgeYODb7mFg2+5hbNwL2Nh2bg1sZDM7IbPtYnmrOSvEd+15CHZmQ37KAZ2Q07aEZ2ww4aA80dmpHdsINmZDfsoBnZDTtoRnbDDhrc8A2ac+T3CnlocMO3aHDDt2hww7doDDR3aHDDt2hww7docMO3aHDDt2hww3doRn6HkIcGN3yLBst3i8ZAc4cGy3eLBst3iwbLd4cm/mty7HyhWY+/rn+MEH6R9UcIXw35I4Rfz/0Rwq+7/gjh10d/hPDrmD9C+PXGHyF8FeCPED6yuyPEf2GHP0L+1Tn+yy/8EfKvzvFfJLGsrxHs8K533j59xn83RON5w6/7jecNbxIazxveUTSeN7z9aDtv/FcnNJ43vLFpPG94F9R43vCWqfG8Nti8g/mr+C8LaDzvYP4q/pH+jecdzF/FP3i/8byD+av4x+M3nncwfxX/EPvG8w7mr+IfNf/f5rXpurstU2XezvyVO29n/mo5Xg++VP57jn9S93+bd1ufz/L1x1KZt7P11523s/XXnbez9dedt7P1dzufh7fM+3xW5u1s/XXn7Wz9deftbP115+2s39he/nkvFX+1d7b+Hvt1+XGulXn7+nwu83WudZkr51qf8Y/hbTxvX5/P/rx9fT778/b1+ezOG/9A5Mbz9pV//Xn7Wn/9efvKv/68Nti8g/mr+McBN553MH8V/+De/zjvtlzz/nnaH/P25q+ceeMfsdt43t78lTdvb/7Km7c3f+XNa4PN25u/8ubtzV958/bmr7x5B/NX8c93bTnvOsU/frPlfsrXvL3t73vz9rX++vN2tr9/lGs/9FiXyryd7e+783a2v+/O29n+vjtvZ/v73rzxj4lsPG9n35905+3t+xvevJ35K3deG2zewfxV/PMjG8/bm796+32zr3l781fevL35K2fe+Cd5Np63N3/lzTvU92O/5u3NX3nz2mDz9uavvHl781fevIP5q/gnpjaedzB/Ff8s1sbzDuavejtfdL32Q+f1+Ov3oT8vXmx+3nsxKxU4nS3WbeF0trK3hdOZDWgLpzPP0BZOZwajKZzeTlttC6cz69IWTmc9Uls4nZVObeEMvJQfxR7XHuWooBl4IXfQ9Hbu3X9Bc17PfdYiZ29H5LVEM/A/qHm6fgr45++pwBnYGbtwtoGdsQ9nYGfswxnYGftwBnbGPhwDzj2cgV2OD2fg7tiHM3Dg9OEM7ZD36+KviStwhnbIDpx9aIfswRnaIXtwhnbIHpyhHbIHx4BzD2doh+zBGdohe3CGdsgeHBzyGzg45Hs4nZ112xgODvkNHBzyGzg45DdwDDj3cHDIb+CM7JC/TVlK5divzo4JbgxnZIfswhnZIXtwOjutuDGckR2yC2dkh+zCGdkhu3AMOPdwRnbILhwc8hs4OOQ3cHDIb+DgkG/hzBMO+Q0cHPIbODjkN3CGXsrXF5x1r8AZeil34PR2APF/g/M6Tb78ud0POEN/IHtwhv5A9uAMXVl4cAw493CGriw8OEP7HA/O0D7HgzN0ZeHBGbqycOD0doT0PZzHvL2Z3vN4Xr7NNX1787HevL1ZU29eG2ze3gykN29vntCbtzeb583bm3Pz5u3NjDnz9naEtDvvYP5qGcxfLYP5q96OCN/W+Zp3reSj3k79duftzF+583bmr9x5O/NX7ryd+Stv3t4OxXbn7cxfufN25q/ceTvzV+68Nti8ffmNMl99+9cfK9/d6uwAcX/evvyGP29ffsOdd+3Lb/jz9uU3/Hn78hv+vH35DX9eG2zevvocf97B/NU6mL/q7CUR/ryD+avOXuXgzzuYv+rshQv+vIP5q9SvRXiMkNkyPUbI7IIeI2Q2No8RMnuV/xth6KPRvV8XDn00ugtn6N+IeXAyr5IfhzP0b8Q8OPwW/g0cfgv/Bs7QvxHz4Az9G7HDLjhnBc7QR6O7cIZ2yB6coR2yB2doh+zBMeDcw+EUhf+DU/tF89hHo3twOEXhDRxOUXgDh1MU7uGMfTS6B4dzxt7A4ZyxN3A4Z+wNHAPOPRwc8hs4OOQ3cHDIb+DgkN/AwSHfwiljH43uwcEhv4GDQ34DB4f8Bo4B5x4ODvkNnIF9znk993muFTQDuxwHzchvG/DQDOxwPDQD+xsPzcDuxkNjoLlDM7Cz8dAM3Px5aAbu/Tw0uOFbNLjhOzTjvFngv6PBDd+iGbntm+bpde+lAmfkts+FY8C5hzNy2+fCGXk/3IUz8n64C2fk/XAXzsj74R6c7t4L0RTOyPvhLpyhHXK5HmWyqQJnaIfswTHg3MMZ2iF7cIZ2yB6coR2yBweH/AYODvne5/T2Zo+2cHDIb+DQIb+BQ4f8Bo4B5x4OHfIbOHTIb+DQIb+Bg0N+AweHfA+ns3fRNIaDQ34DB4f8Bg4O+Q0cA849HBzyGzg45DdwcMhv4OCQ38DBId/D6extQo3h4JDfwMEhv4GDQ34Dx4BzDweH/AbOwD7nKM8jj49yVNAM7HIO255otu0nmn1gj+OhGdjheGgGXqU8NAOvUR6agTscD83ADY6HZmRf46DB19yhGfmtQx4afM0tmoF7Gw/NwK2Nh8YGRnM8b32cleQ98ruGPDQju2EHzchu2EEzsht20Izsht+jGfkNQx6akd2wg2ZkN+ygGdkNO2gMNHdocMO3aHDDt2hww7docMO3aHDDN2iWkd8m5KHBDd+iwQ3fosEN36Ix0NyhwQ3fosEN36LB8t2iwfLdoRn55UoeGizfLRos3y2aFot3OZ5olvVw0BR7vnTvK6S8bnxULrVpfjK3abXr4rJXLt7XJ/H9eN33zxfsf1y6lufXANZv3zL/uvSBZBsQiT0vXde9gmQHyT+RHCD5J5ITJP9A0uT1N50hmUHyTyQFJP9EsoDkn0gMJP9EMqJ7dZCM7V6/fa/3hWRs91pFMqR7vWLfXkMyontdzndIlhHdq4NkRPfqIBnQvW7Tc7htOitIBnSvHhIDyT+RDOhePSQDulcPyYju9XxuWmzzVEEyont1kIzoXt8jsRHdq4NkRPfqIBmxe3WQjNi9OkgMJP9EMmL36iAZsXv9hqTiXm1w91pDMqR7fR7suJUakhHd67G9Q7KO6F4dJCO6VwfJiN3rVUdva6kgGbF7dZAYSP6JZMTu1UEyYvfqIBnQvXpIBnSvHpIB3auDpMWLM+Z1fsWoxUGy7tf3Xb793mKZrgdaoj2QRXugNdoDbb/8QF/bb5fXttoD7dEe6Ij2QGewB2rxWoS2DzRHe6Dy6w/0fP/JNm21B1qiPZBFe6A12gNt0R5oj/ZAR7QHOoM90DFFe6A52gNF+6Q+on1SH9E+qY9on9RHtE/qI9on9RHtk/qI9kl9RvukPqN9Up/RPqnrB5aer+eZzrPl88zztW01l+lb62TPB9qiPdAe7YGOaA90xnogqx//qHygOdoDlWgPtER7IIv2QME+qW0K9kltU7BPapuCfVLbFO2Teo72ST1H+6Seo31Sz7/8z97ZDLJ5j/U85Zf/k3YcvpU52POUYM+zBHseC/Y8DXzH8u15zPsAsue21Ly9TjFZyvU8W7Dn2YM9zxHsec5Yz7NMwZ5nDvY85ZefZynX8xx/Pc/Pa8tWng9ftu/fWfrza4ofV9tyjWpf+/2vh66dhrqvz69Z7UfF9SwLVCpUDCoVKitUKlQ2qFSo7P1QuX7JZV/94ncqj1GPcUY9uxnVruf4+uP+c1SbOhp1uka1rTLqPM6ov20Cj+eoZZoqptSWYM9jwZ5nDfY8W7Dn2YM9zxHseX55wXp94aHYXHmedQr2PHOw5ynBnmcJ9jwW7HnWYM/z0c/nx9+x/8LfcfzC33F+/u/Ypl/4O+Zf+DvKL/wdyy/8HfYLf8f6C3/HL/w7337h3/n2C//Ot1/4d77/wr/z/Rf+ne+/8O98/4V/5/sv/Dvff+Hf+f4L/873X/h3vv/Cv/P9F/6dH//7v/Py2pcvs/dawa9A8DxZ7Mvbfbv1s9A55mgPVKI90BLtgSzaA63RHmiL9kB7tAf63z9P/9P5I3/eaXoVTfPfybP2+Ovyevyj8vhn7Me3949/Tr/9+Pv8enzzHv9DB8DY9HxkK86lx/6sJY/j2/tWayTc76WeM7B/D3YB9u/BXoD9e7AN2L8HewX278HegP3t0geUfUgo33y3VaAcQPkJ5QTKP6Gs05gJx4EyZhJxoIyZGK7v3Xz1ixUoYzp7B4oB5SeUMZ2yA2VIR7tO1w+Qp6MCZUhH60EZ0tF6UIZ0tA6UeUhH60EZ0qes5VmorKUGxYDyE8qQq8/7dx6s85Crjwcl9uozL89Bbd7X71D+7/FL7HXCffzYHYX7+LHbBPfxY6+n7uPHXvncx4+dpd3Hj5163ceP7RBeX+28efzYa/k8L6/H3yqPH3zVdR5/Cb7qeo//y6vu1z7wcT3+UURGULPfvS4F2L8HewH278E2YP8e7BXYvwd7A/bvwd6B/e3SB5RjSCjvv7yxnED5AcUmoPyEMmbCcaCMmUQcKGMmhvffaGlwrliHUMZ04A6UMZ2yA2VIR+t8ecOGdLQelCEdrQNlHdLRelCGdLQelCGXZOe7T+uQS7IHZcgPWue7T9uQH7QelNgftN73GrbYId99/Nhx3H18y/34sddT9/Fjr3zu48eOje7jxw547uPHdgjeF8L22Gu595WkPfiq6z1+8FXXe/zfXnXn+enWy7xOIiMo2u9ucNgrsP817BXYvwd7A/bvwd6B/XuwD2D/HuwT2N8u/T8oxzQklPdf3jhmoPyEUoDyE8qYCceBYkD5CWXMxPD+Gy3HmM7egTKmA3egjOmUHShDOlrnyxvnkI7WgzKko/WgDOloPShDOloPypBLsvPdp3PIJfk9lG0a8oP2/XeftmnID1oPSuwPWud7DdtkuR8/dhx3Hz92cHYfP/Z66j5+7JXPffzYsdF7/Dl2wHMfP7ZDcL4Qts2x13LnK0nbHHzV9R4/+KrrPf6vr7r79X228m37c4T97m3egP17sHdg/x7sA9i/B/sE9q/BLhOwfw/2DOxvlz6glCGhvP3yxlYWoPyEYkD5CWXMhONAGTOJOFDGTAxvv9GylTGdvQNlTAf+HsoyplN2oAzpaN9/eWNbhnS0HpQhHa0HxYDyE8qQjtaDMuSS7Hz3yYZckj0oQ37QOt99siE/aD0osT9ove81WOyQ7z5+7DjuPn7s4Ow+fuz11Hv8NfbK5z5+7NjoPn7sgOc+fmyH4H0hbI29lntfSVqDr7re4wdfdb3H/+1Vd73+ay7b4X2fbfm6yePqZT721+OX5+MfuR//TP34v37OcOPHn3M/fsn9+Evux7fcj7/mfvwt9+PnXnW33KvulnvV3XOvunvuVXfPveruuVfdXz9jt/Hj515199yr7p571d1zr7p77lX3yL3qHrlX3SP3qnvkXnV//TzJxo+fe9U9cq+6R+5V98i96h65V90z96p75l51z9yr7pl71T1zr7pn7lX3zL3qnrlX3TP3qnumXnX3KfWqu0+pV919Sr3q7lPqVXefUq+6+5R61d2n1KvuPqVedfcp9aq7T7lX3Tn3qjvnXnXn3KvunHvV/fVjFRs/fu5Vd8696s65V90596o75151S+5Vt+RedUvuVbfkXnV//QCxxo+fe9UtuVfdknvVLblX3ZJ71V1yr7pL7lV3yb3qLrlX3V8/5Kjx4+dedZfcq+6Se9Vdcq+6S+5V13KvupZ71bXcq67lXnV//cSrxo+fe9W13Kuu5V51Lfeqa7lX3TX3qrvmXnXX3KvumnvV/fWzqRo/fu5Vd8296uY+m2rPfTbVnvtsqj332VR77rOp9txnU+25z6bac59Ntec+m2rPfTbVnvtsqj332VR78LOpyvw8Svfrgvnn4wc/m8p9/Nirrvv4sVdd9/Fjr7ru48dedd3Hj73quo/fYNU9nw+0ma3O48/n9UDzebxuPR/Vq6d5LteTzN/ePvHn+scEe/oJjvQTnNknaHFOlXiCOf0EJf0ES/oJLP0Ea/oJ0q/JR/o1+Yi+Jq/Ha4J99q4/9vV5+XGu30zjc9zoC3jbcc/oq33jcaNbg8bjRvcRjceNbjoaj2tjjRvdzjQeN7r3aTxudKPUeNyxXNU5lKs6pqFc1TEN5aqOaShXdUxDuapjsrHGHcpVHdNQruqYhnJVxzSUqzqmsVzVPJarmsdyVfNYrmoey1W1OJ8v07hjuap5LFc1j+Wq5rFc1TyWqypjuaoylqtqcUJfnHHLvD0f/OuPVhm3q3XXH7erddcft6t11x+3q3XXH7erddcdd+lq3fXH7Wrd9cftqs3wx+2qzfDHtbHGHctVLWO5qmUsV7WM5aqWsVyVjeWqbCxXZWO5KhvLVbU4YTPTuGO5KhvLVdlYrsrGclU2lqtax3JV61iuah3LVa1juao1+EJUvv0CuRT76/rHBMHXFn+CLfgHStm/TXBs/9P1j4mDf6Z8YOLgHysfmNiGmzh4ZPvAxMFT2wcmjr5etp84+vrafuLg8a39xHvwBPeBiYfzXPtwnmsfznO1OCM02cTDea7oJ5F+YOLhPFf0k04/MPFwniv6SaofmLgrz1XK9SxlmV9F7FWtRj+mtfW4XbmtUvbpNW6pjNvVMlzW5Xn3rz8elXG7WoP9cbtagP1xu1p93XGjH2vaety+1l133L7WXXfcvtZdd1wba9yu+g1/3LFcVfRjTVuPO5TNOKOf89l63KFsxjn1tRB9tTPPcb/+w/0+7s+LF5uf50osZqXCpq9Vqy2bvpa4tmz6Wg/bsumrkmjLpi9j0ZRN9HMxpWz6sixt2fRVo7Rl01fn0pbNuGv4Uexx7VEqiSH6SYk6MtHPofsgmfN67rNyQt8Z/cg6IZlx/zXN0zy97r1U2Izrh1020U9Wk7IZ1w/7bMb1wz6bcf2wz8Zgc8tmXHfjsxm3J/bZjJsxfTYj++L9mnIulW4i+nF3SjbRz8aTshnZF3tsRvbFHpuRfbHHxmBzy2ZkX+yxGdkXe2xG9sUeG3zxPRt88S2b6KcbStngi+/Z4Ivv2eCL79kYbG7Z4Ivv2Qzsi8tryu9HbL7YDOyLXTYD+2KXzcC+2GOzDeyLXTYD+2KXzcC+2GUzsC922RhsbtkM7ItdNvjiezb44ns2+OJ7NvjiWzZ9naXcmA2++J4Nvviezchr+Ppis+4VNiOv4Q6bvs5Y/Y9sXvcuf273g83In8Uem5E/iz02I3cUHhuDzS2bkTsKj83I/sZjM7K/8diM3FF4bEbuKBw2nR2A3JYNvvieDb74ng2++J6NDcLmMe4oVvcx7iju9THuKIb0Me4oHvMx7ii28c+429TZGdXuuKOYu8e4o/i1x7ijWLDHuDbWuCO5qq9xR3JV29TZMcXntl3j7rVx+1qI3HH7+qj6uuXj8uVrja2M29dHlTtuXx9V7rh9BUB33L4CoDtuXwHQG7d0tu5643a27nrj9hUA3XG7CoD780n2tTKqjTNqV27q/ahdOan3o3blot6P2pWDej9qV+7p7ah9HST/ftSuXNP7UbtyTO9HHcct9XXQ+PtRx7EQfR0D/n7UcSxEX4d0L6/fti1l2X6O29e52/64XVkJf9yu7IQ/bleWwh/Xxhq3Kxflj9vZQrQe17hbpTzt66Bbf9y+PqqW+Rp3WSquqq9jRf1x+/qocsftKvT543YV/Pxxuwp//rh9rbveuH0dpOmP21cAdMftKwC643bmqo7Xy+6n2rg21riduSpv3M5clTduZ67KG7cvV2Xza1yr5N2+zmx0x+3rGEZ/3L5clTtuX67KHbcvV+WOa2ON25ercsfty1W54/blqtxxx3JV+1iuqq8DVf1xx3JVfR176o87lqvq63BSf9yxXFVfR4j6447lqvo66NMfdyxX1ddxnP64Y7mqvg7N9Mf9312V7fYcd7XNGbd8GZvH1aWUwx13nl/jzmv56/rHBJZ+gjX9BFv6Cfb0ExzpJziTTzA3OJ9RPcGcfoKSfoLsa/I8ZV+T5yn6mnx9X/7rz/vsXX/sTxs4H+fPb1fMU/QFvPG40Vf7xuNGtwaNx43uI9qOO0c3HY3Hje5QGo8b3c40Hje692k8ro017liuah7LVc1juap5LFc1j+WqyliuqozlqspYrqqM5aoanLaaatyxXFUZy1WVsVxVGctVlbFc1TKWq1rGclXLWK5qGctVLTbWuGO5qmUsV7WM5aqsq3W3zNvzwb/+aJVxu1p3/XG7Wnf9cbtad/1xu1p3/XG7Wnf9cbtad/1xu1p3/XG7ajP8cbtqM9xx17Fc1TqWq1rHclXrWK6qwQnLqcYdy1WtY7mqdSxXtY7lqtaxXNU2lqvaxnJV21iuahvLVTU4YTnVuGO5qm0sV7WN5aq2sVzVNpar2oMvROXbT3JLsb+uf0wQfG35FxME/0D5b2fLvL/+MXHwz5QPTBz8Y6X9xEfwvPaBiYNHtg9MHDy1fWDi6Otl+4mjr6/tJw4e3z4wcfAE94GJh/Ncx3Ce6xjOc53Dea5zOM91Due5oh9G+oGJbbiJh/Nc0Q9H/cDEXXmuUq7znMsyv4rYq1qNfvJq63G7clul7NNr3J8nZJfo54n+x3HX5Xnc+Ncfj8q4Xa3B/rhdLcD+uF2tvv64XS29/rh9rbvuuH2tu+64fa273rjRjzVtPW5X/YY/7liuKvqxpq3HHctmRD/ns/W4Y9mM6CdB/sdxj+OK9+c0fR/358Xe66NK9GMjpWz6WuLasulrPWzLxmBzy6YvY9GWTV8upC2bvixLWzZ91Sht2fTVuTRlE/34ww+yOcrzSY5SSQzRT0rUkYl+Dt0HyZzXtupZOaGvRD+yTkhm3H9N8zRPr3svFTbj+mGfzbh+2Gczrh/22Yzrh3024/phl0300+CkbMZ1Nz6bcXtin824GdNnYwOz2a8p51LpJqIfdydlM7Iv9tiM7Is9NiP7Yo/NyL7YYRP9PD8pm5F9scdmZF/ssRnZF3tsDDa3bPDF92zwxfds8MX3bPDF92zwxbdsdnzxPRt88T2bgX1xeU35/YjNF5uBfbHLxmBzy2ZgX+yyGdgXu2wG9sUum4F9sctmYF/ssenrPOHGbAb2xS4bfPE9G3zxPRuDzS0bfPE9G3zxPRt88T0bfPEtm77OvP2PbNYXm3WvsBl5DffYjPxZ/Lp3+XO7H2xG/iz22Iz8WeyxGbmjeM9mmUbuKDw2I3cUHpuR/Y3HZmR/47Ex2NyyGbmj8Njgi+/Z4Ivv2eCL79ngi2/ZdHZo8z2bx7ijWN3HuKO418e4oxjSx7g21rij2MbHuKM4wce4o5i7x7ij+LXHuKNYsP8bd5gTyB/jjuWqhjkn/DFuXwvRuW3XuHtt3L4WIm/cpa+PqvM4H5d/bfmUyrh9fVS54/b1UeWO21cAdMe1scbtKwC643a27nrjdrbueuP2FQDdcbsKgPvTMe8/j79e+joy/f2oXbmp96N25aTej9qVi3o/qo0zalfu6f2oXTmn96N25Zrej9qVY3o/6jhuqa+Dxt+POo6F6OsY8Pej2jijdmUhltdv25aybJVxu7IR/rhdWQl/3K7shD9uV5bCHbevM6z9cbtyUf64nS1E63GNu1XK074OuvXH7eujapmvcb+2sH6O29exov64fX1UueN2Ffr8cbsKfv64Nta4fa277rh9rbvuuH0FQHfcvgKgO25nrup4vex+qozb16GU/riduSpv3M5clTduZ67KG9e6Gtfm17hWybt9ndnoj9uXq3LH7ctVueP25arccftyVd64Z1+uyh23L1fljtuXq3LH7ctVuePaWOOO5ar6OlDVH3csV9XXsaf+uEO5KuvrcFJ/3KFclfV1hKg/7lCuyiYba9yhXJX1dRynP+5Qrsr6OjTTHfez58U9/o71F/6O7Rf+jv0X/o7jF/6O8/N/x2dPu3r8HfMv/B3/u1HbpudpO9tm5nwczNv0/LXFn289fvsHu1SuXvfrn/e6r6t37+mcnveey+Rd/fr5fpnm2XkSW6+Xu9i6vT7GtucHTVkA2QakAfLfgTQH5DouyOsnXV8gzQP5xfoJclpfV5e9cvG+7o9r9+Ol0M19n19O+vokf3/pcZme43gpWWqazPPx1OQLhH2/+CH7huwjyr4j+4iyH8g+ouwnsg8oe4ODS5E9oewzsoeU/SHPwB1KCHm+NQpWkWfgZiaDPIY8keWhRQotD21PaHloZbTyHE8XbsdSkYf2JLQ8tByR5THaiNDy0BpI5Vmn56XrdFTkoTUILQ+tQWh5DHkiy0NrEFoejLVWnvKEt5aKPCvGOrQ8WAOpPNvy/JrktpaKPIY8keXBGvw7eeblidzmb28m+JLnAZLqvxFISvpGIKnTG4HEn7cBueGkG4GkTG4Ektq3EUhS2L8FOb8HaYD8dyDn5QVyq4Ak2TQCSbJpBHLYZFMmOy6QRxFVIaLfC2zD5rCxZR82NQ4t+z5sxh1b9mET+diyD9sfjC37sG1HcNkf8hjySOV5/zOcfdhmJoc8w/Y9OeShRQotD21PaHloZbTyvP+V1EF7EloeWo7Q8tBGhJaH1kAqj/MznAbvfEWeD8pDaxBaHlqD0PLQGkSW58RYa+V5/xvDE2MdWh6sgVQe5zeGJ9YgtDxYg38nj/cbiJPqvxFISvomINeJOr0RSPx5I5A46UYgKZMbgTRAtgFJCvu3IOf3IMlL/xLk+x/crRPJphFIkk0jkOMmm3l+PneZ10lUhWh+L7DO4+awoWUfNzUOLfu4GXdo2cdN5EPLbsg+ouzjth2xZX/IM26HEkOetz/DWedxm5kU8ozb96SQhxYpsjyFtie0PLQyWnne/kpqLbQnoeWh5QgtjyFPZHloDaTyvP8ZzlpoDULLQ2sQWh5ag9Dy0BpElmfBWGvlefsbw3Ux5IksD9ZAKs/73xiuC9YgtDxYg38nj/cbCKP6bwSSkr4RSOr0RiDx541AGiDbgKRMbgSS2rcRSFLYvwX5/iegRl76lyCdH9wZyaYNyJVk0wjkwMlmv35LW759aXuI3wusA+ewkWUfODWOLLsh+4iyD5zIR5Z94P5gZNkHbjtCy/6QZ+AOJYQ873+Gsw7czCSQZxu478kgDy1SaHloe0LLQyujlef9r6Q2Q57I8tByhJaHNiK0PLQGUnmcn+FstAah5aE1iCzPTmsQWh5ag9DyYKy18rz/jeGOsQ4tD9ZAKo/zG8MDaxBaHqzBv5PH+w3EQfXfCCQlfSOQBsg2IPHnjUDipBuBpExuBJLatxFIUti/Bfn+J6AneelfgnR+cHeSbBqBJNk0AjluslmvT72yHd5vaZevmzyuXuZjf4EsT5AGyDYgx002jUGOm2wagxw32TQGOW6yaQxy3GTTFOQ2jZtsGoMcN9k0BjlusmkMkmTTCKQBsg1Ikk0jkCSbRiBJNo1AkmwagSTZtAE5k2wagSTZNAJJsmkEkmTTCKQBsg1Ikk0jkCSbRiBJNo1AkmwagSTZtAFZSDaNQJJsGoEk2TQCSbJpBNIA2QYkyaYRSJJNI5Akm0YgSTaNQJJs2oBcSDaNQJJsGoEk2TQCSbJpBNIA2QYkyaYRSJJNI5Akm0YgSTaNQJJs2oA0kk0jkCSbRiBJNo1AkmwagTRAtgFJsmkEkmTTCCTJphFIkk0jkCSbNiBXkk0jkCSbRiBJNo1AkmwagTRAtgFJsmkEkmTTCCTJphFIkk0jkCSbNiA3kk0jkCSbRiBJNo1AkmwagTRAtgFJsmkEkmTTCCTJphFIkk0jkCSbNiAHfjV4Y5Akm0YgSTaNQJJsGoE0QLYBSbJpBJJk0wgkyaYRSJJNI5AkmzYgD5JNI5Akm0YgSTaNQJJsGoE0QLYBSbJpBJJk0wgkyaYRSJJNI5AkmzYgT5JNI5Akm0YgSTaNQJJsGoE0QLYBSbJpBJJk0wgkyaYRSJJNI5AkmyYg94lk0wgkyaYRSJJNI5Akm0YgDZBtQJJs/h3IMu9PkGWZKyBJNo1AkmwagSTZNAJJsmkDcibZNAJJsmkEsqdkU5YLZLHy19WPaXuKH/60NtS0Pdmmctjz3kvZvKvP6x/5fB6vIeej/nHz9SlzMZnX8tf1D5Y9OSc1y57Mk5hlV286V7PsyUKpWXblosQsu/JoYpYGy2YseyqK1Sx76orVLMk97ViSe9qxJPf8W5br8WK5z971x/588vk4129zPsB39dL0VOBJVCLwxC8ReLKaCLwBXgOeFCgCT2QUgSdfisATRkXgSa4a8EZyFYEnuYrAk1xF4EmuIvAGeA14kqsIPMlVBJ7kKgJPchWBJ7lqwK8kVxF4kqsIPMlVBJ7kKgJvgNeAJ7mKwJNcReBJriLwJFcReJKrBvxGchWBJ7mKwJNcReDx8R8BX76me1z+9UergMfHi8Dj40Xg8fEi8Ph4DfgdHy8Cj48XgcfHi8CzAyUCb4DXgCe5isCTXEXgSa4i8CRXEXiSqwb8QXIVgSe5isCTXEXgSa4i8AZ4DXiSqwg8yVUEnuQqAk9yFYEnuWrAnyRXEXiSqwg8yVUEnuQqAm+A14DHTv5L8OXbWfyl2F/XP1jiEFuxPCaWwH/Lcv/G8tj+p+sf7FkFdexZCHXsaXF17ClydezpcnXs8d869vh1GfuZUlfHnl5Xx55cq2NPrtWxN9jL2JNrdezJtTr25Fode3Ktjj25Vsa+kGt17Mm1Ovbk2o+wL+V8zlmWef425xM8oVYE3gD/GfD79AJfKuCx9Z8Bvy7Pu3/98aiAx9OLwGPoNeAX3LwIPFZeBB4fLwKPjxeBN8BrwLMtJQLPnpQIPMlVBJ7kqgFvBCgReAKUCDwBSgQeO/kZ8MdxbYSc0/Qd/M+LF7vGXMwq5b3hPTOohFHNoBKuNoNKbN4kUGklqGRQiVSTQSUiUAaV2HDKoJKhUgKVcOJ6lY7yfO6jVPoh3n0fXyPeXR1Ao/P64vNZeb/4wWuuE2jEZ51eo3map9e9l58q8TLhFCrROWRQic4hg0p0DhlUMlRKoBJZKYNKpKUMKvF9hwwq0bJmUInuIYJK+8V7LpUdC14HnUIluocMKtE9ZFCJ7iGDSoZKCVSie8igEt1DBpXoHjKoRPeQQSW6hwQq8ULvFCrRPWRQie4hg0p0DxlUMlRKoBLdQwaV6B4yqET3EECl8uJdilVUonvIoBLdQ3yVvm6ASglUonvIoBLdQwaV6B4yqGSolEAluocMKtE9ZFCJ7iGDSnQPGVSie0ig0kz3kEEluocMKtE9ZFCJ7iGDSjjxCCqtL5XWvaISTjyBSgX3EEGl173Ln9v9UAn3kEEl3EMGlQyVEqjEzkUGldi5yKASeSmDSuSlDCqxc5FApYWdiwwq0T1kUInuIYNKdA8ZVDJUSqAS3cNvq/QAT50gAk9DIAJP6BeBJ8drwBvRXASetC0CT4AWgScTi8Ab4DXgSa4i8CRXEXiSqwb8ip38DPhz2y7wew08dlIEnsX1Q+CP83H5Mk2lAp7FVQSexVUEnlpYBJ5aWAN+oxYWgcfHi8Dj40XgqYVF4A3wnwC/P6fc1wp0UqsAOolVAJ20KoBOUhVAJ6X+PvSdhCqATjoVQCeZCqCTSgXQDei/D51wJIBOOBJAJxwJoBOOfh/6QTj6CPTldRbq12hbBTwBSQSekCQCT1ASgTfAa8CzhScCT1LVgD+xkx8Cvx4X+K3yFY0TOykCz+L6GfDLfIFflkpyPVlcReBZXEXgqYJF4KmDReCphBXg92nCx4vA4+NF4KmFReCphUXgDfCfAX88n3yxqQae5CoCT3IVgSe5isCTXEXgSa6fAW/zC7yVn+B5970KPMlVBJ7kKgJPchWBN8BrwJNcReBJriLwJFcReJKrCDzJVQO+kFxF4EmuIvAkVxF4kqsIvAFeA57kKgJPchWBJ7mKwJNcReBJrhrwC8lVBJ7kKgJPchWBJ7mKwOPjPwP+/Q+Mv8Dj4z8E/pgu8N8QXuB54bkKPK5GBB5XIwKPqxGBN8BrwNPHi8Dj40Xg8fEi8PTxIvD08RrwK8n1M+C/cD/BL4tVwJNcReBJriLwJFcReAO8BjzJVQSe5CoCT3IVgSe5isCTXD8EfnmdSbbOP8FvJFcReJKrCDzJVQSe5CoCb4DXgCe5fgi8c9LqRnIVgSe5isCTXEXgSa4a8DvJVQSe5CoCT3IVgSe5isAb4DXgSa4i8CRXEXiSqwg8yVUEnuSqAX+QXEXgSa4i8CRXEXiSqwi8AV4DnuQqAk9yFYEnQInAE6A04E8ClAg8AUoEngAlAo+d/Aj4cm5PKuXcpwp47KQIPBshIvD4eBF4fLwE/Dzh40Xg8fEi8Ph4EXg2QkTgDfAa8CTXj4Bfpuk6uP/r/1oBT3IVgSe5isCTXEXgSa4a8DPJVQSe5PohO3lcJzRNU6mAJ7mKwJNcReAN8BrwJFcReJKrCDzJVQSe5CoCT3LVgC8kVxF4kqsIPMlVBJ7kKgJvgNeAJ7mKwJNcReBJriLwJFcReJKrBvxCchWBJ7mKwJNcReBJriLwBngNeJKrCDzJVQSe5KoBb/j4z4A/juec5Zz++kVI7cHXi3dZK1+0NEx/BpVICBlUIk5kUMlQKYFKBJUMKpFqMqhEBMqgEjt9EVR6PXg5ayqxLZhApZXuIYNKdA8ZVKJ7yKAS3UMGlQyVAqj0unf5c7sfKtE9ZFCJ7iGDSnQPGVSie8igEt1DApU2uocMKtE9ZFCJ7iGDSnQPGVQyVEqgEt1DBpXoHjKoRPeQQSW6hwwq0T0kUGmne8igEt1DBpXoHjKoRPeQQSVDpQQqkZf0Kp3n89rzXCsakZbia0RWCq/RQVKKrxE5Kb5GpKT4GpGR4mtkaBReI/Zm42vEzmx8jegZ4mtEzxBfI3qG8Bqd9AzxNaJn0Gs0T/P0uvdSUYmmIYNKdA0ZVDJUSqASfUMGlWgcMqhE55BBJVqHDCrRO8RXqUw0DxlUonuIoFK5HmWyqaIS3UMGlegeMqhkqJRAJbqHDCrRPWRQie4hmBOvqkT3EEylal6ie0ig0kz3kEEluocMKtE9ZFCJ7iGDSoZKCVSie8igEt1DBpXoHjKoRPeQQSW6hwQqFbqHDCrRPWRQie4hg0p0DxlUMlRKoBLdQwaV6B4yqET3kEEluocMKtE9JFBpoXvIoBLdQwaV6B4yqET3kEElQ6UEKpGX9Cod5fncRzkqGpGWAmhkT4LHtlU0IiuF18hISvE1wtvF18jQKLxG7CnF14gdpfgakY/ia0Q+iq8R+Si8Riv5KL5G7CPF14hdpPga0TME0Oh4Tnmcld57NTQKrxE9Q3yN6Bnia0TPEF8jeob4GtEzhNdoo2eIrxE9Q3yN6Bnia0TPEF8jQ6PwGtEzxNeIniG+RvQM8TWiZ4ivET1DeI12eob4GtEzxNeIniG+RvQM8TUyNAqvET1DfI3IsPE1IsPG14gMG16jgwwbXyMybHyNDI3+pUZ2vjRaj7+uf7DEI7djyZ5ZO5bkgnYs8e/tWOKzm7E88cPtWOJb27Fkj6QdS/Yy2rE0WDZjSe5px5Lc044luacdS3LPv2W5rC+WdnjXf6v+yp8r/lnQnYQkCfhlIlGJwBO/RODJaiLwBDsReAO8BjyRUQSefCkCTxgVgSe5isCTXDXgZ5KrCDzJVQSe5CoCT3IVgTfAa8CTXEXgSa4i8CRXEXiSqwg8yVUDvpBcPwPepuvutkwV8CRXEXiS62fAL8fyAl/7qMHHfwb8tr7mXEsFPD5eBB4fLwKPjxeBx8d/CPz5pDLv8/kT/IKPF4HHx4vA4+NF4NmB+hD4V1ezl0pyXfDxnwF/7Nflx7lWwONqPgK+zPP0uLzMf2b7J3jD1YjA42pE4HE1IvC4GhF4A7wGPH28CDw+XgSePl4Enj5eBJ7kqgG/klxF4EmuIvAk1w+B35YL/GYV8CRXEXgDvAY8yVUEnuQqAk9yFYEnuYrAk1w14DeSqwg8yVUEnuQqAk9yFYHHx38EvPsVvg0fLwKPjxeBx8d/BvxRrq9pH2ulj9/x8SLw+HgReHy8CDw+XgTeAK8Bzw6UCDzJVQSe5CoCT3IVgSe5asAfJFcReJLrh8A7PzA+SK4i8CRXEXgDvAY8yVUEnuQqAk9yFYEnuYrAk1w14E+Sqwg8yVUEnuQqAk9yFYE3wGvAk1xF4PHxnwG/Xl/Tntfjr9O0f1682DXmYlY5evvE9MdXySYSQgaViBMZVCJ7ZFCJoJJBJUOlBCoRgTKoxE5fBpXYFkyg0owT16t0lOdzH+WoaIQPj68RHZ5eo/N8MjkrPavxEuz4GvH24AAazdN1Fu2fv6eiEp1DBpUMlRKoROeQQSU6hwwq0TlkUImslEEl0lIClXgveQqVaFkzqET3EEGl/bp4LpUdC16PnkIlQ6UEKtE9ZFCJ7iGDSnQPGVSie8igEt1DApWM7iGDSnQPGVSie8igEt1DBpUMlRKoRPeQQSW6hwwq0T1kUInuIYNKdA8JVFrpHgKoVF68S7GKSnQPGVSie8igEt1DBpUMlRKoRPeQQSW6hwwq0T1kUInuIYNKdA8JVNroHjKoRPeQQSW6hwwq0T1kUMlQKYFKdA8ZVKJ7SKDSjhOPoNL6UmndKyrhxDOoZKgUQKW9XCr9ud0PlXAPGVTCPWRQiZ2LDCqxc5FBJXYuEqh0kJcyqEReyqASOxcZVGLnIoNKhkq/rNIDPHXCh8CfxzXnXPsvnoZABJ7QLwJPjheBJ5prwJ+kbRF4ArQIPJlYBJ6YKwJvgNeAJ7mKwJNcReBJriLwJNfPgN/W15xrpZ08Sa4S8OtEchWBJ7mKwJNcReBJriLwBngNeJKrCDzJVQSe5CoCT3LVgJ8JUB8BX+brC01ff7QKeAKUCDwBSgSeACUCb4DXgCdAicAToETgCVAi8AQoEXi2/jTgC8lVBJ7kKgJPchWBJ7mKwBvgNeBJriLwJFcReJKrCDzJtQH4B0vCaDOWC/myHUsiYzuWpMB2LLG5H1n0mx74uy544gwqYaAzqITbzqASPj6BSkZCyKAS2SODSqSaDCqxERZBpdeDl7OmkqFSApXoHjKoRPeQQSW6hwwq0T1kUInuIYJK7w+iX1e6hwwq0T1kUInuIYNKdA8ZVDJUSqAS3UMGlegeMqhE95BBJbqHDCrRPSRQaaN7yKAS3UMGlegeMqhE95BBJUOlBCrRPWRQie4hg0p0DxlUonvIoBLdQwKVdvKSXqXzfDI5z7WiEWkpvkaGRuE1IinF14icFF8jUlJ8jchI8TUiIYXX6GBvNr5G7MzG14ieIb5G9AzxNTI0Cq8RPUN8jegZ9BrN0zy97r1UVKJpyKASXUMGlWgbEqh00jdkUInGIYNKdA4ZVKJ1yKCSoVIClWgeMqhE9xBBpXI9ymRTRSW6hwwq0T1kUInuIb5K20T3kEEluocMKtE9BHPiVZXoHoKpVMlL22SolEAluocMKtE9ZFCJ7iGDSnQPGVSie0ig0kz3kEEluocMKtE9ZFCJ7iGDSoZKCVSie8igEt1DBpXoHjKoRPeQQSW6hwQqFbqHDCrRPWRQie4hg0p0DxlUMlRKoBLdQwaV6B4yqET3kEEluocMKtE9JFBpIS/pVTrK87mPclQ0Ii0F0MieBI9tq2hkaBReI5JSfI3wdvE1wtmF18jYU4qvETtK8TUiH8XXiHwUXyNDo/AakY/ia8Q+UnyN2EWKrxE9QwCNjuetj7PSexs9Q3iNVnqG+BrRM8TXiJ4hvkb0DPE1MjQKrxE9Q3yN6Bnia0TPEF8jeob4GtEzhNdoo2eIrxE9Q3yN6Bnia0TPEF8jQ6PwGtEzxNeIniG+RvQM8TWiZ4ivET1DeI12eob4GpFh42tEho2vkaFReI3IsPE1IsOG1+gIvjexPa9ej2Vx7z2/7v3ttZJ/rn5MG9whNZ42uNdoPG3wVbvxtMG7p/8ybZnP56dlKbv3JGW6PolLKe5n5TTP5WIyr+Wv6x8sg3dEqVgG73IysTyDdy6pWHbkc+QsO3JRcpYdeTQ5S4NlM5bB+5VULIP3IKlYknvasST3tGNJ7vm3LNfjxXKfveuP/apGj3P9//yzwNwnQpIIPIlKBJ74JQJPVhOBN8BrwJMCReCJjCLw5EsReMKoCDzJVQN+JrmKwJNcReBJriLwJFcReAO8BjzJVQSe5CoCT3IVgSe5isCTXDXgC8lVBJ7kKgJPchWBJ7mKwBvgNeBJriLwJFcReJKrCDzJVQSe5KoBv5BcReBJriLwJFcReHz8R8CX+Tr95uuPVgGPjxeBx8eLwOPjReDx8Rrwho8XgcfHi8Dj40Xg2YESgTfAa8CTXEXgSa4i8CRXEXiSqwg8yVUDfiW5isCTXEXgSa4i8CRXEXgDvAY8yVUEnuQqAk9yFYEnuYrAk1w14DeSqwg8yVUEnuQqAk9yFYE3wGvAYyf/Jfjy7Sz+Uuyv6x8scYjNWEZ/p3gglvs3lsf2P13/YM8qqGPPQqhjT4urY0+Rq2NPl6tjj//Wscevy9gflLo69vS6OvbkWh17cq2OvcFexp5cq2NPrtWxJ9fq2JNrdezJtTL2J7lWx55cq2NPrv0I+1LO55OXZZ6/zfkET6gVgTfAfwb8Pr3Alwp4bP1nwK/L9SzrclTA4+lF4DH0EvDHhJsXgcfKi8Dj40Xg8fEi8AZ4DXi2pUTg2ZMSgSe5isCTXDXgZwKUCDwBSgSeACUCj538DPjjuDZCzmn6Dv7nxYvNz7cTLWalohLeM4NKGNUMKuFqM6jE5k0ClQpBJYNKpJoMKhGBMqjEhlMGlQyVEqiEE9er9PVv5XHtUSr9EO++j68R764OoNF5ffH5rLxf/OA11wk04rNOr9E8zdPr3stPlXiZcAqV6BwyqETnkEElOocMKhkqJVCJrJRBJdJSBpX4vkMGlWhZM6hE9xBBpf3iPZfKjgWvg06hEt1DBpXoHjKoRPeQQSVDpQQq0T1kUInuIYNKdA8ZVKJ7yKAS3UMClXihdwqV6B4yqET3kEEluocMKhkqJVCJ7iGDSnQPGVSiewigUnnxLsUqKtE9ZFCJ7iGBSjvdQwaV6B4yqET3kEEluocMKhkqJVCJ7iGDSnQPGVSie8igEt1DBpXoHhKodNA9ZFCJ7iGDSnQPGVSie8igEk48gkrrS6V1r6iEE0+g0ol7iKDS697lz+1+qIR7yKAS7iGDSoZKCVRi5yKDSuxcZFCJvJRBJfJSBpXYuYiv0tcNUCmBSnQPGVSie8igEt1DBpUMlRKoRPfw2yo9wFMniMDTEIjAE/pF4MnxGvAz0VwEnrQtAk+AFoEnE4vAG+A14EmuIvAkVxF4kqsGfMFOfgb8uW0X+L0GHjspAs/i+iHwx/m4fJmmUgHP4ioCz+IqAk8tLAJPLawBv1ALi8Dj40Xg8fEi8NTCIvAG+E+A35/Pva8V6KRWAXQSqwA6aVUAnaQqgE5K/X3oRkIVQCedCqCTTAXQSaUC6Ab034dOOBJAJxwJoBOOBNAJR78PfSUcfQT68joL9Wu0rQKegCQCT0gSgScoicAb4DXg2cITgSepasBv2MkPgV+PC/xW+YrGhp0UgWdx/Qz4Zb7AL0sluW4sriLwLK4i8FTBIvDUwSLwVMIa8Ds+XgQeHy8CTy0sAk8tLAJvgP8M+GN9grepBp7kKgJPchWBJ7mKwJNcReBJrp8Bb/MLvFX6eN59rwJPchWBJ7mKwJNcReAN8BrwJFcReJKrCDzJVQSe5CoCT3LVgD9JriLwJFcReJKrCDzJVQTeAK8BT3IVgSe5isCTXEXgSa4i8CRXBfhjmkiuIvAkVxF4kqsIPMlVBB4f/xnw739g/AUeH/8h8Md0gf+G8ALPC89V4HE1IvC4GhF4XI0IvAFeA54+XgQeHy8Cj48XgaePF4Gnj9eALyTXz4D/wv0EvyxWAU9yFYEnuYrAk1xF4A3wGvAkVxF4kqsIPMlVBJ7kKgJPcv0Q+OV1Jtk6/wS/kFxF4EmuIvAkVxF4kqsIvAFeA57k+iHwb09a/QJPchWBJ7mKwJNcReBJrhrwRnIVgSe5isCTXEXgSa4i8AZ4DXiSqwg8yVUEnuQqAk9yFYEnuWrAryRXEXiSqwg8yVUEnuQqAm+A14AnuYrAk1xF4AlQIvAEKA34jQAlAk+AEoEnQInAYyc/Ar6c25NKOfepAh47KQLPRogIPD5eBB4frwG/4+NF4PHxIvD4eBF4NkJE4A3wGvAk189UBtN0Hdz/9X+tgCe5isCTXEXgSa4i8CRXDfiD5CoCT3L9kJ08rhOapqnyVpyD5CoCT3IVgTfAa8CTXEXgSa4i8CRXEXiSqwg8yVUD/iS5isCTXEXgSa4i8CRXEXgDvAY8yVUEnuQqAk9yFYEnuYrAk1wl4OeJ5CoCT3IVgSe5isCTXEXgDfAa8CRXEXiSqwg8yVUDfsbHfwb8cTyfvJzTX78Iqdy8rBfvsu4VlTD9GVQiIWRQiTiRQSVDpQQqEVQyqESqyaASESiDSuz0RVDpepS5nDWV2BZMoFKhe8igEt1DBpXoHjKoRPeQQSVDpQAqve5d/tzuh0p0DxlUonvIoBLdQwaV6B4yqET3kEClhe4hg0p0DxlUonvIoBLdQwaVDJUSqET3kEEluocMKtE9ZFCJ7iGDSnQPCVQyuocMKtE9ZFCJ7iGDSnQPGVQyVEqgEnlJr9J5Pq89z7WiEWkpvkZkpfAarSSl+BqRk+JrREqKrxEZKb5GhkbhNWJvNr5G7MzG14ieIb5G9AzxNaJnCK/RRs8QXyN6hgC7E9M8ve69VFSiacigEl1DBpUMlRKoRN+QQSUahwwq0TlkUInWIYNK9A4JVNppHjKoRPcQQaWyX/e2qaIS3UMGlegeMqhkqJRAJbqHDCrRPWRQie4hmBOvqkT3kCEv0T0kUOmge8igEt1DBpXoHjKoRPeQQSVDpQQq0T1kUInuIYNKdA8ZVKJ7yKAS3UMClU66hwwq0T1kUInuIYNKdA8ZVDJUSqAS3UMGlegeMqhE95BBJbqHDCrRPcRXqUx0DxlUonvIoBLdQwaV6B4yqGSolEAl8pJepaM8n+T49iAvjUhLATSyJ8Fj2yoakZXCazSTlOJrhLeLr5GhUXiN2FOKrxE7SvE1Ih/F14h8FF8j8lF4jQr5KL5G7CPF14hdpPga0TME0OhYnxqdld67GBqF14ieIb5G9AzxNaJniK8RPUN8jegZwmu00DPE14ieIb5G9AzxNaJniK+RoVF4jegZ4mtEzxBfI3qG+BrRM8TXiJ4hvEZGzxBfI3qG+BrRM8TXiJ4hvkaGRuE1omeIrxEZNr5GZNj4GpFhw2u0kmHja0SGja+RodG/1MjOl0br39c/WOKR27Fkz6wdS3JBO5b493Ys8dnNWG744XYs8a3tWLJH0o4lexntWBosm7Ek97RjSe5px5Lc044lueffslzWF0tzr/9W/ZU/V/yzoNsISRrwO4lKBJ74JQJPVhOBJ9iJwBvgNeCJjCLw5EsReMKoCDzJVQSe5KoBf5BcReBJriLwJFcReJKrCLwBXgOe5CoCT3IVgSe5isCTXEXgSa4a8CfJ9TPgbXo+y2zLVAFPchWBJ7l+BvxyLC/wtY8afPxnwG/ra861VMDj40Xg8fEi8Ph4EXh8/IfAn08q8z6fP8AvEz5eBB4fLwKPjxeBZwfqQ+BfXc1epgp4fPxnwB/7dflxrhXwuJqPgC/zPD3vPpflJ/gZVyMCj6sRgcfViMDjakTgDfAa8PTxIvD4eBF4+ngRePp4EXiSqwZ8IbmKwJNcReBJrh8Cvy0X+M0q4EmuIvAGeA14kqsIPMlVBJ7kKgJPchWBJ7lqwC8kVxF4kqsIPMlVBJ7kKgKPj/8IePcrfAs+XgQeHy8Cj4//DPijXF/TPtZKH2/4eBF4fLwIPD5eBB4fLwJvgNeAZwdKBJ7kKgJPchWBJ7mKwJNcNeBXkqsIPMn1Q+CdHxivJFcReJKrCLwBXgOe5CoCT3IVgSe5isCTXEXgSa4a8BvJVQSe5CoCT3IVgSe5isAb4DXgSa4i8Pj4z4Bfr69pz+vx12naPy9ebH7eezErFZUw/QlU2kkIGVQiTmRQieyRQSWCSgaVDJUSqEQEyqASO30ZVGJbMIFKB05cr9JRnk9yfHuQl0b48Pga0eHpNTrP55RnrWflJdjxNeLtwQE0mqfrLNo/f09FJTqHDCoZKiVQic4hg0p0DhlUonPIoBJZKYNKpKX4KhnvJU+hEi1rBpXoHiKotF8Xz6VUVKJ7yKCSoVIClegeMqhE95BBJbqHDCrRPWRQie4hgUoz3UMGlegeMqhE95BBJbqHDCoZKiVQie4hg0p0DxlUonvIoBLdQwaV6B4SqFToHgKoVF68S7GKSnQPGVSie8igEt1DBpUMlRKoRPeQQSW6hwwq0T1kUInuIYNKdA8JVFroHjKoRPeQQSW6hwwq0T1kUMlQKYFKdA8ZVKJ7SKCS4cQjqLS+VFr3iko48QwqGSoFUGkvl0p/bvdDJdxDBpVwDxlUYucig0rsXGRQiZ2LBCqt5KUMKpGXMqjEzkUGldi5yKCSodIvq/QAT53wIfDncc051/6LpyEQgSf0i8CT40XgieYa8BtpWwSeAC0CTyYWgSfmisAb4DXgSa4i8CRXEXiSqwg8yfUz4Lf1NedaaSc3kqsG/E5yFYEnuYrAk1xF4EmuIvAGeA14kqsIPMlVBJ7kKgJPctWAPwhQHwFf5usLTV9/rPwi9CBAicAToETgCVAi8AZ4DXgClAg8AUoEngAlAk+AEoFn608D/iS5isCTXEXgSa4i8CRXEXgDvAY8yVUEnuQqAk9yFYEnuTYA/2BJGG3Fcp3Il+1YEhnbsSQFtmOJzf3Iot/0wN91whNnUAkDnUEl3HYGlfDxCVSaSQgZVCJ7ZFCJVJNBJTbCIqh0PcpczppKhkoJVKJ7yKAS3UMGlegeMqhE95BBJbqHCCq9P4h+LXQPGVSie8igEt1DBpXoHjKoZKiUQCW6hwwq0T1kUInuIYNKdA8ZVKJ7SKDSQveQQSW6hwwq0T1kUInuIYNKhkoJVKJ7yKAS3UMGlegeMqhE95BBJbqHBCoZeUmv0nk+pzzPtaIRaSm+RoZG4TUiKcXXiJwUXyNSUnyNyEjxNSIhhddoZW82vkbszMbXiJ4hvkb0DPE1MjQKrxE9Q3yN6BkC7E5M8/S691JRiaYhg0p0DRlUom1IoNJG35BBJRqHDCrROWRQidYhg0qGSglUonnIoBLdQwSVyn7d26aKSnQPGVSie8igEt1DApV2uocMKtE9ZFCJ7iGYE6+qRPeQIC/thkoJVKJ7yKAS3UMGlegeMqhE95BBJbqHBCoddA8ZVKJ7yKAS3UMGlegeMqhkqJRAJbqHDCrRPWRQie4hg0p0DxlUontIoNJJ95BBJbqHDCrRPWRQie4hg0qGSglUonvIoBLdQwaV6B4yqET3kEEluof4Km0TeUmv0lGeT3J8e5CXRqSlABrZk+CxbRWNDI3Ca0RSiq8R3i6+Rji78BrN7CnF14gdpfgakY/ia0Q+iq+RoVF4jchH8TViHym+RuwixdeIniGARsfz1sdZ6b1neobwGhV6hvga0TPE14ieIb5G9AzxNTI0Cq8RPUN8jegZ4mtEzxBfI3qG+BrRM4TXaKFniK8RPUN8jegZ4mtEzxBfI0Oj8BrRM8TXiJ4hvkb0DPE1omeIrxE9Q3iNjJ4hvkZk2PgakWHja2RoFF4jMmx8jciw8TXqyHvP22rXvff5r6v/b9q1Ixf7L6btyGvMx3E99mmnd/U5X6+BPY/T/fc3z+ViMq/lr+sfLA2WzVh2tHbLWXa0xspZdtTnyll21LvKWfbk0cQst54coJplR99rkrPsqLuVsyT3tGNpsGzGktzzb1mux4vl926jfv2xX/XZca4/S66NkCQCT6ISgSd+icCT1TTgd4KdCDwpUASeyCgCT74UgTfAa8CTXEXgSa4i8CRXEXiSqwg8yVUD/iC5isCTXEXgSa4i8CRXEXgDvAY8yVUEnuQqAk9yFYEnuYrAk1w14E+Sqwg8yVUEnuQqAk9yFYE3wGvAk1xF4EmuIvAkVxF4kqsE/D7h4z8CvszXCSlff7QKeHy8CDw+XgTeAK8Bj48XgcfHi8Dj40Xg8fEi8OxAacDP7ECJwJNcReBJriLwJFcReAO8BjzJVQSe5CoCT3IVgSe5isCTXDXgC8lVBJ7kKgJPchWBJ7mKwBvgNeBJriLwJFcReJKrCDzJVQSe5KoBv5BcReAN8P8OfPl2Fn8p9tf1D5Y4xHYsWQL/Lcv9G8tj+5+uf7BnFZSxNxZCHXtaXB17ilwde7pcHXuDvYw9fl3HnlJXx55eV8eeXKtjT66VsV/JtTr25Fode3Ktjj25VsfeYC9jT67VsSfX6tiTa3XsybUfYV/K+Xzysszztzmf4Am1GvAbifZD4PfpBb5UwGPrPwN+XZ53//rjUQFvgNeAx9CLwOPmReCx8iLw+HgReHy8BvyOjxeBZ1tKBJ49KRF4kqsIvAFeA54AJQJPgBKBJ0BpwB/Yyc+AP45rI+Scpu/gf1682Px8O9FiVinvD7xnBpUwqhlUMlRKoBKbNxlUIqhkUIlUk0ElIlAGldhwSqDSye5UBpUMleQqHcUe1x6l0g/x7vvwGh28uzqARuf1xeez8n7xg9dcJ9CIzzq9RvM0T697LxWV6BwyqETnkEElOocMKtE5JFCJFyCnUImslEEl0lIGlfi+QwaVDJUSqET3EEGl/XrwuZSKSnQPGVSie8igEt1DBpXoHhKoxCusU6hE95BBJbqHDCrRPWRQyVApgUp0DxlUonvIoBLdQwaV6B4yqET3kEAlXkKeQiW6hwwq0T1kUInuIYBK5cW7FKuoZKiUQCW6hwwq0T1kUInuIYNKdA8ZVKJ7SKCS0T1kUInuIYNKdA8ZVKJ7yKCSoVIClegeMqhE95BBJbqHDCrRPWRQie4hgUorTjyCSutLpXWvqGSolEAl3EMElV73Ln9u90Ml3EMGlXAPCVTa2LnIoBI7FxlUYucig0rkpQwqGSolUImdiwwqsXORQSW6hwwq0T1kUInuIYFKO91DBpXoHn5bpQd46gQReBoCEXgDvAY8OV4EnmguAk/aFoEnQIvAk4k14A9irgg8yVUEnuQqAk9yFYHHTn4G/LltF/i9Bh47qQF/srh+CPxxPi5fpqly6tvJ4ioCz+IqAm+A14CnFhaBpxYWgcfHi8Dj40XgqYUl4L9qBMB/Avz+fO59rUAntQqgk1gF0EmrAugG9N+HTkoVQCehCqCTTgXQSaYC6KTS34c+k0gF0AlHAuiEIwF0A/rvQyccCaATjj4CfXmdhfo12lYBT0ASgSckicATlDTgC2FJBJ4tPBF4kqoIPHbyQ+DX4wK/Vb6iUbCTGvALi+tnwC/zBX5ZKsl1YXEVgWdxFYGnChaBN8BrwFMJi8Dj40Xg8fEi8NTCIvDUwhrwRnL9EPhjfYK3qQae5CoCT3IVgSe5isAb4DXgSa6fAW/zC7xV+njefa8CT3IVgSe5isCTXDXgV5KrCDzJVQSe5CoCT3IVgTfAa8CTXEXgSa4i8CRXEXiSqwg8yVUDfiO5isCTXEXgSa4i8CRXEXgDvAY8yVUEnuQqAk9yFYEnuYrAk1w14PeekuuXOX5cXaZlcq4u02HPq0s5XPDz/AI/r+Wv6x8sewqjapY95Us1y54io5qlwbIZy56CnZplT1lNzbKn+KVm2VOiUrPsKSSJWR7knnYsyT3tWJJ7/i3L6wSvrz/vs3f9sT+LkD9flPhZhByEJBF4A7wGPPFLBJ6sJgJPsBOBJwWKwBMZNeBP8qUIPGFUBJ7kKgJPchWBN8BrwJNcReBJriLwJFcReJKrCDzJVQH+nCaSqwg8yVUEnuQqAk9yFYE3wGvAk1xF4EmuIvAkVxF4kqsIPMlVA34muYrAk1xF4EmuIvAkVxF4A7wGPD7+I+DL/HqWebMKeHy8CDw+XgO+4ONF4PHxIvD4eBF4fLwIvAFeA54dKBF4dqBE4EmuIvAkVxF4kqsG/EJyFYEnuYrAk1xF4EmuIvAGeA14kqsIPMlVBJ7kKgJPchWBJ7lqwBvJVQSe5CoCT3IVgSe5isAb4DXgSa4i8CRXDfgVO/kvwZdvR8KXYn9d/2CJQ2zHkiXw37L8T+8ZfH/9gz2roI49C6GOPS2ujj1Fro49Xa6M/Yb/1rHHr+vYU+rq2NPr6tgb7GXsybU69uRaHXtyrY49uVbHnlwrY7+Ta3XsybU69uRaHXtyrY69wf4T7Es5n09elnn+NucTPKFWBJ5E+yHw+/QCXyrgsfWfAb8u+/Pu63L8BH/g6UXgMfQi8Lh5EXisvAi8AV4DHh8vAo+PF4FnW0oEnj0pEXiSqwb8SXIVgSdAicAToETgDfAa8NjJz4A/jmsj5Jym7+B/XrzY/Hw70WJWKe9PvGcGlTCq8VWaJ1xtBpXYvMmgEkElg0qkmgwqGSolUIkNpwwqsTuVQCVeaB9ApaM8n+QoR0UjfHh8jejw9Bqd1xefz8r7xWdecx1fI94PHECjr+Znet17qahE55BBJTqHDCoZKiVQic4hg0p0DhlUIitlUIm0lEElvu+QQCVe2pxCJbqHCCrtF++vnqGiEt1DBpXoHjKoZKiUQCW6hwwq0T1kUInuIYNKdA8ZVKJ7SKASr91OoRLdQwaV6B4yqET3kEElQ6UEKtE9ZFCJ7iGDSnQPGVSie8igEt1DAJXKi3cp9lOlle4hg0p0DxlUonvIoBLdQwaVDJUSqET3kEEluocMKtE9ZFCJ7iGDSnQPCVTa6B4yqET3kEEluocMKtE9ZFDJUCmBSnQPGVTCiUdQaX2ptO4/Vdpx4hlUwj1EUOl17/Lndj9UMlRKoBLuIYNK7FxkUImdiwwqsXORQSXyUgKVDvJSBpXYucigEjsXGVSie8igkqFSApXoHjKoRPeQQSW6h99W6QGeOkEEnoZAA/4k9IvAk+NF4InmIvCkbRF4A7wGPJlYBJ6YKwJPchWBJ7mKwJNcJeC/HhDwHwF/btsFfq+BN8BrwLO4fgj8cT4uX6apVMCzuIrAs7hqwM/UwiLw1MIi8NTCIvD4eBF4A7wGPLWwCDy18EfA78/n3tcKdFKrADqJVQCdtPr70AtJVQCdlCqATkIVQCedCqAb0H8fOqlUAJ1EKoBOOBJAJxz9PvSFcCSATjgSQCccfQT68joL9Wu0rQKegCQCb4DXgCcoicATlkTg2cITgSepasAbdvJD4NfjAr9VvqJh2EkReBbXz4Bf5gv8slSSq7G4isCzuIrAUwVrwK/UwSLwVMIi8Ph4EXh8vAi8AV4DnlpYBJ7k+iHwx/oEb1MNPMlVBJ7kKgJPctWA30iuIvAk18+At/kF3ip9PO++V4EnuYrAG+A14EmuIvAkVxF4kqsIPMlVBJ7kqgG/k1xF4EmuIvAkVxF4kqsIvAFeA57kKgJPchWBJ7mKwJNcReBJrhrwB8lVBJ7kKgJPchWBJ7mKwBvgNeBJriLw+HjND4wPfPyHwB/TBf4bwgs8LzxXgcfViMAb4DXgcTUi8PTxIvD08SLw+HgReHy8BPwy0ceLwNPHi8CTXD/0q79yvShxWawCnuQqAm+A14AnuYrAk1xF4EmuIvAkVxF4kqsG/ExyFYEnuX4I/PI6k2ydK+BJriLwJFcReAO8BjzJVQSe5CoCT3L9EPj3J61+/c+A14AnuWrAF5KrCDzJVQSe5CoCT3IVgTfAa8CTXEXgSa4i8CRXEXiSqwg8yVUDfiG5isCTXEXgSa4i8CRXEXgDvAY8yVUEnuQqAk9yFYEnuWrAGwFKBJ4AJQJPgBKBJ0CJwBvgNeCxkx8BX87tSaWc+1QBj50UgWcjRAN+xceLwOPjReDx8SLw+HgReAO8BjwbISLwbISIwJNcP1MZTNN1cP/X/7UCnuQqAk9y1YDfSK4i8CRXEXiSqwg8yfVDdvK4TmiaplIBb4DXgCe5isCTXEXgSa4i8CRXEXiSqwb8TnIVgSe5isCTXEXgSa4i8AZ4DXiSqwg8yVUEnuQqAk9yFYEnuWrAHyRXEXiSqwg8yVUEnuQqAm+A14AnuYrAk1xF4EmuIvAkVxF4kqsG/ImP/wz443g+eTmnv34RUrl5WS/eZa180fLE9GdQyVApgUrEiQwqkT0yqERQyaASqSaDSkSg+CrZxE5fBJWuR5nLWVOJbcEMKtE9ZFCJ7iGDSoZKCVSie8igEt1DBJVe9y5/bvdDJbqHDCrRPWRQie4hgUoz3UMGlegeMqhE95BBJbqHDCoZKiVQie4hg0p0DxlUonvIoBLdQwaV6B4SqFToHjKoRPeQQSW6hwwq0T1kUMlQKYFKdA8ZVKJ7yKASeUmv0nk+rz3Pny+qtoW0FF8jslJ8jUhK8TUiJ8XXyNAovEZkpPgakZDia8TebHyN2JmNrxE9Q3iNjJ4hvkb0DPE1omeIrxE9Q4DdiWmeXvdeKioZKiVQia4hg0q0DRlUom/IoBKNQwaV6BwSqLTSOmRQid4hg0o0DxlUonuIoFLZr3vbVFHJUCmBSnQPGVSie8igEt1DBpXoHjKoRPcQzInXVNroHhLkpY3uIYNKdA8ZVKJ7yKCSoVIClegeMqhE95BBJbqHDCrRPWRQie4hgUo73UMGlegeMqhE95BBJbqHDCoZKiVQie4hg0p0DxlUonvIoBLdQwaV6B4SqHTQPWRQie4hg0p0DxlUonvIoJKhUgKV6B4yqET3kEEl8pJepaM8n+T49iCXRidpKYBG9iR4bFtFI7JSfI1ISvE1wtvF1whnF18j9pTia8SOUnyNyEfRNVon8lF8jchH8TUiH8XXiH2k+BoZGoXXiJ4hgEbH+tToPCoa0TPE14ieIb5G9AzxNaJnCK/RTM8QXyN6hvga0TPE14ieIb5GhkbhNaJniK8RPUN8jegZ4mtEzxBfI3qG8BoVeob4GtEzxNeIniG+RvQM8TUyNAqvET1DfI3oGeJrRM8QXyMybHiNFjJsfI3IsPE1IsPG14gMG18jvPe/1cjOl0br39c/WOKR27Fkz6wdS3JBM5aGf2/HEp/djiV+uB1LfGs7lgbLZizZy2jHktzTjiW5px1Lck87luSeZixXcs+/ZbmsL5bmXv+t+it/rvhnQbcSkkTgSVQi8MQvEXgDvAY8wU4EnhQoAk9kFIEnX4rAE0Y14DeSqwg8yVUEnuQqAk9yFYE3wGvAk1xF4EmuIvAkVxF4kqsIPMlVA34nuYrAk1xF4EmunwFv0/683JapAp7kKgJvgP8I+OVYXuBrHzX4+M+A39bXnGupgMfHi8Dj4zXgD3y8CDw+/kPgzyeVeZ/PCnh8vAg8Pl4E3gCvAc8O1IfAv7qavVSS64GP/wz4Y78uP871J/gTV/MR8GWep+fd57JUwONqROBxNSLwBngNeFyNCDzfqxGBp48XgcfHi8DTx0vAbxN9vAg8yVUEnuQqAk9yFYE3wH8G/OtZ5s0q4EmuIvAkVxF4kqsIPMlVBJ7kqgE/k1xF4EmuIvAkVxF4kqsIvAFeA57kKgKPj/9/iq/wbTM+XgO+4ONF4PHxnwF/lOtr2sda6eMLPl4EHh8vAm+A14DHx4vAswMlAs8OlAg8yVUEnuSqAb+QXEXgSa4i8CRXEXiS64fAv/+B8bYY4DXgSa4i8CRXEXiSqwg8yVUEnuSqAW8kVxF4kqsIPMlVBJ7kKgJvgNeAJ7mKwJNcReBJrhrwKz7+M+DX61nm9fjrNO2fFy82P++9mJWKSpj+DCqREDKoRJzIoJKhUgKVCCoZVCLVZFCJCJRBJXb6MqjEtmAClTacuF6lozyf5Pj2IC+NDI2ia8SbrQNodJ7PKc9az8pLsBNoxGedXqN5us6i/fP3VFSic8igEp1DBpXoHDKoROeQQSU6hwQq8fbwFCqRljKoxPcdMqhEy5pBJUOlACrt18VzqexY8Hr0FCrRPWRQie4hg0p0DxlUontIoNJJ95BBJbqHDCrRPWRQie4hg0qGSglUonvIoBLdQwaV6B4yqET3kEEluof4Ku0T3UMGlegeMqhE9xBApfLiXYpVVKJ7yKCSoVIClegeMqhE95BBJbqHDCrRPWRQie4hgUoz3UMGlegeMqhE95BBJbqHDCoZKiVQie4hg0p0DxlUonvIoBLdQwKVCk48gkrrS6V1r6iEE8+gEu4hgkp7uVT6c7sfKuEeMqiEe8igEjsXCVRa2LnIoBI7FxlUIi9lUIm8lEElQ6UEKrFzkUEluoffVukBnjrhQ+DP45pzrv0XT0MgAk/o14A3crwIPNFcBJ60LQJPgBaBN8BrwBNzReBJriLwJFcReJKrCDzJVQN+Jbl+Bvy2vuZcK+3kSnIVgSe5isCTXEXgDfAa8CRXEXiSqwg8yVUEnuQqAk9y1YDfSK4i8ASoj4Av8+tZ5q3yi9CNACUCb4DXgCdAicAToETgCVAi8AQoEXgClAb8ToASgWfrTwSe5CoCT3IVgTfAa8CTXEXgSa4i8CRXEXiSqwg8yVUD/iC5NgD/YEkYbceSfNmOJZGxHUuDZTOW2NzPfO2k6YG/B544g0oY6AQqnbjtDCrh4zOoRELIoBLZI4NKhkoJVGIjLIJK16PM5aypxK5ZBpXoHjKoRPeQQSW6h/gqHRPdQwaV6B4iqPT+IPpjonvIoBLdQwaVDJUSqET3kEEluocMKtE9ZFCJ7iGDSnQPCVSa6R4yqET3kEEluocMKtE9ZFDJUCmBSnQPGVSie8igEt1DBpXoHjKoRPeQQKVC95BBJbqHDCoZKslVOs/nlOe5VjQiLcXXiKwUXyOSUnyNyEnxNSIlhddoISPF14iEFF8j9mbja8TObHyNDI3Ca0TPEF8jeob4GtEzxNeIniHA7sQ0T697LxWVaBoSqGR0DRlUom3IoBJ9QwaVaBwyqGSolEAlWocMKtE7ZFCJ5iGDSnQPEVQq+3Vvmyoq0T0kUGmle8igEt1DBpXoHjKoRPeQQSVDpVhOvKoS3UOCvLTSPWRQie4hg0p0DxlUontIoNJG95BBJbqHDCrRPWRQie4hg0qGSglUonvIoBLdQwaV6B4yqET3kEEluocEKu10DxlUonvIoBLdQwaV6B4yqGSolEAluocMKtE9ZFCJ7iGDSnQPGVSie0ig0kH3kEEluocMKhkqyVU6yvNJjm8P8tKItBRAI3sS/NqTrWhEVoqvEUkpvEYn3i6+Rji7+BqxpxRfI3aU4mtkaBReI/JRfI3IR/E1Ih/F14h9pPgasYsUXaNzomcIoNHxvPXX51pFI3qG+BrRM8TXiJ4hvkaGRuE1omeIrxE9Q3yN6Bnia0TPEF8jeobwGs30DPE1omeIrxE9Q3yN6Bnia2RoFF4jeob4GtEzxNeIniG+RvQM8TWiZwivUaFniK8RPUN8jegZ4mtkaBReIzJsfI3IsPE1IsPG14gMG16jpSfvfRzXY592uorO16tCz+P0NdrLS6Njc65fyno8Ll/KVirgezLUocAf0wX+G8IX+J4cWCrwPdmqVOB78kqpwPdkgFKB76mZzwTeeqrbU4HHx4vA4+NF4Hv6Vl0q8AZ4DXiS62fAf+F+gl8Wq4AnuYrAk1xF4EmuIvAkVw34leQqAk9yFYEnuYrAk1xF4A3wnwG/XJvdyzpXwJNcReBJriLwJFcReJKrCDzJVQN+I7l+CPz8Ar+sFfAkVxF4kqsIPMn1/8veuyU2jmRLtnPpEQCOjdd87jR67ldRJYKKkjt3RAeo/VrnKz94lLRllYSZgXQYgRfA24CnuRqBp7kagae5GoGnuRqBp7nagN9prkbgaa5G4GmuRuBprkbgBfA24GmuRuBprkbgaa5G4GmuRuBprjbgD5qrEXiaqxF4CpQReAG8DXgKlBF4CpQReAqUDfiTOPkW8O3cHlTax92mDnjipBF4boQYgSfHG4EXwNuAJ8cbgSfHG4EnxxuB50aIEXhuhBiAb9PH/wH+LZPBND3O7V8+/l874GmuRuBprkbgaa5G4AXwNuBprkbgaa5vipPHdULTx4W0A57magSe5moEnuZqA36muRqBp7kagae5GoGnuRqBF8DbgKe5GoGnuRqBp7kagae5GoGnudqAbzRXI/A0VyPwNFcj8DRXI/ACeBvwNFcj8DRXI/A0VyPwNFcj8DRXG/ALzdUIPM3VCDzN1Qg8Of494I/j8c7bOf32i5DOH2/r9cbb2vmi5ULoj+ASDSGCS9SJCC7RPQK4JBSVCC7RaiK4RAWK4BJ3+jy4dMjl0tlzSXApgEtsDxFcYnuI4BLbQwSX2B4iuMT24MGl599uv/7c/7q0sj1EcIntIYJLbA8RXGJ7iOCS4FIAl9geIrjE9hDBJbaHCC6xPURwie0hgEsb20MEl9geIrjE9hDBJbaHCC4JLgVwie0hgktsDxFcYnuI4BLbQwSX2B4CuLTTl+xdOs/Ha89z7XhEW/LvkeCRe49oSv49oif594iW5N8jOpJ/j2hI7j06uDfr3yPuzPr3iJ3Bv0fsDP49Ejxy7xE7g3+P2BnsPZqneXr+7aXjEktDBJfYGiK4xNoQwKWTvSGCSywOEVxic4jgEqtDBJcElwK4xPIQwSW2Bw8uteutTDJ1XGJ7iOAS20MEl9ge/Ls0T2wPEVxie4jgEtuDsyTedYntwZlLnb70YR0uBXCJ7SGCS2wPEVxie4jgEttDBJfYHgK4NLM9RHCJ7SGCS2wPEVxie4jgkuBSAJfYHiK4xPYQwSW2hwgusT1EcIntIYBLje0hgktsDxFcYnuI4BLbQwSXBJcCuMT2EMEltocILrE9RHCJ7SGCS2wPAVxa6Ev2Lh1NPl97tKPjEW3JgUfyIHhsW8cjwSP3HtGU/HtEtvPvEcnOvUfCPSX/HnFHyb9H9CP/HtGP/HskeOTeI/qRf4+4j+TfI+4i+feIncGBR8f68Ojs7N7CzuDeo5Wdwb9H7Az+PWJn8O8RO4N/jwSP3HvEzuDfI3YG/x6xM/j3iJ3Bv0fsDO492tgZ/HvEzuDfI3YG/x6xM/j3SPDIvUfsDP49Ymfw7xE7g3+P2Bn8e8TO4N6jnZ3Bv0d0WP8e0WH9eyR45N4jOqx/j+iw/j0ie/+pR3I+PVqP317/X5YHGfk+ltwzu48lveA+luT3+1gKLG9jSR6+jyW59T6W3CO5jyX3Mu5jSe+5jeVJ77mPJb3nPpb0nvtY0nv+lOWyPlnKob3+y/TXfr3ifwe6UwBvA55GZQSe+mUEnq5mBJ5iZwSeFmgCvk1URiPw9Esj8JRRI/A0VyPwAngb8DRXI/A0VyPwNFcj8DRXI/A0VxvwM83VCDzN1Qg8zdUIPM3VCLwA3gY8zfU94GW6/rosUwc8zdUIPM31PeCX53uRpfNR08jx7wG/rU+da+uAJ8cbgSfHG4EnxxuBF8C/B/z5oDLv89kBT443Ak+ONwJPjjcCzx2oN4F/bjV76zTXhRz/HvDHfr38ONcOeAH8O8B/3GGaPl/+cc9j6YAn1RiBJ9UYgSfVGIEn1RiB53s1NuCFPd4IPDneCDx7vBF49ngj8AJ4G/A0VyPwNFcj8DTXN4Hflgv8Jh3wNFcj8DRXG/ArzdUIPM3VCDzN1Qg8zdUIvADeBjzN1Qg8zdUIPM3VCDzN1Qb8Ro5/C3j1K3wbOd4IPDneCLwA/j1fWm3X17SPtbPHb+R4I/DkeCPw5Hgj8OR4I/DcgbIBv3MHygg8zdUIPM3VCDzN1Qi8AN4GPM3VCDzN9U3glR8Y7zRXI/A0VyPwNFcb8AfN1Qg8zdUIPM3VCDzN1Qi8AN4GPM3VCDzN1Qg8zdUIPM3VCDzN1Qb8SXM1Ak+Ofw/49fqa9rwev52m/f3Fi8yPv72IdI7ePgWXArhEQ4jgEnUigkt0jwguUVQiuESr8e/SMlGBIrjEnb4ILnFbMIJLJHF7l44mn6892tHxiBzu3iOebO3Ao/N8qDw7O+vCQ7ADeMRnnb1H83SdRfvr39Nxic0hgktsDgFc4rHdIVxic4jgEptDBJfoShFcElwK4BLfd4jgEitrBJfYHjy4tF8vnlvnjgWPRw/hEttDAJcWtocILrE9RHCJ7SGCS2wPEVwSXArgEttDBJfYHiK4xPYQwSW2hwgusT0EcEnYHiK4xPYQwSW2hwgusT1EcElwKYBLbA8OXGpP3q1JxyW2hwgusT1EcIntIYJLbA8BXFrZHiK4xPYQwSW2hwgusT1EcElwKYBLbA8RXGJ7iOAS20MEl9geIrjE9hDApY3tIYJLbA8RXCKJe3Bpfbq07h2XSOIRXCI9eHBpb5dLv/7c/7q0kx4iuER6iOASdy4iuMSdiwguCS4FcIm+FMEl+lIEl7hzEcEl7lxEcInt4add+i/4gznhTeDP49I5d/4Xf7AQGIGn9BuBp8cbgRfA24CnbRuBp0AbgacTG4Gn5hqBp7nagD9prkbgaa5G4GmuRuBpru8Bv61PnWtnnTwF8Dbgaa5G4GmuRuBprkbgaa5G4GmuJuBlorkagae5GoGnuRqBp7kagadAvQV8m68vNH38o3TAU6CMwFOgjMBToIzAU6BswM8UKCPwFCgj8BQoI/AUKCPwAngb8DRXI/A0VyPwNFcj8DRXI/A0VxvwjeZqBJ7magSe5moEnuZ6A/hPlgLL21jSL+9jSWW8jyUt8DaWCzH3LRf9Ww/8lYVMHMElAnQEl0jbEVwSXArgEg0hgkt0jwgu0WoiuMSNMA8uHXK5dPZc4q5ZAJeE7SGCS2wPEVxie4jgEttDBJcElxy49PogehG2hwgusT1EcIntIYJLbA8RXGJ7CODSyvYQwSW2hwgusT1EcIntIYJLgksBXGJ7iOAS20MEl9geIrjE9hDBJbaHAC5tbA8RXGJ7iOAS20MEl9geIrgkuBTAJfqSvUvn+VB5nmvHI9qSf4/oSu492mlK/j2iJ/n3iJbk3yM6kn+PBI/ce8S9Wf8ecWfWv0fsDP49Ymfw7xE7g3uPDnYG/x6xM9h7NE/z9PzbS8clloYILrE1RHBJcCmAS+wNEVxicYjgEptDBJdYHSK4xO4QwKWT5SGCS2wPHlxq11uZZOq4xPYQwSW2hwguCS4FcIntIYJLbA8RXGJ7cJbEuy6xPThzqduX2B78u7RObA8RXGJ7iOAS20MEl9geIrgkuBTAJbaHCC6xPURwie0hgktsDxFcYnsI4NLM9hDBJbaHCC6xPURwie0hgkuCSwFcYnuI4BLbQwSX2B4iuMT2EMEltocALjW2hwgusT1EcIntIYJLbA8RXBJcCuASfcnepaPJ52uPdnQ8oi058EgeBI9t63hEV3Lv0UJT8u8R2c6/R4JH7j3inpJ/j7ij5N8j+pF/j+hH/j2iH7n3SOhH/j3iPpJ/j7iL5N8jdgYHHh2PP32cnd1bBI/ce8TO4N8jdgb/HrEz+PeIncG/R+wM7j1a2Rn8e8TO4N8jdgb/HrEz+PdI8Mi9R+wM/j1iZ/DvETuDf4/YGfx7xM7g3qONncG/R+wM/j1iZ/DvETuDf48Ej9x7xM7g3yM6rH+P6LD+PaLDuvdop8P694gO69+jH78erefl0bErHn382y8w8/p8UOS+d99I+3ztPn9B3v3Dsj7+7jrPv732E8sJlg6WYwJLD8sMlh6WBpYelgUsPSwClh6WtSSW9QpQH7d9ldd+/JvlehPbM8m143hA3ID47xB3IP47xJp5+2aINdP5vRDPmln+Zog1k//NEH+8J5zXOrOfswpxntv1Tua1/bbOfCpYwiuQ8ArW8Aq28Ar28AqO8ArO4Aq2aQqvYA6vIPo1eZuiX5O3yfs1eT2eCvb5NwW9O2j7FUaPc/3y1x9yvV/Ab5br/Wp/s1zv0eBmud5zxM1yvYeOe+XO3hPKzXK9x5mb5XrPPjfL9R6UbpYrteTWSlVzrVQ110pVc61UNddKVa1Wqmq1UlWrlaparVT180+1tJVbK1W1Wqmq1UpVrVaqarVS1VIrVS21UtVSK1UttVLVzz9R0lZurVS11EpVS61UJamuu22+fnP68Y/SkZvquqvLTXXd1eWmuu7qclNdd3W5qa67utxU111dbqrrri431Zqhy021Zqhy11qpaq2VqtZaqWqtlap+/nkStnJrpaq1Vqpaa6WqtVaqWmulqq1WqtpqpaqtVqraaqWqnz8921ZurVS11UpVW61UtdVKVVutVLU7vxC1L79Abk1+k/upwPm15Q8UOP9AafsXBcem/E/u9es/FTv/THmDYucfK/crPpz3tTcodl7Z3qDYeWt7g2Lv18v7FXu/vt6v2Hl9e4Ni5w3uDYrLZa6jXOY6ymWus1zmOstlLu8nkb5BcbnM5f2k0zcoLpe5vJ+k+gbFqTJXa+fj2Vxtmb/+9YfcVIFLl5sqbbW2T0+57Zvc3fvho38pd10ef/3jH4+O3FTXYF1uqguwLjfV1VeXm+rSq8vNdd1V5ea67qpyc113NbnejzW9W26qfUOXWytVeT/W9G65tWKG93M+75ZbK2Z4PwnyL+Uex1Xvz2n6Kvf7ixeZH+dKLCKdcuz92EhTNrkucfeyyXU9vJeNwGbIJlewuJdNrhRyL5tckeVeNrlmlHvZ5NpcbmXj/fjDN7I52uMpskfrNAbvJyXakfF+Dt0byZzXbdWzc0Lf7v3IOkMydf9rmqd5ev7tpcOmbh7W2dTNwzqbunlYZ1M3D+ts6uZhlY330+BM2dRNNzqbujuxzqZux9TZSGE2+6Vybp1twvtxd6ZsKudijU3lXKyxqZyLNTaVc7HCxvt5fqZsKudijU3lXKyxqZyLNTYCmyEbcvGYDbl4zIZcPGZDLh6zIRcP2ezk4jEbcvGYTeFc3J4qvx6x+WRTOBerbAQ2QzaFc7HKpnAuVtkUzsUqm8K5WGVTOBdrbHKdJ3wzm8K5WGVDLh6zIReP2QhshmzIxWM25OIxG3LxmA25eMgm15m3f8lmfbJZ9w6bytdwjU3lz+Ln327H3GFT+bNYY1P5s1hjU3mjeM3mmCpvFBqbyhuFxqZyvtHYVM43GhuBzZBN5Y1CY0MuHrMhF4/ZkIvHbMjFQzbJDm0es/mUWyXqfsqtkl4/5VYJpJ9ypZbcKrHxU26VJPgpt0q4+5RbJa99yq0Swf4rt8wJ5J9ya6WqMueEf8rNdSE6t+2Su/fk5roQaXKXXB9V53F+vnyZptaRm+ujSpWb66NKlZurAKpypZbcXAVQlZvsuqvJTXbd1eTmKoCq3FQFcH8k5v378ddHriPTX0tNlaZeS02VpF5LTZWiXkuVOlJTpafXUlMlp9dSU6Wm11JTJabXUuukpVwHjb+WWidC5DoG/LVUqSM1VYRYnr9t+/iDW0duqhihy00VJXS5qeKELjdVpFDl5jrDWpebKkXpcpNdiNbjkrt1xtNcB93qcnN9VC3zJXdZOqkq17GiutxcH1Wq3FSlT5ebqvjpcqWW3FzXXVVuruuuKjdXAVTl5iqAqtxkqep4Pux+6sjNdSilLjdZqtLkJktVmtxkqUqTK6nkyvyUK52+m+vMRl1urlSlys2VqlS5uVKVKjdXqtLknrlSlSo3V6pS5eZKVarcXKlKlSu15NZKVbkOVNXl1kpVuY491eWWSlVnrsNJdbmlUtWZ6whRXW6pVHVOUktuqVR15jqOU5dbKlWduQ7NVOW2ZF8Bff01sjPXySZLO6ZL7pc3/pSb67qrys113VXlJvvGqyY32TdeNbnJfnqhyU320wtNbrLrriI31/kXutxkP73Q5OZaM1S5yb55065jepZFOnKlltxk32fW5Cb7PrMmN9n3mTW5yb7PrMlN9n1mRe6a7PvMmtxk32fW5Cb7PvPy/C3COnfkJktVmlypJTdZqtLkJktVmtxkqUqTW+pXYmeyY0I0ucmOCVHllvrt/bmV+u39uZX67f25SS25pX57fyY780aVW+q39+dWK1XVOtHorHWi0VnrRKOz1olGZ60Tjc5aJxqdtU40OmudaHTWOtHorHWi0ZntRCNFbrYjfjS5tWJGtiN+NLlSS26tmJHrEBjtGbpnrkNgVLm5DoHR5SZ7ZLAmN9kjgzW5yR4ZrMlNdd3V5SZ7ZLAmN9kjgzW5yR4ZrMnNVe+n6fq58sf/a0durnr/Wu48JTsERpWba81Q5eZaM1S5udYMVa7kuhC9fJj7h9xkqUqTmyxVaXKTpSpNbrKtSpObbKtS5M7JtipNbrKtSpObbKvS5CbbqjS5UkturVQ110pVc61UNddKVXOtVNVqpapWK1W1Wqmq1UpVTWrJrZWqWq1U1WqlqlYrVeU6sFiVm+vAYl1uruvuccyfL2/n9Nvd+84fb+ulsq2dG0q5Tje+mU2uK/q9bHJd/u9lkysr3MsmV7C4l02uFHIrm1xnPd/MJtdq9HdsDrnYnD02uSame9lUzsUaG4HNkE3lXKyxqZyLNTaVc/Hzb7dj7rCpnIs1NpVzscIm12ndN7OpnIs1NpVzscamci7W2Ahshmwq52KNTeVcrLEhF4/ZkIvHbMjFQza5zlu/mQ25eMyGXDxmQy4esxHYDNmQi8dsyMVjNuTiIZtcJ5//FZvzfLz2PNcOmbrpRiNTN9toZOomG42MQGZApm6q0cjUzTQambqJRiNTd+fTyNRd+RQyBxl4RIYMPCJDBh6RIQOPyEjdHWKap+ffXjpsCm97KpvC257KpvC2p7IpfM9bZVP4nrfGJtnjMu5lU/iet8qm8D1vlU3he94qGynMpl1vZZKpw6ZyLtbYVM7FGpvKuVhjUzkXa2wq5+LXbOZcDzz5f7+Gd9mQi0f5Zs71KJWb2ZCLx2wENkM27MVjNuzFYzbsxWM27MVjNuzFQzbJHllzLxty8ZgNuXjMhlw8ZiOwGbIhF4/ZkIvHbMjFYzbk4jEbcvGQTbKHDt3Lhlw8ZkMuHrMhF4/ZCGyGbMjFYzbk4jEbcvGQTbLH//wNm6M9jig+2tEhUzfdHPJ438e2dcjUzTYambrJRiNT9/qkkal7ddLI1N1sNDJ1FxuFTOFnA2lkyDMjMuSZERnyzIiMQGZApu5Ko5EpnIGP9UHm7HTtwk8D0sgUzsAKmcIZ+DWZws8B0sgUzsAKmcIZWCFTOAMrZAQyAzKFM7BChgw8IkMGHpEhA4/IkIEHZAo/80cjQwYekSEDj8iQgUdkBDIDMmTgERky8IgMGXhEhgw8IFP46UcaGZLeiAxJb0SGpDciI5AZkPF+1ZbzSWY9fiPzqcD71VVX4H0JUhW4f4KLrsD79VZX4P26qCvwfv3SFXi/zugKvDd/XYH3hq4rCH9Ndv/kC11B+Guy+6dI6Aq8X5OX9alAflfQeb3yKOjZ/eMbbpbr/Wp/s1ypJdd7jrhZrvfQcbNc7wnlZrne48zNcr1nn1vlNvePFbhZbqlU1dwf/n+z3FKpqk1SS26pVNXcH6R/s9xSqaq5P+7+Zrm1UpX7Q+lvllsrVbk/Ov5mublSlUzXX5dl6siVWnJzparlWJ5ye/9jznXd3dbHl2E+/rF15Oa67mpy3R96fbPcXNddVW6u6+52btdfn8+O3FzXXVVuruuuKjfXdVeVm2vN2J6ZeW+dVNVyXXeP/Xr5ca7f5bo/WPev5P564t7ny39p68hN9cmsy031yazLTfXJrMtN9cmsy021M+tyU/VdXW6q664q1/2hwTfLTdV3dbm1UpX7M3tvliu15CZLVdtyyd2kIzdZqtLkJktVmtxkqUqTmyxVKXLdH0N7s9xkqUqTmyxVaXKTpSpNrtSSWytVuT+E9Wa5ye7eKzdN3B99ebPcZHfvNbm57t4f7brheaydvuv+5Mmb5aa67upyc929V+Xmunuvys31WwRVbq7vRKpyk303Q5Hr/pjJm+XmSlWq3Fqpyv0pjzfLlVJfI9uTpSpNbrJUpclNlqo0uclSlSa31jde3R/6ebPcZKlKk5ssVWlyk6UqTa7UklsrVbk/AvVmubVSlfvDVe+Vm+wU0PW64Tmvx2+/8Pz+4kXmx99eRDo/B012ZOi9bHJd0e9lI7AZssmVFe5lkytY3MsmVwq5l02uyHIvm1yr0Z1slmRHs97Lpu41/Gjy+dqjHR0yda/gCplkp9T9DZnzfJysc3Za5pLsQLs7ydT9r2merl/0/fr3dNjUzcM6m7p5WGdTNw/rbOrmYZVNssP97mVTN9vobOqmG51N3Z1YZyOwGbKpnIv368Vz62wTyY46vJdN5VyssamcizU2lXOxwmapnIs1NpVzscamci7W2FTOxRobgc2QDbl4zIZcPGZDLh6zIReP2ZCLh2xyHY57Mxty8ZgNuXjMpnAubk+VrUmHjcBmyKZwLlbZFM7FKpvCuVhlUzgXq2wK52KNTa7jjW9mUzgXq2wK52KVDbl4zEZgM2RDLh6zIReP2ZCLx2zIxWM25OIhm2QnNv8dm/XJZt07bCpfwzU2lT+Ln4e+t2PusKn8WayxqfxZrLBJdmjxvWwqbxQam8obhcamcr7R2AhshmwqbxQam8obhcamSi7+lJss6p7H4+Xb3HM3WXpV5CY771mVmyxjanKTxUZNbrIkqMmVWnKT5TVNbrIIpslNlqo0ubVS1VErVZ21UlWy07y3db7krp1GlOyAblVurlSlypVacnOlKlVurlSlys2VqlS5uVKVKjdXqlLkSrKDo1W5pVKVTKliRpuvWf3jH6UjV2rJTRUzdLmpYoYuN1XM0OWmihm63FQxQ5U7p4oZutxUMUOXm2q80eXWSlWz1JJbK1XlejKDLrdWqsr1/ARdbq1UlespB7rcwKnqU0HgoPSpIHD2+VQg4RUETiifCir/1Ov1TwSl8vHlGpvKx5erbCr/1EtjU/mnXhobfso+ZiOwGbKp/FMvjU3ln3odcrE5e2wqH4GgsamcizU2lXOxwqby8eUqm8q5WGPDEQj/YdP5SbKUPr5cYyOwGbLhCIQxG45AGLPhaLAxG44GG7PhaLAhm9LHl2tsOBpszIZcPGZDLh6zEdgM2ZCLx2zIxWM25OIxG3LxmA25eMhmIxeP2ZCLx2zIxWM2dfPNeT5+hnyea4dM3XSjkambbTQydZONRqZurlHIFH4QgEambqbRyNRNNBqZujufRkYgMyBDBh6RIQOPyJCBR2TIwCMyhbe9aZ6ef3v5zibb0wduZVN421PZFN72VDaF73mrbAQ2QzaF73mrbArf81bZFL7nrbIpfM9bZVM5F7frrUwyfWeT7fkRt7KpnIs1NpVzscamci7W2Ahs/s+IDbl4zIZcPMw3yR69cS8bcvGYDXvxiM2a7Akg97JhLx6zYS8es2EvHrMR2AzZkIvHbMjFYzbk4jEbcvGYDbl4yCbXI2tuZkMuHrMhF4/ZkIvHbAQ2Qzbk4jEbcvGYDbl4zIZcPGZDLh6yyfXQoZvZkIvHbMjFYzZ1883RHkcUH+3okKmbbg55vO9j2zpk6mYbjUzdZKOQKfyMII1M3auTRqbuZqOREcgMyBTOMwoZ8syIDHlmRIY8MyJTd6dRyBR+IpBGpnAGPh5/+jg7Xbvw04A0MoUzsEJGIDMgUzgDK2QKZ2CFTOEMrJApnIEVMoUz8GsyhZ/+o5EhA4/IkIFHZMjAIzICmQEZMvCIDBl4RIYMPCJDBh6RIQMPyBR+0o9Ghgw8IkMGHpEhA4/IkPRGZEh6IzIkvREZkt6IDElvQObnn2QzPc7on7dlU8is+/x49+u+rtrfns7rC/Nzm5RXt3k/Pl/dWtM8kml+vG+Z1qfKtndevK8P9/cvz/zrK2wPeOuXL7J/vPTTngV7TO2Rx0s/FoaOPYI9nu1ZscezPRv2eLZnxx7P9hzY49meE3sc2/Pzz7vCnr+xZ8Yez/awGri2h9XAiz1ffkvytEewx7M9rAbG9lyT6N6zh9XA1p7lfGkPq4Fre1gNXNvDamBqzzY9SG/T+d2ek9XAtT2sBq7tYTVwbQ+rgWt7BHtMk9v5ELjNU8ceVgPX9rAauLaH1cC1PawGru1hNXBszzaxGri2h9XAtT2sBq7tYTVwY8/ZsUewx7M9rAbG9jyeI7K1nj2sBrb2HNtLe1gNXNvDauDaHlYD2/s911dBtrV9t2dmNXBtD6uBa3tYDVzbw2rg2h7BHs/2sBq4tofVwLU9hXvP/HjfH3eNJ6ta+vLIo60V7j0u7Hn529KtFe49Eewp3Hsi2FO490SwR7DHsz2Fe08Eewr3ngj2FL5bGsGewndLI9jDauDZnoXVwIs9nTN1toXVwLU9rAbG9rw68mhbWA1s7Xl5aMu2CPZ4tofVwLU9rAam9rw+dmJbWA1c28Nq4NoeVgPP9girgWt7WA1sk9vrn/4Kq4Fre1gNXNsj2OPZHlYD1/awGri2h9XAtT2sBq7tYTXwbM/KauDGns5qsLIauLaH1cDYnpdHHq2sBrb2vD60ZRXs8WwPq4Fre1gNbO/3vP5l9spq4NoeVgPX9rAaeLZnYzVwbQ+rgWt7WA1c28Nq4Nqeur1nkutEquloVrX09ZFHW93e48Oe178t3er2nhD21O09EezZ6/aeEPbU7T0h7Knbe0LYU7f3hLBHsMezPXXvloawh9XAtT2sBl7s6Z2ps7MauLaH1cDYnpdHHh2sBrb2vD605WA1cG0Pq4Fre1gNTO1Rjp04BHs828Nq4NoeVgPX9rAauLaH1cA2ub3+6e/BauDZnpPVwLU9rAau7WE1cG0Pq4FrewR7PNvDauDaHlYD1/awGrixp7ManKwGru1hNTC259WRR/vEamBrz8tDW/aJ1cC1PawGru1hNbC93/Pyl9n7JNjj2R5WA9f2sBq4tofVwLU9rAau7WE18GzPzGrg2p6yvWc+9/myZxarWvryyKN9Fuwxteflb0s/5GOPZ3vK9p4Y9pTtPTHsKdt7YthTtveEsKeV7T0x7Cl7tzSGPWXvlsawh9XAtT2CPU7s6ZypszdWA9f2sBoY2/PqyKO9sRrY2vPy0Ja9sRq4tofVwLM9C6uBqT2vj53YF1YD1/awGri2h9XAtT2CPZ7tYTWwTW4vf/q7L6wGru1hNXBtD6uBa3tYDTzbI6wGru1hNXBtD6uBa3tYDVzbI9jjxZ7OaiCsBq7tYTUwtuflkUfCamBrz+tDW4TVwLU9rAae7VlZDWzv97z+ZfbKauDaHlYD1/awGri2R7DHsz2sBq7tYTVwbQ+rgWd7tn/vPbJfs9EqmwKlTcfj1a19OeRnPvrA296ud9KOTXn90tbHKVNL276eMvWQO+eSe0yX3C9v/ClXaslda8ndasnda8k9ask9S8ndk113Nbm1rrt7qyV3qSVXUsn9EPmQuyzSkZsrValyc6UqVW6uVKXKzZWqVLm5UpUm98iVqlS5uVKVKjdXqlLl5kpVy3JNc8s6d+RKLbnJUpUmN1mq0uQmS1Wa3GSpSpObLFXNT7nL+l3umSxVaXKTpSpNbrJUpclNlqo0uVJLbrJUpclNlqo0uclSlSY3WarS5JZKVcdUKlUdU6lUdUylUtUxlUpVxyS15JZKVcdUKlUdU6lUdUylUtUx1UpVc61UNdeKGXOtmHHDA29Dya0VM+ZaMWNOdSFq5/b4UVI79+m73JbqQqTLTVXvdbmprru63FTXXV1uquuuLjfVdVeXm+q6q8tNVe91uanqvS43V72fpsfPsZep7d/lLrnqvSo3100TVW6uNUOVm2vNUOVKLbnJUtVxfVt9mlpHbrJUpclNlqo0uclSlSY32ValyJVkW5UmN9lWpclNtlVpcpNtVZpcqSW3VqqSWqlKaqUqqZWqpFaqWmulqrVWqlprpaq1Vqq64UjmUHJrpaq1Vqpaa6WqtVaqWmulqlwHFutya6WqXAcWt+O4TgA/p9/u3nf+eFsvlW3t3FDKdbrxzWxyXdHvZZPr8n8vm1xZ4V42uYLFrWxyHd98M5tckeVeNrlWo79jc72VuZ09NrkmpnvZCGyGbCrnYo1N5VyssamcizU2lXPx82+3X3/uG5vKuVhhk+sA7pvZVM7FGpvKuVhjUzkXa2wENkM2lXOxxqZyLtbYVM7FGhty8ZgNuXjIJtcR6jezIReP2ZCLx2zIxWM2ApshG3LxmA25eMyGXDxmQy4esTlznXz+V2zO8/Ha81w7ZOqmG41M3WyjkRHIDMjUzTUambqpRiNTN9NoZOomGo1M3Z1PIZPr8PlbyZCBR2TIwCMyZOARGYHMgEzhbW+ap+ffXjpsCm97KpvC257KpvC2p7IpfM9bY5PsCRj3sil8z1tlU/iet8qm8D1vlY3AZsimci5u+/W3ZeqwqZyLNTaVc7HGpnIu1thUzsUKm1zPMLmZDbl4zIZcPMw3uR6lcjMbgc2QDXvxmA178ZgNe/GYDXvxmA178ZBNsqfQ3MuGXDxmQy4esyEXj9kIbIZsyMVjNuTiMRty8ZgNuXjMhlw8ZJPsOUL3siEXj9mQi8dsyMVjNgKbIRty8ZgNuXjMhlw8ZkMuHrJJ9vifv2FztMc7Ob68kSeZuunmkO1BZts6ZOpmG42MQGZApu71SSNT9+qkkam72ShkCj8dSCNTOM8oZMgzIzLkmREZgcyATN2dRiNTd6XRyBTOwMf6IHN2unbhpwFpZApn4NdkCj8JSCNTOAMrZApnYIVM4QyskBHIDMgUzsAKmcIZWCFDBh6RIQOPyJCBB2QKP/VHI0MGHpEhA4/IkIFHZAQyAzJk4BEZMvCIDBl4RIYMPCJDBu6SaVPhpx9pZEh6IzIkvREZgcyADElvRMb7VVvOJ5n199d/KvB+dVUVuH8yjK7A+3VcV+D9eqsr8H5d1BV4v37pCrxfZ3QF3pu/rsB7Q9cVhL8mu3/yharA/fMpdAXhr8nun/WwrE8For7+9aOgP+R6v4DfLNf71f5mud6jwc1yveeIm+V6Dx03y/WeUG6W6z3O3CvX/TMIbpbrPSjdLLdWqnJ/+P/NcqWW3Fqpyv2p+zfLrZWq3J+Nf7PcWqnK/Qn2N8utlarcnzN/s9xaqcr9afB/J1em60FrskwdublSlSo3V6pajuUpt/c/5lzX3W19fBnm4x/bd7nuT8i+WW6u664qN9d1V5Wb67q7nY9DV+Z9Pjtyc113Vbm5rruq3FzXXVVurjVje2bmvXVS1Zbrunvs18uPc+3ITfXJ3Obr7Ok2fz97+kNuqk9mXW6qT2ZdbqpPZl1uqk9mXW6qnVmXm6rvqnLdny98s9xUfVeXm6rv6nJrpSr3Z/beLLdWqnJ/uu5fyt2WS+6vd/tNbrJUpclNlqo0uclSlSLX/Ym1N8tNlqo0uclSlSY3WarS5EotuclSlSa3VqpyfwjrvXLdn5J5700T90df3iw32d17TW6uu/dHu254Hmun77o/efJmubnu3qtyc929V+Xmunuvys31WwRVbq7vRCpy5ynZdzM0ublSlSo3V6pS5ZZKVfMkteQmS1Wvv0Y2T8lSlSY3WarS5CZLVZrcZKlKkev+HM+b5SZLVZrcZKlKk5ssVWlypZbcWqnK/ammN8utlarcn5d6s9xaqSrZKaDrdcNzXo/ffuH5/cWLzI+/vYi0DptcF+l72eS6ot/LJtfl/142ubLCvWxyBYt72eRKIfeyyRVZbmWT7LTVe9nkmpjuZVP3Gn60xzs5vryRJ5m6V3CFTLJT6v6GzHk+TtY5ey0z2YF2d5Kp+1/TPF2/6Pv17+mwqZuHdTZ187DOpm4eVtkkO6/vXjZ187DOpm620dnUTTc6G4HNkE3djqmzqZyL9+vFH/fnOmwq52KNTeVcrLGpnIsVNsnO07yXTeVcrLGpnIs1NpVzscZGYDNkUzkXa2zIxWM25OIxG3LxmA25eMgm13m3N7MhF4/ZkIvHbMjFYzZSl017qmxNOmwK52KVTeFcrLIpnItVNoVzscqmcC7W2OQ6sfhmNoVzscqmcC5W2RTOxSobgc2QDbl4zIZcPGZDLh6zIReP2ZCL/78Rm2Qnit/LpvI1fH2yWfcOm8rXcI1N5c/i56Hv7def+8am8mfxazYt2TnE97KpvFFobCpvFBqbyhuFxkZgM2RTOd9obCpvFBqbyhuFxqZKLv6Umyzqnsfj5dvccTfZec+q3GSBVJObLGNqcpPFRk2u1JKbLNxpcpPlNU1usgimyU2WqjS5tVJVq5WqWq1Ulew0722dL7lrpxElO6BblSu15OZKVarcXKlKlZsrValyc6UqVW6uVKXJTXbKtCo3V6pS5dZKVYtkkvvrGJLHX5836chNFTN0ualihi43VczQ5aaKGbrcVDFDlSupYoYuN1XM0OWmihm63FTjjS5XasmtlapyPcZBl1srVeV62IIut1aqyvVIBF1urVQV+cEFnwoCB6VPBRJeQeA486kgcEL5VFD5p16vfyLYKh9frrKp/FMvjU3ln3ppbCr/1EtjE/iK/nY2/JR9zKbyT700NpV/6nW9lbmdPTaVj0DQ2FTOxQqbyseXq2wq52KNTeVcrLHhCIT/sOn9JLn08eUaG45AGLPhCIQxG45AGLPhaLAxG44GG7IpfXy5xoajwcZsOBpszIZcPGYjsBmyIReP2ZCLx2zIxWM25OIxG3LxkE3p48s1NuTiMRty8ZgNuXjMpm6+Oc/Hz5DPc+2QqZtuNDJ1s41Gpm6yeU1mKfwoAI1M3VSjkambaTQydRONRkYgMyBTd+XTyJCBR2TIwCMyZOARGTLwgEy2Bwr8zQ4xzdPzby8dNoW3PZVN4W1PZVN421PZCGyGbArf81bZFL7nrbIpfM9bZVP4nrfKpvA9b41NtkdC/BWbtl9/W6YOm8q5WGNTORdrbCrnYo2NwGbIpnIu1tiQi8dsyMXjfEMuHrMhFw/ZJHuox71s2IvHbNiLx2zYi8dsBDZDNuzFYzbk4jEbcvGYDbl4zIZcPGST6yk0N7MhF4/ZkIvHbMjFYzYCmyEbcvGYDbl4zIZcPGZDLh6zIRcP2eR6jtDNbMjFYzbk4jEbcvGYTd18c7THOzm+vJEnmbrp5pDtQWbbOmTqZhuNTN1ko5Ap/IwgjUzdq5NGRiAzIFN3sdHIFM4zChnyzIgMeWZEhjwzIFP4mUAamborjUamcAY+Hn/6ODtdu/DTgDQyApkBmcIZWCFTOAMrZApnYIVM4QyskCmcgV+TKfz8H41M4QyskCEDj8iQgUdkBDIDMmTgERky8IgMGXhEhgw8IkMGHpAp/KwfjQwZeESGDDwiQwYekRHIDMiQ9EZkSHojMiS9ERmSXp+MFH76kUbm36/ay3Xq/iayKmTmc74OeTuPUyfzfH7e1I5Nef3S1uPz5UvbWkeu5JJ7TJfcL2/8KXevJfeoJfcsJfeGx3eEkjvXkttqyU123dXk1rru3vB0i1Byt1pyc6WqD5EPucsiHbm5UpUqN1eq0uS2XKlKlZsrValyc6UqVW6uVKXKlVpyc6UqVW6uVLUs1zS3rHNHbrJUpclNlqo0uclSlSJ3SZaqNLnJUpUmN1mqmp9yl7UjN1mq0uRKLbnJUpUmN1mq0uQmS1Wa3GSpSpObLFUpciVZqtLkJktVmtxaqUpqpaobDnEPJbdWqpJaqUpqpSqplaqkVqpaa6WqtVaqWmulqrVWqlprxYy1VsxYa8WMtVbMWGvFjC3Vhaid2+O8yHbuU0duqguRLldqyU113dXlprru6nJTXXd1uamuu7rcVNddVe6eqt7rclPVe11urno/TY9fKy8f/68dubnqvSpXasnNtWaocnOtGarcXGuGKjdZqjqub6tPU+dkhT1ZqlLkHslSlSY3WarS5CbbqjS5ybYqTa7Ukptsq9LkJtuqNLnJtipNbq1UddRKVWetVHXWSlVnrVR11kpVN5xyG0purVR11kpVZ61UddZKVWepVLVOpVLVOpVKVetUKlWtuQ4s1uVKLbm5rrvH8Xgv7Zx+u3vf+eNtvVS2de+wyXWRvpdNriv6rWxynZt8M5tcWeFeNrmCxb1scqWQe9kIbIZscq1Gf8fmeibK3M4em1wT071sKudijU3lXKyxqZyLFTa5Tr6+mU3lXPz82+3Xn/vGpnIu1thUzsUaG4HNkE3lXKyxqZyLNTaVc7HGpnIu1thUzsUKm1xnl9/Mhlw8ZkMuHrMhF4/ZCGyGbMjFYzbk4jEbcvGYDbl4zIZcPGST6/T5m9mQi8dspCyb83rf57l2yNRNNxqZutlGI1M32Whk6uYajUzdVKOQyXX2+61k6iYajUzdnU8jU3fl08gIZAZkyMAjMmTgERky8IhM4W1vmqfn3146bApvexqbrfC2p7IpvO2pbArf81bZFL7nrbIR2AzZFL7nrbIpfM9bZVP4nrfKpnIubtdbmWTqsKmcixU2yR4eci+byrlYY1M5F2tsKudijY1wDR+yIRcP802uR6nczIZcPGbDXjxmw148ZJPs8S/3smEvHrNhLx6zYS8esxHYDNmQi8dsyMVjNuTiMRty8ZgNuXjIJtkDfO5lQy4esyEXj9mQi8dsBDZDNuTiMRty8ZgNuXjMhlw8ZkMuHrHZkj2C6V425OIxGynL5miPI4qPdnTI1E03h2wPMtvWIVM322hk6iYbhUzhZwRpZOpenTQydTcbjUzdxUYjI5AZkCHPjMiQZ0ZkyDMjMnV3Go1M3ZVGIVP4eUDHsT7InJ2uXfhpQBqZwhlYIVM4AytkBDIDMoUzsEKmcAZWyBTOwAqZwhlYIVM4A78mU/jZPxoZMvCIDBl4RIYMPCIjkBmQIQOPyJCBR2TIwCMyZOARGTLwgEzh5/xoZMjAIzJk4BEZgcyADElvRIakNyJD0huRIekNyLh/ko2cTzLr8dvrPxV4v7rqCrwvQboC79dxXYH3662uwPt1UVfg/fqlK/B+ndEVeG/+qgL3T+vQFYS/Jrt/8oWuIPw12f1TJHQF3q/Jy/pUIIf2euVR0Jv7xzfcLNf71f5mud6jwc1yveeIe+W6fxTCzXK9J5Sb5XqPMzfL9Z59bpYrteTWSlXuD/+/WW6tVOX+iP6b5dZKVe4P0r9Zbq1U5f64+5vl1kpV7g+lv1lurVTl/uj4m+XmSlUyXX9dlqkjN1eqUuXmSlXLsTzldv7H7P447b+Tu62P9/Lxj60jN9d1V5Wb67qrys113VXl5rrufuh5vHyfz47cXNddVW6u664qN9d1V5G7uz/m+S/lPjPz3qaO3FzX3WO/Xn6ca0duqk/mNl9nT7e5c/b07v603Jvlpvpk1uWm+mRW5bo/4Phmual2Zl1uqr6ry0113dXlSi25qfquLrdWqnJ/Zu/NcmulKven6/6l3G255P56t/8r1/2RuTfLTZaqNLnJUpUmN1mq0uRKLbnJUpUmN1mq0uQmS1Wa3GSpSpNbK1W5P4T1ZrnJ7t4rN03cH315s9xkd+81ubnu3h/tuuF5rJ2+6/7kyZvl5rp7r8rNdfdek+v+4Meb5eb6LYIqN9d3IlW5yb6bocmVWnJzpSpVbq1U5f6Ux5vlJktVytfIJFmqUuSuyVKVJjdZqtLkJktVmtxa33h1f+jnzXKTpSpNbrJUpclNlqo0ubVSlftTTe+V6/4I1Jvl1kpV7g9XvVluruvuet3wnNfjt194fn/xIvPjby8ircMm10X6Xja5ruj3ssl1+b+XTa6scCubZMec3ssmVwq5l02uyHIvm1yr0b1sBDZDNnWv4UeTz9ce7eiQqXsFV8gkO6Xub8ic1/s+ey0z2YF2d5Kp+1/TPF2/6Pv17/nO5qybh3U2dfOwzqZuHtbZ1M3DOhuBzZBN3Wyjs6mbbnQ2dXdinU3djqmzqZyL9+vFc/u+TRzJjjq8l03lXKyxqZyLNTaVc7HGRmAzZFM5F2tsKudijU3lXKyxqZyLNTbk4iGbXAfN3syGXDxmQy4esyEXj9kIbIZsyMVjNuTiMZvCubg9VbYmHTaFc7HKpnAu1tjkOir4ZjaFc7HKpnAuVtkUzsUqG4HNkE3hXKyyKZyLVTbk4jEbcvGYDbl4yCbXYc83syEXj9mQi8dsyMVjNpWv4euTzbp32FS+hitskp0W/Hdsnoe+t19/7hubyp/FGpvKn8UaG4HNkE3ljUJjU3mj0NhUzjcam8r5RmNTeaNQ2CQ7wvleNlVy8afcZFH3PB4v3+aeu8nSqyZXaslNljE1uclioyY3WRLU5CYLd5rcZHlNkZvsvGdVbrJUpcmtlaq2Wqlqk1pykz3xdZ0vuWunESU7oFuVmytVqXJzpSpVbq5UpclNdti1KjdXqlLl5kpVqtxcqUqVK7Xk1kpVe6qY0eZrVv/4x863snKd9K3LTRUzVLlHqpihy00VM3S5qWKGLjdVzNDlSi25qWKGLjfVeKPLrZWqjlqpKtdjHFS5uZ7MoMutlapyPT9Bl1srVeV6yoEuN3Cq+lQQOCh9KgicfT4VBI4znwoCJ5T/KDgrH1+u/ETwrHx8ucom1QXvZjaVf+qlsan8Uy+NDT9lH7Php+xjNpV/6qWwqXx8eTvkYnP22FQ+AkFjUzkXa2wq52KNjcBmyKZyLtbYcATCf9h0fpJ8lj6+XGPDEQhjNhyBMGRT+vhyjQ1Hg43ZcDTYmA1Hg43ZCGyGbDgabMyGXDxmQy4esyEXj9mQi4dsSh9frrEhF4/ZkIvHbMjFYzYCmyEbcvGYDbl4zKZuvjmv932e63cyUjfdaGTqZhuNTN1ko5Gpm2s0MgKZAZm6mUYjUzfRaGTq7nwamborn0aGDDwgU/jwf40MGXhEhgw8IlN425vm6fm3lw4bgc2QTeFtT2VTeNtT2RS+562yKXzPW2VT+J63xibbsxhuZVP4nrfKpvA9b5VN5VzcrrcyydRhI7AZsqmcizU2lXOxxqZyLtbYVM7FGhty8ZBNsqdp3Jpvkj1641425OIxG/biMRuBzZANe/GYDXvxmA178ZgNe/GYDbl4yCbX419uZkMuHrMhF4/ZkIvHbAQ2Qzbk4jEbcvGYDbl4zIZcPGZDLh6yyfUAn5vZkIvHbMjFYzbk4jEbgc2QDbl4zIZcPGZTN98c7XFE8dGO/yWzTFPddHPI9iCzbR0ydbONRqZustHI1L0+aWTqXp00MnU3G41M3cVGI1M4z7wmU/jJQBoZ8syIDHlmRKbuTqOREcgMyBTOwMfjTx9np2sXfhqQRqZwBlbIFM7ACpnCGfg1mcJPAdLIFM7ACpnCGVghUzgDK2QEMgMyZOARGTLwiAwZeESGDDwiQwYekCn8xB+NDBl4RIYMPCJDBh6REcgMyJCBR2TIwCMyZOARGZLegEzhpx9pZEh6IzIkvREZkt6IzA1X7XY8yCzroZBp8/54dWtt/vKGls6rZZof1GVa5Xp12zsv3tcH8/14/uHu313b42b/+uXr4x8v/YSyl4Qij5eu696BcgDlO5QTKN+g3PHUmnxQZqB8h9KA8h3KApTvUAQo36GsQPkOpWaiVaBUT7RfvtP7hFI90XahFE20VyHcO1C2mol2OV9CqZloFSg1E60CpWSi3aaHvm06O1AEKN+hlEy0GpSSiVaDUjLRalBqJtrzcYtjm6cOlJqJ9jWUvWaiVaDUTLQKlJqJVoFSc6NVoAhQvkOpudEqUGputAqUmhvtFyidRLuXT7Q9KEUT7ePMx611oBw1E+2xvYRSM9EqUGomWgVKzY32Gq63tXWgCFC+Q6m50SpQam60CpSaG60CpWSi1aCUTLQKlLNkotWg/HhOmR+5qc3rZBXeXv9g4Y6nawSE8vo7b+cKlO9QNqB8h7ID5TuUAyjfoZxA+V8o8zQB5TuUGSjfoTSgfIdSM9EqUKQ4lM538+epeqLtQimaaF/9YGGeaibal19Dn6eaiVaBUjPRvoYyl0y0r79cPM8lE60GpWSi1aCUTLQaFAHKdyg1E+3LLwLOc81Eq0CpmWgVKDUTrQKlZqJ9DaXV3GgVKDU3WgVKzY1WgVJzo1WgSHUonUTbyifaHpSiifbVDxbmVjPRvvwa+txqJloFSs1E+xrKUnOjffntyHmpudEqUGputAqUmhutAkWA8h1KyUSrQSmZaDUoJROtAkV+OqdMcv2KY/rt6RB+frAwy1wSyuvvvEkDyncoC1C+QxGgfIeyAuU7lA0o36HsQPkO5QDKdygnUL5BWWsmWgVK9UTb+27+Wj3RdqEUTbQvf7Dw48/38QHl9dfQ15qJVoFSM9EqUEomWuXLxWvJRKtBKZloFShbyUSrQSmZaDUoNRPt6y8CbjUTrQJFgPIdSs1Eq0CpmWgVKDU3WgVKzY1WgVJzo30NZa+50SpQam60r7+bv5dPtD0oRRPtyx8s/PjzfXxAef019L1molWg1Ey0CpSaG+3rb0fuNTdaBUrNjfY1lKPmRqtAqbnRKlBKJloNSslEq0ERoHyH8sM5ZT73+YIyi1V4e/2DhZ9+aosTKK+/8/bTT20JAeWnn9oSA8oMlO9QGlC+Q1mA8h2KAOU7lBUo36FsQPkOpWaiVaBUT7S97+af1RNtB0qbiibaVz9YaFPNRPvya+htqploFSg1E60CRSpCef3l4jaVTLQalJKJVoNSMtFqUEomWg1KzUT78ouAba6ZaBUoNROtAqVmolWg1Ey0ChQByncoNTdaBUrNjVaBUnOjVaDU3Ghffje/zeUTbQdKK5poX/1gobWaifbl19Bbq5loFSg1E60CRUruKS+/HdlazY1WgVJzo1Wg1NxoFSg1N1oFSslEq0BZSiZaDUrJRKtBkX+GMq/zs10tCpR1v74uczz/8DJd72d19n42Z+9nd/Z+jp99Px/36a7YLb33c/p6Pzc8weTe9zM7ez/N2ftZnL0f+en3Mz1ePG2997M6ez+bs/ezO3s/h7P3c/p6P+vk7P3Mzt5Pc/Z+Fmfvx9nn8+rs83l19vm8Ovt8Xp19Pq/OPp83Z5/Pm7PP583Z5/Pm7PN5c/b53D+a9ePf8fn/dUzLnW9nXuTxl+dlfb76Y1X6fD+Hs/dz+no//bNADd/P7Oz9NGfvZ3H2fsTZ+1mdvZ/N2ftx9vm8O/t83p19Ph/OPp8PZ5/Px8/+967dLjg2X2/nZ//XrIXDc/L1dmZfb6f5ejv/njSWL29HtP/Sn19inT/+P59vqM2PNyTe3tDq7Q1t3t7Q7u0NHd7e0OnrDS3T9LNvaJPpekNfvnLy5Q3N3t5Q8/aGFm9vSLy9odXbG9q8vaF3flJ//iuO9/8rzrf/K+bp/f+K+f3/ivb+f8Xy/n+FvP9fsb7/X7G9/1/x/v+65/f/1z2//7/u9v7/utv7/+tu7/+vu73/v+72/v+62z//192eLbrNq3YZVtaspW3O3s/u7P0czt7P6ev9LJOz9/PPn3V/94uE9vjvfV6nTshdmq+3s/h6O+Lr7ay+3s7m6+3svt7O4evtnK7ejky+3o6vT2Xx9aksvj6Vxdensvj6VBZfn8ri61NZfH0qi69P5dXXp/Lq61N59fWpvPr6VF59fSqvvj6VV1+fyquvT+XV16fy6utTefP1qbz5+lTefH0qb74+lTdfn8qbr0/lzden8ubrU3nz9am8+fpU3n19Ku++PpV3X5/Ku69P5d3Xp/Lu61N59/WpvPv6VN59fSrvvj6VD1+fyoevT+XD16fy4etT+fD1qXz4+lQ+fH0qH74+lQ9fn8qHr0/l09en8unrU/n09al8+vpUPn19Kp++PpVPX5/Kp69P5dPXp/Lp6lNZJlefyjK5+lSWydWnskyuPpVlcvWpLJOrT2WZXH0qy+TqU1kmV5/KMvn6VJ59fSrPvj6VZ1+fyrOvT+XZ16fy7OtTefb1qTz7+lSefX0qz74+lZuvT+Xm61O5+fpUbr4+lZuvT+Xm61O5+fpUbr4+lZuvT+Xm61N58fWp7Ou3feLrt33i67d94uu3feLrt33i67d94uu3feLrt33i67d94uu3feLrt33i67d94uu3feLrt33i67d94uu3feLrt33i67d94uu3feLrt33i67d94uu3feLrt33i67d94uu3feLrt33i67d94uu3feLrt33i67d94uu3feLrt33i67d94uu3feLrt33i67d94uu3feLrt33i67d94uu3feLrt33yw7/ta7J9vniZ1t/ezvfXyjQ/3rtMq1yvbnvnxfv6eFTIfszPly7dv/t4w9KUlx57e3A4ntJaj8M8Hw9pc5vk64s/SS+Q/iHSAukfIr1C+odIb5D+IdI7pH+I9AHpx0s/iZz1iKyPZ/nK17/6IPLDvwGPQGSGyP8QKdhhFCIFu8bxuDB9qO8QEYj8D5GC2V0hUjBjK0TqZeF1up45Ox0dIvUyq0akXmZViJz1MqtGpF5m1YhIPSLt8R7W1iNSL49oROpda7blfLzhtXWI1LvWvCayTo6vNfPyUCnzvn4l8vneHV8V1PfueHNQ37vjdUB9746vm+p7d3yFU9+7426svnfHLVZ9744zwPP5o4P37vhqPc/L871v39/77Pm6qr13z9dV7b3/7HX1Y754vJ0v76b/3udpOR5vfp5Evvzto/v6uT3+257nrzHv0roU0iqFtK6FtG6FtO6FtB6FtJ51tP7w2Ue2WudCWgvlplYoN/3weVO2WgvlplYoN7VCuallyk3n9duh+Tw7WjPlJkXrkik3aVoz5SZNa6bcpGnNlJs0rVJIa6bc9NT6229GLq2ZcpOmNVFuatN5aZ33jtZEuUnVmig3aVolUW5StSbKTarWRLlJ1ZooN6laJafW1jpaU+Wm6al16WhNdH1dlsePVuZFpo7WRNdXTeua6Pqqak10fVW1Jrq+qloTXV9VrYmur6rWRNfXRdZL69q5vq6JdglVa6JdQtWaKTdpWjPlJkXrlik3aVoz5SZF6w+fsvf8lec2NUXr8vEnPl+8zMeX7t0e710Cv/c18HvfAr/3PfB7PwK/9zPue//hM7Xufe9z4PfeAr/3wNfVHz776d73Hvi6egS+rh6Br6tH4OvqEfi6ega+rp6Br6tn4OvqGfi6+sNnGN373gNfV8/A19Uz8HX1DHxdPeNeV7cp7nV1m+JeV7cp7nV1m+JeV7cp7nV1m+JeV7cp7nV1m+JeV7cp7nV1mwJfV+fA19U58HV1DnxdnR1fV9v8ePHS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"}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"Vanhelsing::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Vanhelsing::constructor_parameters","fields":[{"name":"feeTo","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Vanhelsing::createCoffin_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Vanhelsing::createCoffin_parameters","fields":[{"name":"stakingToken","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"rewardsToken","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"periodInDays","type":{"kind":"field"}},{"name":"rewardsAmount","type":{"kind":"field"}},{"name":"nonce","type":{"kind":"field"}}]}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"reject_all","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"approved_actions","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}}]},{"kind":"struct","fields":[{"name":"admin","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"minters","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"total_supply","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"pending_shields","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}},{"name":"public_balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}]}},{"name":"symbol","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}]}},{"name":"name","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}]}},{"name":"decimals","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}]}}]},{"kind":"struct","fields":[{"name":"feeTo","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}}]}],"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000006827b230"},{"kind":"string","value":"AddressNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000006827b230"},{"kind":"string","value":"AddressNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000006827b230"},{"kind":"string","value":"AddressNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000071421477"},{"kind":"string","value":"ValueNote"}]}]}},"file_map":{"22":{"source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\nstruct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint { \n        EmbeddedCurvePoint {\n            x: self.x,\n            y: -self.y,\n            is_infinite: self.is_infinite\n        }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite) | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\nstruct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n// This is a hack as returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\nfn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint\n) -> EmbeddedCurvePoint\n// docs:end:embedded_curve_add\n{\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n    EmbeddedCurvePoint { x, y, is_infinite: point_array[2] == 1 }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n","path":"std/embedded_curve_ops.nr"},"23":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"24":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field/mod.nr"},"27":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\nmod sha256;\nmod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\nuse sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\ntrait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n","path":"std/hash/mod.nr"},"32":{"source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"53":{"source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n","path":"std/option.nr"},"59":{"source":"use crate::append::Append;\n\nimpl<T> [T] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    // Append each element of the `other` slice to the end of `self`.\n    // This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T where T: Append {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n","path":"std/slice.nr"},"62":{"source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        (if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (unsafe {\n                        U128::uconstrained_check_is_upper_ascii(ascii) as u8\n                    });\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        }) as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            \n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        unsafe {\n            let (q,r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        unsafe {\n            let (c,d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        unsafe {\n            let (c, d)= a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n","path":"std/uint128.nr"},"64":{"source":"mod test;\n\ncontract Vanhelsing {\n    use dep::token::Token;\n    use dep::aztec::{prelude::{PublicMutable, AztecAddress, Map}};\n\n    #[aztec(storage)]\n    struct Storage {\n        feeTo: PublicMutable<AztecAddress>,\n    }\n\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(\n        feeTo: AztecAddress,\n    ) {\n        storage.feeTo.write(feeTo);\n    }\n\n    #[aztec(public)]\n    fn createCoffin(\n        stakingToken: AztecAddress,\n        rewardsToken: AztecAddress,\n        periodInDays: Field,\n        rewardsAmount: Field,\n        nonce: Field\n    ) {\n\n        Token::at(rewardsToken).transfer_public(\n            context.msg_sender(),\n            context.this_address(),\n            rewardsAmount,\n            nonce\n        ).call(&mut context);\n\n    }\n\n}\n","path":"/home/g/Documents/Code/aztec-tutorials/aztec-txe/contracts/myContract/src/main.nr"},"68":{"source":"use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal ADDRESS_NOTE_LEN: Field = 3;\n// ADDRESS_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal ADDRESS_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[aztec(note)]\nstruct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NoteInterface<ADDRESS_NOTE_LEN, ADDRESS_NOTE_BYTES_LEN> for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/address-note/src/address_note.nr"},"77":{"source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::{PrivateContext, UnconstrainedContext},\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{\n    public_keys::{PublicKeys, PUBLIC_KEYS_LENGTH}, stored_keys::StoredKeys,\n    constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}\n},\n    state_vars::{\n    shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter,\n    public_mutable::PublicMutable, map::Map\n}\n};\n\nmod test;\n\n// This is the number of blocks that must pass after a key rotation event until the old keys are fully phased out and\n// become invalid.\nglobal KEY_REGISTRY_UPDATE_BLOCKS = 5;\n\nglobal KEY_REGISTRY_STORAGE_SLOT = 1;\n\n// A helper function since requesting nsk_app is very common\n// TODO(#6543)\npub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// Returns all current public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_current_public_keys(context: &mut PrivateContext, account: AztecAddress) -> PublicKeys {\n    // We're going to perform historical reads from public storage, and so need to constrain the caller so that they\n    // cannot use very old blocks when constructing proofs, and hence e.g. read very old keys. We are lax and allow\n    // _any_ recent block number to be used, regardless of whether there may have been a recent key rotation. This means\n    // that multiple sets of keys are valid for a while immediately after rotation, until the old keys become phased\n    // out. We *must* be lax to prevent denial of service and transaction fingerprinting attacks by accounts that rotate\n    // their keys frequently.\n    // Note that we constrain the max block number even if the registry ends up being empty: this ensures that proof of\n    // an empty registry is also fresh.\n    let current_header = context.get_header();\n    context.set_tx_max_block_number(current_header.global_variables.block_number as u32 + KEY_REGISTRY_UPDATE_BLOCKS);\n\n    get_historical_public_keys(current_header, account)\n}\n\n// Returns historical public keys for a given account at some block determined by a block header. We read all keys at\n// once since the constraints for reading them all are actually fewer than if we read them one at a time - any read keys\n// that are not required by the caller can simply be discarded.\n// WARNING: if called with a historical header created from a fixed block this function will explicitly ignore key\n// rotation! This means that callers of this may force a user to use old keys, potentially leaking privacy (e.g. if the\n// old keys were leaked). Only call this function with a header from a fixed block if you understand the implications of\n// breaking key rotation very well.\npub fn get_historical_public_keys(historical_header: Header, account: AztecAddress) -> PublicKeys {\n    // TODO: improve this so that we always hint the correct set of keys (either registry or canonical) and hash them\n    // once instead of having two different hints and twice as many constraints due to the double hashing.\n\n    // The key registry is the primary source of information for keys, as that's where accounts store their new keys\n    // when they perform rotation. The key registry conveniently stores a hash of each user's keys, so we can read that\n    // single field and then prove that we know its preimage (i.e. the current set of keys).\n    let key_registry_hash = key_registry_hash_public_historical_read(historical_header, account);\n    if key_registry_hash != 0 {\n        let hinted_registry_public_keys = key_registry_get_stored_keys_hint(\n            account,\n            historical_header.global_variables.block_number as u32\n        );\n        assert_eq(hinted_registry_public_keys.hash().to_field(), key_registry_hash);\n\n        hinted_registry_public_keys\n    } else {\n        // If nothing was written to the registry, we may still be able to produce the correct keys if we happen to know\n        // the canonical set (i.e. the ones that are part of the account's preimage).\n        let (hinted_canonical_public_keys, partial_address) = get_public_keys_and_partial_address(account);\n        assert_eq(\n            account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n        );\n\n        hinted_canonical_public_keys\n    }\n}\n\nfn key_registry_hash_public_historical_read(historical_header: Header, account: AztecAddress) -> Field {\n    // The keys are stored in a Map that is keyed with the address of each account, so we first derive the corresponding\n    // slot for this account.\n    let keys_storage_slot = derive_storage_slot_in_map(KEY_REGISTRY_STORAGE_SLOT, account);\n\n    // The keys are stored as [ ...serialized_keys, hash ], and since arrays get allocated sequential storage slots\n    // (prior to siloing!), we simply add the length to the base slot to get the last element.\n    let hash_storage_slot = keys_storage_slot + PUBLIC_KEYS_LENGTH as Field;\n\n    historical_header.public_storage_historical_read(hash_storage_slot, CANONICAL_KEY_REGISTRY_ADDRESS)\n}\n\nunconstrained fn key_registry_get_stored_keys_hint(account: AztecAddress, block_number: u32) -> PublicKeys {\n    // This is equivalent to the key registry contract having an unconstrained getter that we call from an oracle, but\n    // PXE does not yet support that functionality so we do this manually instad. Note that this would be a *historical*\n    // call!\n\n    // TODO (#7524): call the unconstrained KeyRegistry.get_current_keys() function instead\n\n    let context = UnconstrainedContext::at_historical(CANONICAL_KEY_REGISTRY_ADDRESS, block_number);\n    let keys_storage = Map::new(\n        context,\n        KEY_REGISTRY_STORAGE_SLOT,\n        |context, slot| { PublicMutable::new(context, slot) }\n    );\n\n    let stored_keys: StoredKeys = keys_storage.at(account).read();\n    stored_keys.public_keys\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"85":{"source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"104":{"source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/initializer.nr"},"105":{"source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"123":{"source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub fn get_key_validation_request(pk_m_hash: Field, key_index: Field) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"141":{"source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32, let M: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32, let M: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the \n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the \n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from \n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let M: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"159":{"source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\ntrait CallInterface<let N: u32, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr"},"162":{"source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        _contract_address: AztecAddress,\n        _function_selector: FunctionSelector,\n        _args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(_self: Self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [\n        user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n        user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<let N: u32>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N as Field)\n}\n\nunconstrained fn storage_write<let N: u32>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<let N: u32>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<let N: u32>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<let N: u32> {\n    values: [Field; N]\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"181":{"source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc, point::Point\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"196":{"source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash_with_separator,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"219":{"source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"233":{"source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr"},"244":{"source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"288":{"source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x:fields[0], y: fields[1], is_infinite: fields[2] as bool},\n            sk_app: fields[3],\n        }\n    }\n}\n\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr"},"300":{"source":"struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"303":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr"},"318":{"source":"// docs:start:token_all\n// docs:start:imports\nmod types;\nmod test;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n\ncontract Token {\n    // Libs\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        context::{PrivateContext, PrivateCallInterface}, hash::compute_secret_hash,\n        prelude::{\n        NoteGetterOptions, Map, PublicMutable, SharedImmutable, PrivateSet, AztecAddress,\n        FunctionSelector, NoteHeader, Point\n    },\n        encrypted_logs::{\n        encrypted_note_emission::{encode_and_encrypt_note_with_keys, encode_and_encrypt_note_with_keys_unconstrained},\n        encrypted_event_emission::{encode_and_encrypt_event, encode_and_encrypt_event_with_keys_unconstrained}\n    },\n        keys::getters::get_current_public_keys\n    };\n\n    // docs:start:import_authwit\n    use dep::authwit::auth::{assert_current_call_valid_authwit, assert_current_call_valid_authwit_public, compute_authwit_nullifier};\n    // docs:end:import_authwit\n\n    use crate::types::{\n        transparent_note::TransparentNote,\n        token_note::{TokenNote, TOKEN_NOTE_LEN, TokenNoteHidingPoint}, balances_map::BalancesMap\n    };\n    // docs:end::imports\n\n    // In the first transfer iteration we are computing a lot of additional information (validating inputs, retrieving\n    // keys, etc.), so the gate count is already relatively high. We therefore only read a few notes to keep the happy\n    // case with few constraints.\n    global INITIAL_TRANSFER_CALL_MAX_NOTES = 2;\n    // All the recursive call does is nullify notes, meaning the gate count is low, but it is all constant overhead. We\n    // therefore read more notes than in the base case to increase the efficiency of the overhead, since this results in\n    // an overall small circuit regardless.\n    global RECURSIVE_TRANSFER_CALL_MAX_NOTES = 8;\n\n    #[aztec(event)]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n    }\n\n    // docs:start:storage_struct\n    #[aztec(storage)]\n    struct Storage {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool>>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: BalancesMap<TokenNote>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128>,\n        // docs:start:storage_pending_shields\n        pending_shields: PrivateSet<TransparentNote>,\n        // docs:end:storage_pending_shields\n        public_balances: Map<AztecAddress, PublicMutable<U128>>,\n        symbol: SharedImmutable<FieldCompressedString>,\n        name: SharedImmutable<FieldCompressedString>,\n        // docs:start:storage_decimals\n        decimals: SharedImmutable<u8>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[aztec(public)]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_name() -> pub FieldCompressedString {\n        storage.name.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_name() -> pub FieldCompressedString {\n        storage.name.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_public\n        storage.decimals.read_public()\n        // docs:end:read_decimals_public\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_private\n        storage.decimals.read_private()\n        // docs:end:read_decimals_private\n    }\n\n    // docs:start:admin\n    #[aztec(public)]\n    #[aztec(view)]\n    fn admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[aztec(public)]\n    #[aztec(view)]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:total_supply\n    #[aztec(public)]\n    #[aztec(view)]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n\n    // docs:start:balance_of_public\n    #[aztec(public)]\n    #[aztec(view)]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n\n    // docs:start:set_minter\n    #[aztec(public)]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint_public\n    #[aztec(public)]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_public\n\n    // docs:start:mint_private\n    #[aztec(public)]\n    fn mint_private(amount: Field, secret_hash: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount, secret_hash);\n        let supply = storage.total_supply.read().add(U128::from_integer(amount));\n\n        storage.total_supply.write(supply);\n        // docs:start:insert_from_public\n        pending_shields.insert_from_public(&mut note);\n        // docs:end:insert_from_public\n    }\n    // docs:end:mint_private\n\n    // TODO: Nuke this - test functions do not belong to token contract!\n    #[aztec(private)]\n    fn privately_mint_private_note(amount: Field) {\n        let caller = context.msg_sender();\n        let caller_keys = get_current_public_keys(&mut context, caller);\n        storage.balances.add(caller, caller_keys.npk_m, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note_with_keys(&mut context, caller_keys.ovpk_m, caller_keys.ivpk_m, caller)\n        );\n\n        Token::at(context.this_address()).assert_minter_and_mint(context.msg_sender(), amount).enqueue(&mut context);\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn assert_minter_and_mint(minter: AztecAddress, amount: Field) {\n        assert(storage.minters.at(minter).read(), \"caller is not minter\");\n        let supply = storage.total_supply.read() + U128::from_integer(amount);\n        storage.total_supply.write(supply);\n    }\n\n    // docs:start:shield\n    #[aztec(public)]\n    fn shield(from: AztecAddress, amount: Field, secret_hash: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            // The redeem is only spendable once, so we need to ensure that you cannot insert multiple shields from the same message.\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount.to_field(), secret_hash);\n\n        storage.public_balances.at(from).write(from_balance);\n        pending_shields.insert_from_public(&mut note);\n    }\n    // docs:end:shield\n\n    // docs:start:transfer_public\n    #[aztec(public)]\n    fn transfer_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_public\n\n    // docs:start:burn_public\n    #[aztec(public)]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n\n    // docs:start:redeem_shield\n    #[aztec(private)]\n    fn redeem_shield(to: AztecAddress, amount: Field, secret: Field) {\n        let secret_hash = compute_secret_hash(secret);\n\n        // Pop 1 note (set_limit(1)) which has an amount stored in a field with index 0 (select(0, amount)) and\n        // a secret_hash stored in a field with index 1 (select(1, secret_hash)).\n        let mut options = NoteGetterOptions::new();\n        options = options.select(TransparentNote::properties().amount, amount, Option::none()).select(\n            TransparentNote::properties().secret_hash,\n            secret_hash,\n            Option::none()\n        ).set_limit(1);\n\n        let notes = storage.pending_shields.pop_notes(options);\n        assert(notes.len() == 1, \"note not popped\");\n\n        // Add the token note to user's balances set\n        // Note: Using context.msg_sender() as a sender below makes this incompatible with escrows because we send\n        // outgoing logs to that address and to send outgoing logs you need to get a hold of ovsk_m.\n        let from = context.msg_sender();\n        let from_keys = get_current_public_keys(&mut context, from);\n        let to_keys = get_current_public_keys(&mut context, to);\n        storage.balances.add(to, to_keys.npk_m, U128::from_integer(amount)).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to));\n    }\n    // docs:end:redeem_shield\n\n    // docs:start:unshield\n    #[aztec(private)]\n    fn unshield(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let from_keys = get_current_public_keys(&mut context, from);\n        storage.balances.sub(from, from_keys.npk_m, U128::from_integer(amount)).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from));\n\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:unshield\n\n    // docs:start:transfer\n    #[aztec(private)]\n    fn transfer(to: AztecAddress, amount: Field) {\n        let from = context.msg_sender();\n\n        let from_keys = get_current_public_keys(&mut context, from);\n        let to_keys = get_current_public_keys(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n\n        // We reduce `from`'s balance by amount by recursively removing notes over potentially multiple calls. This\n        // method keeps the gate count for each individual call low - reading too many notes at once could result in\n        // circuits in which proving is not feasible.\n        // Since the sum of the amounts in the notes we nullified was potentially larger than amount, we create a new\n        // note for `from` with the change amount, e.g. if `amount` is 10 and two notes are nullified with amounts 8 and\n        // 5, then the change will be 3 (since 8 + 5 - 10 = 3).\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            from,\n            amount,\n            INITIAL_TRANSFER_CALL_MAX_NOTES\n        );\n\n        storage.balances.add(from, from_keys.npk_m, change).emit(\n            encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from)\n        );\n\n        storage.balances.add(to, to_keys.npk_m, amount).emit(\n            encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to)\n        );\n\n        // We don't constrain encryption of the note log in `transfer` (unlike in `transfer_from`) because the transfer\n        // function is only designed to be used in situations where the event is not strictly necessary (e.g. payment to\n        // another person where the payment is considered to be successful when the other party successfully decrypts a\n        // note).\n        Transfer { from, to, amount: amount.to_field() }.emit(\n            encode_and_encrypt_event_with_keys_unconstrained(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to)\n        );\n    }\n    // docs:end:transfer\n\n    #[contract_library_method]\n    fn subtract_balance(\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n        account: AztecAddress,\n        amount: U128,\n        max_notes: u32\n    ) -> U128 {\n        let subtracted = storage.balances.try_sub(account, amount, max_notes);\n\n        // Failing to subtract any amount means that the owner was unable to produce more notes that could be nullified.\n        // We could in some cases fail early inside try_sub if we detected that fewer notes than the maximum were\n        // returned and we were still unable to reach the target amount, but that'd make the code more complicated, and\n        // optimizing for the failure scenario is not as important.\n        assert(subtracted > U128::from_integer(0), \"Balance too low\");\n\n        if subtracted >= amount {\n            // We have achieved our goal of nullifying notes that add up to more than amount, so we return the change\n            subtracted - amount\n        } else {\n            // try_sub failed to nullify enough notes to reach the target amount, so we compute the amount remaining\n            // and try again.\n            let remaining = amount - subtracted;\n            compute_recurse_subtract_balance_call(*context, account, remaining).call(context)\n        }\n    }\n\n    // TODO(#7729): apply no_predicates to the contract interface method directly instead of having to use a wrapper\n    // like we do here.\n    #[no_predicates]\n    #[contract_library_method]\n    fn compute_recurse_subtract_balance_call(\n        context: PrivateContext,\n        account: AztecAddress,\n        remaining: U128\n    ) -> PrivateCallInterface<25, U128, (AztecAddress, Field)> {\n        Token::at(context.this_address())._recurse_subtract_balance(account, remaining.to_field())\n    }\n\n    // TODO(#7728): even though the amount should be a U128, we can't have that type in a contract interface due to\n    // serialization issues.\n    #[aztec(internal)]\n    #[aztec(private)]\n    fn _recurse_subtract_balance(account: AztecAddress, amount: Field) -> U128 {\n        subtract_balance(\n            &mut context,\n            storage,\n            account,\n            U128::from_integer(amount),\n            RECURSIVE_TRANSFER_CALL_MAX_NOTES\n        )\n    }\n\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[aztec(private)]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier);\n    }\n    // docs:end:cancel_authwit\n\n    // docs:start:transfer_from\n    #[aztec(private)]\n    fn transfer_from(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n\n        let from_keys = get_current_public_keys(&mut context, from);\n        let to_keys = get_current_public_keys(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        storage.balances.sub(from, from_keys.npk_m, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        storage.balances.add(to, to_keys.npk_m, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to));\n    }\n    // docs:end:transfer_from\n\n    // docs:start:burn\n    #[aztec(private)]\n    fn burn(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let from_keys = get_current_public_keys(&mut context, from);\n        storage.balances.sub(from, from_keys.npk_m, U128::from_integer(amount)).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from));\n\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn\n\n    /// We need to use different randomness for the user and for the fee payer notes because if the randomness values\n    /// were the same we could fingerprint the user by doing the following:\n    ///      1) randomness_influence = fee_payer_point - G_npk * fee_payer_npk =\n    ///                              = (G_npk * fee_payer_npk + G_rnd * randomness) - G_npk * fee_payer_npk =\n    ///                              = G_rnd * randomness\n    ///      2) user_fingerprint = user_point - randomness_influence =\n    ///                          = (G_npk * user_npk + G_rnd * randomness) - G_rnd * randomness =\n    ///                          = G_npk * user_npk\n    ///      3) Then the second time the user would use this fee paying contract we would recover the same fingerprint\n    ///         and link that the 2 transactions were made by the same user. Given that it's expected that only\n    ///         a limited set of fee paying contracts will be used and they will be known, searching for fingerprints\n    ///         by trying different fee payer npk values of these known contracts is a feasible attack.\n    ///\n    /// `fee_payer_point` and `user_point` above are public information because they are passed as args to the public\n    /// `complete_refund(...)` function.\n    #[aztec(private)]\n    fn setup_refund(\n        fee_payer: AztecAddress, // Address of the entity which will receive the fee note.\n        user: AztecAddress, // A user for which we are setting up the fee refund.\n        funded_amount: Field, // The amount the user funded the fee payer with (represents fee limit).\n        user_randomness: Field, // A randomness to mix in with the generated refund note for the sponsored user.\n        fee_payer_randomness: Field // A randomness to mix in with the generated fee note for the fee payer.\n    ) {\n        // 1. This function is called by fee paying contract (fee_payer) when setting up a refund so we need to support\n        // the authwit flow here and check that the user really permitted fee_payer to set up a refund on their behalf.\n        assert_current_call_valid_authwit(&mut context, user);\n\n        // 2. Get all the relevant keys\n        let fee_payer_npk_m_hash = get_current_public_keys(&mut context, fee_payer).npk_m.hash();\n        let user_keys = get_current_public_keys(&mut context, user);\n        let user_npk_m_hash = user_keys.npk_m.hash();\n\n        // 3. Deduct the funded amount from the user's balance - this is a maximum fee a user is willing to pay\n        // (called fee limit in aztec spec). The difference between fee limit and the actual tx fee will be refunded \n        // to the user in the `complete_refund(...)` function.\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            user,\n            U128::from_integer(funded_amount),\n            INITIAL_TRANSFER_CALL_MAX_NOTES\n        );\n        storage.balances.add(user, user_keys.npk_m, change).emit(\n            encode_and_encrypt_note_with_keys_unconstrained(&mut context, user_keys.ovpk_m, user_keys.ivpk_m, user)\n        );\n\n        // 4. We create the partial notes for the fee payer and the user.\n        // --> Called \"partial\" because they don't have the amount set yet (that will be done in `complete_refund(...)`).\n        let fee_payer_partial_note = TokenNote {\n            header: NoteHeader {\n                contract_address: AztecAddress::zero(),\n                nonce: 0,\n                storage_slot: storage.balances.map.at(fee_payer).storage_slot,\n                note_hash_counter: 0\n            },\n            amount: U128::zero(),\n            npk_m_hash: fee_payer_npk_m_hash,\n            randomness: fee_payer_randomness\n        };\n        let user_partial_note = TokenNote {\n            header: NoteHeader {\n                contract_address: AztecAddress::zero(),\n                nonce: 0,\n                storage_slot: storage.balances.map.at(user).storage_slot,\n                note_hash_counter: 0\n            },\n            amount: U128::zero(),\n            npk_m_hash: user_npk_m_hash,\n            randomness: user_randomness\n        };\n\n        // 5. Now we get the note hiding points.\n        let mut fee_payer_point = fee_payer_partial_note.to_note_hiding_point();\n        let mut user_point = user_partial_note.to_note_hiding_point();\n\n        // 6. Set the public teardown function to `complete_refund(...)`. Public teardown is the only time when a public\n        // function has access to the final transaction fee, which is needed to compute the actual refund amount.\n        context.set_public_teardown_function(\n            context.this_address(),\n            FunctionSelector::from_signature(\"complete_refund(((Field,Field,bool)),((Field,Field,bool)),Field)\"),\n            [\n            fee_payer_point.inner.x, fee_payer_point.inner.y, fee_payer_point.inner.is_infinite as Field, user_point.inner.x, user_point.inner.y, user_point.inner.is_infinite as Field, funded_amount\n        ]\n        );\n    }\n\n    // TODO(#7728): even though the funded_amount should be a U128, we can't have that type in a contract interface due\n    // to serialization issues.\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn complete_refund(\n        // TODO(#7771): the following makes macros crash --> try getting it work once we migrate to metaprogramming\n        // mut fee_payer_point: TokenNoteHidingPoint,\n        // mut user_point: TokenNoteHidingPoint,\n        fee_payer_point_immutable: TokenNoteHidingPoint,\n        user_point_immutable: TokenNoteHidingPoint,\n        funded_amount: Field\n    ) {\n        // TODO(#7771): nuke the following 2 lines once we have mutable args\n        let mut fee_payer_point = fee_payer_point_immutable;\n        let mut user_point = user_point_immutable;\n\n        // TODO(#7728): Remove the next line\n        let funded_amount = U128::from_integer(funded_amount);\n        let tx_fee = U128::from_integer(context.transaction_fee());\n\n        // 1. We check that user funded the fee payer contract with at least the transaction fee.\n        // TODO(#7796): we should try to prevent reverts here\n        assert(funded_amount >= tx_fee, \"funded amount not enough to cover tx fee\");\n\n        // 2. We compute the refund amount as the difference between funded amount and tx fee.\n        let refund_amount = funded_amount - tx_fee;\n\n        // 3. We add fee to the fee payer point and refund amount to the user point.\n        fee_payer_point.add_amount(tx_fee);\n        user_point.add_amount(refund_amount);\n\n        // 4. We finalize the hiding points to get the note hashes.\n        let fee_payer_note_hash = fee_payer_point.finalize();\n        let user_note_hash = user_point.finalize();\n\n        // 5. At last we emit the note hashes.\n        context.push_note_hash(fee_payer_note_hash);\n        context.push_note_hash(user_note_hash);\n        // --> Once the tx is settled user and fee recipient can add the notes to their pixies.\n    }\n\n    /// Internal ///\n\n    // docs:start:increase_public_balance\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n    // docs:end:increase_public_balance\n\n    // docs:start:reduce_total_supply\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n\n    /// Unconstrained ///\n\n    // docs:start:balance_of_private\n    unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.balance_of(owner).to_field()\n    }\n    // docs:end:balance_of_private\n\n    #[aztec(public)]\n    fn get_total_supply() -> pub Field {\n        storage.total_supply.read().to_integer()\n    }\n\n    #[aztec(public)]\n    fn get_balance_of_public(owner: AztecAddress) -> pub Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n}\n\n// docs:end:token_all","path":"/home/g/Documents/Code/aztec-tutorials/aztec-txe/contracts/token/src/main.nr"},"321":{"source":"// docs:start:token_types_all\nuse dep::aztec::{\n    note::{note_getter_options::PropertySelector, utils::compute_note_hash_for_nullify},\n    prelude::{NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator}\n};\n\nglobal TRANSPARENT_NOTE_LEN: Field = 2;\n// TRANSPARENT_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TRANSPARENT_NOTE_BYTES_LEN: Field = 2 * 32 + 64;\n\n// Transparent note represents a note that is created in the clear (public execution), but can only be spent by those\n// that know the preimage of the \"secret_hash\" (the secret). This is typically used when shielding a token balance.\n// Owner of the tokens provides a \"secret_hash\" as an argument to the public \"shield\" function and then the tokens\n// can be redeemed in private by presenting the preimage of the \"secret_hash\" (the secret).\n#[aztec(note)]\nstruct TransparentNote {\n    amount: Field,\n    secret_hash: Field,\n}\n\nstruct TransparentNoteProperties {\n    amount: PropertySelector,\n    secret_hash: PropertySelector,\n}\n\nimpl NoteInterface<TRANSPARENT_NOTE_LEN, TRANSPARENT_NOTE_BYTES_LEN> for TransparentNote {\n\n    // Custom serialization to avoid disclosing the secret field\n    fn serialize_content(self) -> [Field; TRANSPARENT_NOTE_LEN] {\n        [self.amount, self.secret_hash]\n    }\n\n    // Custom deserialization since we don't have access to the secret plaintext\n    fn deserialize_content(serialized_note: [Field; TRANSPARENT_NOTE_LEN]) -> Self {\n        TransparentNote {\n            amount: serialized_note[0],\n            secret_hash: serialized_note[1],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn compute_nullifier(self, _context: &mut PrivateContext, _note_hash_for_nullify: Field) -> Field {\n        self.compute_nullifier_without_context()\n    }\n\n    // Computing a nullifier in a transparent note is not guarded by making secret a part of the nullifier preimage (as\n    // is common in other cases) and instead is guarded by the functionality of \"redeem_shield\" function. There we do\n    // the following:\n    //      1) We pass the secret as an argument to the function and use it to compute a secret hash,\n    //      2) we fetch a note via the \"get_notes\" oracle which accepts the secret hash as an argument,\n    //      3) the \"get_notes\" oracle constrains that the secret hash in the returned note matches the one computed in\n    //         circuit. \n    // This achieves that the note can only be spent by the party that knows the secret.\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl TransparentNote {\n    // CONSTRUCTORS\n    pub fn new(amount: Field, secret_hash: Field) -> Self {\n        TransparentNote { amount, secret_hash, header: NoteHeader::empty() }\n    }\n\n    // CUSTOM FUNCTIONS FOR THIS NOTE TYPE\n    // Custom serialization forces us to manually create the metadata struct and its getter\n    pub fn properties() -> TransparentNoteProperties {\n        TransparentNoteProperties {\n            amount: PropertySelector { index: 0, offset: 0, length: 32 },\n            secret_hash: PropertySelector { index: 1, offset: 0, length: 32 }\n        }\n    }\n}\n\nimpl Eq for TransparentNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) & (self.secret_hash == other.secret_hash)\n    }\n}\n\n// docs:end:token_types_all","path":"/home/g/Documents/Code/aztec-tutorials/aztec-txe/contracts/token/src/types/transparent_note.nr"},"323":{"source":"use dep::aztec::{\n    generators::{Ga1 as G_amt, Ga2 as G_npk, Ga3 as G_rnd, G_slot},\n    prelude::{NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{\n    constants::GENERATOR_INDEX__NOTE_NULLIFIER, point::{Point, POINT_LENGTH}, scalar::Scalar,\n    hash::poseidon2_hash_with_separator, traits::Serialize\n},\n    note::utils::compute_note_hash_for_nullify, oracle::unsafe_rand::unsafe_rand,\n    keys::getters::get_nsk_app\n};\nuse dep::std::{embedded_curve_ops::multi_scalar_mul, hash::from_field_unsafe};\n\ntrait OwnedNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self;\n    fn get_amount(self) -> U128;\n}\n\nglobal TOKEN_NOTE_LEN: Field = 3; // 3 plus a header.\nglobal TOKEN_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n#[aztec(note)]\nstruct TokenNote {\n    // The amount of tokens in the note\n    amount: U128,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n\nimpl NoteInterface<TOKEN_NOTE_LEN, TOKEN_NOTE_BYTES_LEN> for TokenNote {\n    // docs:start:nullifier\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([note_hash_for_nullify, secret],GENERATOR_INDEX__NOTE_NULLIFIER)\n    }\n\n    fn compute_note_hiding_point(self) -> Point {\n        // We use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        let amount_scalar = from_field_unsafe(self.amount.to_integer());\n        let npk_m_hash_scalar = from_field_unsafe(self.npk_m_hash);\n        let randomness_scalar = from_field_unsafe(self.randomness);\n        let slot_scalar = from_field_unsafe(self.header.storage_slot);\n        // We compute the note hiding point as:\n        //     `G_amt * amount + G_npk * npk_m_hash + G_rnd * randomness + G_slot * slot`\n        // instead of using pedersen or poseidon2 because it allows us to privately add and subtract from amount\n        // in public by leveraging homomorphism.\n        multi_scalar_mul(\n            [G_amt, G_npk, G_rnd, G_slot],\n            [amount_scalar, npk_m_hash_scalar, randomness_scalar, slot_scalar]\n        )\n    }\n}\n\nimpl TokenNote {\n    // TODO: Merge this func with `compute_note_hiding_point`. I (benesjan) didn't do it in the initial PR to not have\n    // to modify macros and all the related funcs in it.\n    fn to_note_hiding_point(self) -> TokenNoteHidingPoint {\n        TokenNoteHidingPoint::new(self.compute_note_hiding_point())\n    }\n}\n\nstruct TokenNoteHidingPoint {\n  inner: Point\n}\n\nimpl TokenNoteHidingPoint {\n    fn new(point: Point) -> Self {\n        Self { inner: point }\n    }\n\n    fn add_amount(&mut self, amount: U128) {\n        self.inner = multi_scalar_mul([G_amt], [from_field_unsafe(amount.to_integer())]) + self.inner;\n    }\n\n    fn add_npk_m_hash(&mut self, npk_m_hash: Field) {\n        self.inner = multi_scalar_mul([G_npk], [from_field_unsafe(npk_m_hash)]) + self.inner;\n    }\n\n    fn add_randomness(&mut self, randomness: Field) {\n        self.inner = multi_scalar_mul([G_rnd], [from_field_unsafe(randomness)]) + self.inner;\n    }\n\n    fn add_slot(&mut self, slot: Field) {\n        self.inner = multi_scalar_mul([G_slot], [from_field_unsafe(slot)]) + self.inner;\n    }\n\n    fn finalize(self) -> Field {\n        self.inner.x\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TokenNoteHidingPoint {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Eq for TokenNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) &\n        (self.npk_m_hash == other.npk_m_hash) &\n        (self.randomness == other.randomness)\n    }\n}\n\nimpl OwnedNote for TokenNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self {\n        Self {\n            amount,\n            npk_m_hash: owner_npk_m_hash,\n            randomness: unsafe_rand(),\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn get_amount(self) -> U128 {\n        self.amount\n    }\n}","path":"/home/g/Documents/Code/aztec-tutorials/aztec-txe/contracts/token/src/types/token_note.nr"},"338":{"source":"use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::{Deserialize, Serialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n// VALUE_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal VALUE_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:value-note-def\n#[aztec(note)]\nstruct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN, VALUE_NOTE_BYTES_LEN> for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret,\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    /// The following method needed to be implemented because the note is passed as an argument to a contract function\n    /// --> the serialize method is called by aztec-nr when computing an arguments hash.\n    /// Note that when the note is about to be encrypted and emitted as a log the to_be_bytes function auto-implemented\n    /// by aztec macros is called instead.\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.npk_m_hash, self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value) &\n        (self.npk_m_hash == other.npk_m_hash) &\n        (self.randomness == other.randomness)\n    }\n}\n","path":"/home/g/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/value-note/src/value_note.nr"}}}