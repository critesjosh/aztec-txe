{"noir_version":"0.33.0+47457412d9534885d98ff5ca22e9ec4f4b72f9c4","name":"AuthRegistry","functions":[{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/+1Z247aMBC1lyQYmt1AX9sf6FtCWWDfVur1P6r2Q/oL7XP7q2XIHOVgVkjV2jtCwRKy43jmzNUOHu/6FvY/r+NS+8qdNqx51L59XusS8mpzyukvRM6bC5FzciFyFgnl9E/IKX2hY8k7ybmp6/Px5CUTi6Mn9N6dYxSj/tU+KCMGe0xkuRDhJuO9W38T5T6EU8M41eeLvkPv9Ver0RzR124w3EeaA99PNIcd8TPNTd0xVnCD0RPrvRO+sxy89/4SXeZu0AH6YYx3ou9bWldm1LXKo+s6m4/aPsvho1J5A6siu80JP+Hp0vkoRjxhYb6g8Rtai3VYMyF5pd25Id7nZ+jKiK5xx/EDuhDR4Rl7kvBZ6vj1/vc1DGvB/xXxS3lKC+86D++ObVYob+hRk24N4aeL0dVOMG7dcfPRMx8sDcl0l0Wmfv8BDmSbRTZI93Vzv/bEG/ri+SY7/mZnjP9gi799b4u/ao3tb6z/5ocx/nfj+DPO/+3K2P7duOPf2v/m+4/1+We9/9xfz78x7//W8Tf2/Wc78vyz3n/M/W+Nb/39Zf3/azPu70/r/Xfs+X89/8f+/St4uAP9qb3cLy4IL+Gd50Md6QsMF9kADXLUNG7ILixnmUzOvn6wiGRaRH4ROy3z2OlwNzzRe/ZbskERTu1S6hxkkbv9Xy8g4zkbLamHv96RTHnu1Ns1188cYbhITjS+U88T88d36lwD4jxIhPXf58kV+/nYT/lX5pADnKuo5TU0h3hcEg+JxynVzRPG48FWger2BWGVVD+fRXX7RPgd44M3sALVFjH+44a1MypWHmqj+gz5pS5W6Zjlj+mKiK6hNRXRTSM6PCOmxH6/dSx++wdoaXbJyiUAAA==","debug_symbols":"ldixbsIwEIDhd/HMkLuc72xepapQgIAiRQFBqFShvHtD24H1X6Kc7X/6tnumY79/nHfDdLrc0/bjmcbLoZuHy7ROz2WT9rdhHIfz7v04Na+Plt/392s3vcb73N3mtG09Nqmfjutf6NqfhrFPW7flc5O00qJtcCG4UFy0uDBcZFw4LgIX2LzF5obNDZsbNjdsbtjcsLlhc8Pmhs0Nm2dsnrF5xuYZm2dsnrF5xuYZm2dsnrG5Y3PH5o7NHZs7Nnds7tjcsbljc8fmgc0Dmwc2D2we2DyweWDzwOaBzQObF2xesHnB5gWbF2xesHnB5gWbF2xesHnF5hWbV2xesXnF5hWbV2xesXnF5hWbS9PwRHiiPGl5YjzJPHGeBE8KT7i+cH3h+sL1hesL1xeuL1xfuL5wfeH6yvWV6yvXV66vXF+5vnJ95fp8SSd0S7es01d3G7r92P8vDU+P6fC2Q5y/r3836+Mf","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"_set_authorized","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"approver","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"message_hash","type":{"kind":"field"},"visibility":"private"},{"name":"authorize","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/+1dy27TQBQdp3nXTZqSloYvYOk8bLcLJBDPHQsWrKvERSx4qCA+g19iC2v4IDKZuerJLQpIzOiquh4psj2x55x75s7Lc5UkxqXm+pP48xY7YqJ7Hvpj9n9pGrCsLCbP5JbwbNwSnnu3hGczBk9LsunPW4y8rcA9+P6Piaz85U+6/kEs/GEgBboMN1jZZ4uz9rqMx92bQhhvzxP/HR0TEOm5z3vOvku9gAbKTs21oE8gjzCfQl7b5z2DvI7Zxur4fJuO1p8XKNI67a8/Q39+8eXdy4/LD6vqVfV+VV0lcBs9lZjdyRZ3yIt7tFpdVZ8+4bO9fyzPpr4/toBHD3gdQFnh3GlepN4eTJwv+v4BcEqjcMqmKeDsgxaoQbiOdVEkUDbZS9eN6PhlLotfVML4c2H9F8L2nwvjX+r2v1kmi58L618Kt78i193+peu/mOoe/8T7/zPd/X850z3+lhe6+99ioXv8l57/Svf/2ud/2uffxVK4/z1X7n/S429e9/+q+/+lcvx6/iVrv/T7N+HxV3z9K73+lx7/pOdfdf8vil+eWzza//vqj3Z/bQB4Aff8ypTZSxiGaUCJeKRwfgC6IM9WMJ7ZZlwYME4DVi9Wp2EcnTZ7o3t+M3YfNGh2b+rS8nnExW5Jf0/ic9ylEWGOoL5K0K0fhVM2s3r0zHba5V994NSNw2mzp0w4PTj2gUcgrM140me20jX57dBs7/mT/ZHqJIsXQ5DNDj1v0vWA1esA7COfDKh3hhq2zE3/t7gjsD0xYfuoQ6jnBLiMAH8cRfv50vr1kdlOu9raGDjdicLJtTXCIW49pkG48TPfrJ/HzF66bkTHd/NnOXz3/lDQ/pmw/VNh/FIYP5fFd+t3Qf8Tbv9u/aC4/S90+988022/e39R+78Uvnj9S4+/0v2v9v5f+fynkG7/le7+p17/1eu/ev1Xr//E9K/Xf0Zz/YvPv1fC+ue661/7+k+7/tLzD+n5l/r3H4Xy+fel7vFP/P2zcP8zqywe7YHf95vPdn/5GPAC7nmvUmYvYRimASXikcL5GHRBnqHjl44Zp2NWL1ankzg6LTF+6Qg0oPgl1IXil4gLj1+KxXGXRoQ5gvp6ALrF8S8Xv8R//uRf/MtyOozDaYq+S9yGkIcxeH/zOXyuDdzHkfSk+CDiTTh9ph/yaUE+xs4NwK4E7sdYm9Modrj2dGK20y6/OAVOd6Nwcn5BOMStxzQI/a71lNlL143o+G6uKYfv5jqC9s+E7Z8K45fC+LksvptrCvqfcPt371oVt/+Fbv+bZ7rtd7E2tf9L4YvXv/T4K93/au//lc9/Cun2X+nuf+r1X73+q9d/9fpPTP96/Wc017/4/HslrH+uu/61r/+06y89/5Cef6l//1Eon39f6h7/xN8/C/c/LtaG9sC/+c1nu788AbzQsTZoL2EYpgEl4pHC+SnogjxDx9pMGKcJqxer0704Om3F2pyABhRrg7pQrA1x4bE2sTju0ogwR1BfD0C/NnA1oGccv3NxDYhFGIbxpzQBTnF+N8txmjAdhpBHGtnfiqLYleu/G/r84eriTfX66u3nyrDUgHMMaurAOb+P8pM/5NnU92J0ulHE2DS4LvxXVBOwyMHtocf+DyoQ/hTxqWzCovwmnP9Mru/twf9D2Xuo4Xbgh73a/hz58+ea7Lkh3NOG5zrsObqm+rT6/fD8bL39BjLp7akGcAAA","debug_symbols":"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","brillig_names":["_set_authorized"]},{"name":"is_consumable","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"on_behalf_of","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"message_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/+1dwW4bNxDlypK8qjaWFdm1k1yMfsGupJXiQwEXTdtjgfYLXEsuemhUuEnR/kF/qdfmmJyT34kp8kVPhKMECIlBMEtAWIne5XvzZsgllwNvZlxp334y/71DdWHBORf+WH5aqSK2VabkmX0mPFufCc+9iDwz4tkG2TZXkBFWoL07DOMOwA3+Tz8e+OM3NzeX/5z99nSx/Pts9fzZ2er67JfV86eLP99d+cZ/yT0is7qIJGEeWBGt7cfTx93bNr7NN8pwsfY88X/DMfOfgtTF9QW18YTqMMx8R3VdX/e9r9u//fTN5u8/+Hpg3Kc6aJ/7D/O6iKGLHwb2zUYXjrScjn3Cj+fzydRq0DPbJQt+s7/6xOmLJJzKqiCcHh1Zg3jD0nSWUduwF79byfHntSz+bCmMPxHWfyps/7kw/rXu+BuXuv0/F+5/tXT8TZr+pzn+xO+/C2H8Shh/LIx/JYxfK7//SY+/0vGvff6j/P4nPf7Mz5XHn/T9pxn/ZfGlx3/p+Yfy+c9sqrv/ia+/pJ+/Vcrtl37+2Iz/qvHn5xYPe2D/+qPdXyoIL+KeV10E9gLDBBqgFHTE9z7pwjw70Xi6begi4FQEfrE63Uuj03pvcC/f2AkN2rS/imPH14GL9efLLD3HXRoBc0j+qkm3NPFVjnl/2hCGCXga0g+c9tNwqjh2gc2xayLa/zFxO6C6DtmfyCdluhgsx4fG7YVD13uBX/tk34GJrnfJGnYI74BwD8n2iPkL6zFqYDZ+zojLIeGPkmg/ubIaD8122dXXRsTpfhJOrq8BB9x6gQbx7p/1ev40CuzF71ZyfDd/lcN3zw8F7R8L218J48+F8WtZfLd+F4w/4f7v1g+K+/9Ud/xNSt32u/2jJv6l8MX9L33/lR5/tY//yuc/M+n+v9Q9/jTrv2b916z/mvWfmP7N+s9o9r/4/HshrH+t2//a13/a9Zeef0jPv9Q//5gpn39f677/iT9/Fh5/xkuLhz3wr/zms91fPiK8iHveiyKwFxgm0AAFPAr6PiJdmGfs/KWjgNNR4Ber03Eana44f2lIGiB/iXVB/hK4hPlLqTju0giYQ/LX16Rbmvhy+Usds10+Jr4sp0EaThXHLrgNqI5zEz8Uc3xdl7iPEumJ/CDwBk4R6Md8OlR/QLz6ZFdG53OuzUkSO1x/OjbbZVdcnBCnL5NwcnEBHHDrBRrEftZ6EtiL363k+G6uKYfv5jqC9o+F7a+E8efC+LUsvptrCsafcP93z1oV9/+p7viblLrtd7k2TfxL4Yv7X/r+Kz3+ah//lc9/ZtL9f6l7/GnWf836r1n/Nes/Mf2b9Z/R7H/x+fdCWP9at/+1r/+06y89/5Cef6l//jFTPv++1n3/E3/+LDz+uFwb7IH/5zef7f7yKeHFzrVhe4FhAg1QwKOg7yekC/OMnWtzGnA6DfxidXqQRqetXJtj0gC5NqwLcm3AJcy1ScVxl0bAHJK/ONemS9ddROHj3rfzMImt2+9QMYRhAvtRHpKtafpSWVk+yGm5/Ov3H/+4Wi2WPz9b3Vz+uvxpebnICLcfcOZj9h67WlR3V05Ny9xdUvrBtvfIt9XxbSPvB5htOueFN2Z4B09uC9dBJ7R5QLY/IrtxHueMYWyGvzleWnTuaXANj22cQ7cXnG9zntb/04repxRR2/WYl/u2oS2wMMbYQy94p1Qk/Irx0TawcnrXFb6/zjbn9uhlW/YcjJ3gb/3Yxf9ey99/XTu4bkDndOm6/eA6/EafsPq98vys394Cq0ELNcdvAAA=","debug_symbols":"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","brillig_names":["is_consumable"]},{"name":"is_reject_all","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"on_behalf_of","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/+1cXW/TMBR1uqRL26xdWzaJt/IKL0mbNuwBKGLwigS/oLQZ4oEVjQ3BL+BvMze+9MwrFRK2rtCNpSoftX3OPffasWMrgarSwe0vMOcR3LMT5ZmbY/pvKXNYV+qTZ/Cf8Gw45BkAzwMiG+INMKKxwygMKqzsMVw8NMeXV1eLH6NPl6vy+2h9cz1aX4w+rG8uV19/l3xhTmJAI0ZzR/LFlhXO6n6aF83bOl7F99VTxp5z8x8dA/NLID+VT9TWE+dwj5rua3Pv8PbXVtv/31j4A7hHOsemHHKYu9DANKOmqStUdyPqEPDbgO/Ov5M8MfVjCqzrEM7bwKnlhVOaJRaOMliogbtmnc8CqJvspeuGd/xiyos/K5nxJ8z658z2nzHjX8iOv3Eq2/8Fc/ubMsdfMWb2P3f/vxBuv/DnD3f7m2XM+EvZ+OzPv4nw+JM+/hE+/uRu/8WZ8PgTPv6r+/96/CF6/J/Lbn/c83/292+ZcPu53z/W/b9o/OJM49Ea2E9z1Os+HcBzuOY1TSx7CUNZGlAiHgmct0EX5Bk541ktN3csTh3LL7Hh5UGnzdrgQbzFIQ3C+L4uEay56qTXLieBf477NCLMPvhrCrr5ia90jGvRCjCUxZNSBzg1/XDKMHYJG2NXOcT6m7jtwb0I7Pfkk9RfDKbjY1XFF+maWH5tg31HyrneKWoYAd4R4PbAdof7FzZ9VFdt/RwAlx7gD7xoP1lqrY/V3bSvrQ2AU98Lp6qtEQ5xa1kaOHx/v+lmB5a9dN3wjl+NX/nwq/eHjPaPme3PmPELZvwpL341f2eMP+b2X80fBLf/XHb8TVLZ9lfrR3X8c+Gz+5/7+cvd/0rv/4WPf2bc7b+U3f/U8796/lfP/+r5H5v+9fxPSfY/+/h7xaz/VLb/pc//pOvPPf7gHn+Jf/8xEz7+vpD9/GN//8zc/4xLjUdr4I/M4rNeXx4CnsM171Vi2UsYytKAEvFI4HwAuiBP1/uXhhanoeUXrdMDPzotcf/SMWhA+5dQF9q/RFzs/Uu+OO7TiDD74K9noFsE5eZO+FTf+zjxYmu1L6Kr7qZ9cXsCtvppS2nWAZ0X3z6//bJcr8r31+urxcfyXblYBYDbtTjjMfiDXQ24h3sOox3/Y/LpB13fKfDA/VmEGUKeJ8aY/g6eWBeVI52ozi7Yfgp2Uz7cV0p98xDKKihDeYdWGezbKA9+Jwb/23zPBb7x4lDbTZ8Xm7pJW8KKYC9ly/qmjSP8DPGpbsKi+yGcPw+2eVvwIRidh/pO4q990TTnyN8uF1rlepCnCeUOrXJ0TW1C65cbftpvvwD5bWzqm0sAAA==","debug_symbols":"5Z3NTptXFEXfxWMG9+z7z6tUVQQJiSwhE4FTqUK8e+1ig1uskq1WjVa+SSKHY+cc1mCZjbT9uPp0c/3ty4f15vPdw+ryl8fV7d3Hq+36brN79Ph0sbq+X9/err98OP3nVdr/EenP+YevV5v9w4ft1f12dZkuVjebT7u/d8/9vL69WV228vTrxSrCmpY1na3pYk1Xa7pZ092aHtb0dKZlsZTFUhZLWSxlsZTFUhZLWSxlsZTFMlsss8UyWyyzxTJbLLPFMlsss8UyWyyzxbJYLIvFslgsi8WyWCyLxbJYLIvFslgsi8WyWiyrxbJaLKvFslosq8WyWiyrxbJaLKvFslksm8WyWSybxbJZLJvFslksm8WyWSybxbJbLLvFslssu8WyWyy7xbJbLLvFslssu8VyWCyHxXJYLIfFclgsh8VyWCyHxXJYLIfFclosp8VyWiynxXJaLKfFclosp8VyWiynxTKSFxYkLy1IXlyQvLwgeYFB8hKD5EUGycsMkhcaJI+qGwF5VM0QyEyBzBjIzIHMIMhMgswoyMuCwguDQmay51H18qDwAqHwEqHwIqHwMqHwQqHwUqHwYqHwcqHIZmDrUfWioTifDRUVHZ5R1PLpky7eDM/oh9nZ+stolHlmNupxk5jjZVYjnXvdquMSs454na7t7PTxlefpK/fnK9siruyLuHIs4sq5hCvPZ7Y/3ZWxiCu1iCvzIq4si7hyEe99yr9/77P7sf44vPuxd75z59n3mm/HehqHwa76+pL1sHVHbj2QW0/i1jUhtw7k1kJunZFbF+TWFbk10o0V6caKdGNFurEh3diQbmxINzakGxvSjQ3pxoZ0Y0O6sSHd2JBu7Eg3dqQbO9KNHenGjnRjR7qxI93YkW7sSDd2pBsH0o0D6caBdONAunEg3TiQbhxINw6kGwfSjQPpxol040S6cSLdOJFunEg3TqQbJ9KNE+nGiXTjJLpRiehGJaIblYhuVCK6UYnoRiWiG5WIblQiulGJ6EYlpBsD6cZAujGQbgykGwPpxkC6MZBuDKQbA+nGQLpRSDcK6UYh3SikG4V0o5BuFNKNQrpRSDcK6caMdGNGujEj3ZiRbsxIN2akGzPSjRnpxox0Y0a6sSDdWJBuLEg3FqQb/4PenR+xNdKNyF4cIXtxhOzFEbIXR8heHCF7cYTsxRGyF0fIXhwhe3GE7MURshdHyF4cIXtxhOzFEbIXR8heHCF7cYTsxRGyF0fIXhwhe3GE7MURshdHyF4cIXtxhOzFEbIXR8heHCF7cYTsxRGyF0fIXhwhe3GE7MURshdHyF4cIXtxhOzFEbIXR8heHCF7cYTsxdF39OIMvbN1pOMH0kRk/eW/eDtdc2+H6Zrn6+fXjHMvXaWX4d0vvv55eNRSD8OjznQ6vL/0O7p0fpZLYzGXajGX5sVcWhZzaf3fL21xXL7EO8vvvhcvsycf8DXr8+4NvHsH7z7Au0/s7jkl8O4B2X3/QYN/313g3TN096fdw9+u7tdX17c3D7un7L/6bfNxu77bHB5uf//6/JXd8B8=","brillig_names":["is_reject_all"]},{"name":"unconstrained_is_consumable","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"on_behalf_of","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"message_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/+1cXW/aMBR1IIGw0lJKO2if+AnhK91LpXbdpPVl0vqwp+2BktBV20ACKm1/aL9zuPEtB4+yarN1HxxLKE6wfc4913bs5CqeyFJh+fNUPoBreqIy5+oY/V/qGGwrssnTM8jTA54FIuvjBc0IzKOj8P93cHKsjhez2fBn+26SpD/a0/tFezpu30zvJ8n8seZnlQkBmdicG5Iu1Kww1varflxatnEZrpTBVF3+iipPZapipfQbda2s7Kf/36oTqnsA10i3neVvT+Vv08Xrb9PR1/f332/SGfokEOu1UAE97Sgk1eLldLKYDUeLiySZpfM5tlDa0Kp4osUX0OKX4d3kKsFa5X9r6WM6m99NJ1grfGZLoWqNyhrsZ13pu4qGp/PxNauI0ws7nDpVwKnAcQd4GMLqelq7PpzT2KjBtSLYb8knkWx7107b3X3lN9J1V/NrFeyjsWpQ7wg1DABvD3D3wXbTt5CaWPnZAy77gN+won1vJG2ti/W0baw1gNOBFU7ZWCMc4lbRNCgYwxv0PGib7KXzgnX80z4vfjxmtr/LbH+HGf+UGX/Ai9+NmPsf8/iPR46P/77b/a8XuW1/nOb932n/c99/uedf1+d/x9c/Mff4T92ef/L9X77/y/d/+f6PTf98/ydc9j/7+jth1n/gtv9d3/+5rj/3+oN7/eX884/Y8fX32O37H/vzZ+b5p5tKPHoH/ksd5fvlQ8Az+M47qWr2EobQNKBEPKqQb4AuyDMwxjOLDTjUOB1qfpE6HdnR6SE2oKgCguqggR/+qUugrhEXGZH0wbPPcZtGhFkHf52Bbnb6Vxa/VBTr6Tn9S3Kq2eHUwb5L3Gpi3YeE+7c+h/V84N6wpCfFBxFvwtnR9EM7Ari+p/Ei3h6Ux1ibphU7svF0JNbTtn7RBE4vrXDK+gXhELeKpoHpZ61NzV46L1jHz9aafPjZWofR/i6z/R1m/FNm/AEvfrbWZOx/zOM/e9bq8Pjvu93/epHb9mexNnn/58Jn9z/3/Zd7/nV9/nd8/RNzj//U7fkn3//l+798/5fv/9j0z/d/wmX/s6+/E2b9B2773/X9n+v6c68/uNdfzj//iB1ff4/dvv+xP39mnn+yWBt6x3ymXj7L98stwDMda4P2EobQNKBEPKqQb4IuyNN0rE1L49TS/CJ1Oraj01qszRFoQLE2qAvF2hAXPdbGFsdtGhFmHfx1BvphXIYAPfH83AjP7DtVJ1Y0yOIlsL8ShtB0oXQCttoZY1FHxsFQLMx8MZ0Nb9PrdPj4gSgPKHkbjt4T5qAZJchvCreRKdhQb1t67pDD0CSTsnlgV6Da1j855EOZKyWM/rkc4lbSbCEdqE0ZhkTalcBOKofhaDTtt6A9AXWobEurg9MmhnYVtfIynEpqW4bPoRnU9mE6DVXbpC1h0fQlD5Vwnb8h/A7iU9uERdd9yH/yVmUr8J07WYamZeIv/VhSeeSv1/O1ejUoU4J6Za1eWfsMntTvWvGTfvsNIWENnupRAAA=","debug_symbols":"7d3bThtLEIXhd/E1F72quvrAq2xtRZCQyBIyEZAtbSHePWPC2E5swUjOwX+Gm0QOTXtVEekbcbH8sPhwdfnl07vl6uPN3eL8n4fF9c37i/vlzWp49fB4tri8XV5fLz+92/3nRVr/0Z6O332+WK1f3d1f3N4vztPZ4mr1Yfh7+NaPy+urxXnJj2d7x5r688HmdXO0xYGjYfF8NGJ7q1yP/54t+jEZ6niwdXs5Q/Yxbi7txwxKR4Toqs8H+3DbiyFKGhdRrOyF0DEhYry574x3OEQb76xp76chOxQid2/j9nqJyfso2/8Yyv3AWcWYRX0b21o6OKLZeHG07aYtysHT48199+b6NKTPYcg8hyFjDkOWOQxZ5zBkm8OQfQZDWprDkJrDkHN44rHjn3iU8hhGqfdXxpz42BqbB/ho329uHToTQwcxdCGGrsTQjRi6A0N7IoYWMbQRQxNFdKKIThTRiSI6UUQniuhEETNRxEwUMRNFzEQRM1HETBQxE0XMRBEzUcRMFDGIIgZRxCCKGEQRgyhiEEUMoohBFDGIIgZRxEIUsRBFLEQRC1HEQhSxEEUsRBELUcRCFLEQRaxEEStRxEoUsRJFrEQRK1HEShSxEkWsRBErUcRGFLERRWxEERtRxEYUsRFFbEQRG1HERhSxEUXsRBE7UcROFLETRexEETtRxE4UsRNF7EQRO1FEJSKJSkQTlYgoKhFVHN4RmZroohIRRiWijEpEGoe3IaYW0kYhbRTSRiFt/AmVQ38iNdJGIW0U0kYhbRTSRkPaaEgbDWkjsstGyDIbIdtshKyzEbLPRshCGyEbbYSstBGy00bIUhshW22ErLURstdGyGIbIZtthKy2EbLbRshyGyHbbYSstxGy30bIghshG26ErLgRsuNGyJIbIVtuhKy5EbLnRsiiGyGbboSsuhGy60bIshsh226ErLsRsu9GyMIbIRtvhKy8EbLzRsjSGyFbbzSh9qbZy29A+BSyOosp2yym7HOYckJ1z98wpWYxpc1iSp/FlHkWU8Yspjz+2eeXPLHVNAaotn1iHH4h8C11RaZuyNSdmLolZGohUxsytSNTZ2TqQKZG2tiQNjakjQ1pY0fa2JE2dqSNHWnjhMqjU0yNtLEjbexIGzvSxk600RLRRktEGy0RbbREtNES0UZLRBstEW20RLTREtFGS0gbhbRRSBuFtFFIGyf0Hp1iaqSNQtoopI1C2iikjYa00ZA2GtJGQ9o4offoFFMjbTSkjYa00ZA2GtJGR9roSBsdaaMjbZzQe3SKqZE2OtJGR9roSBsdaWNG2piRNmakjRlp44Teo1NMjbQxI23MSBsz0saMtDGQNgbSxkDaGEgbJ/QenWJqpI2BtDGQNgbSxkDaWJA2FqSNBWljQdo4offoFFMjbSxIGwvSxoK0sSBtrEgbK9LGirSxIm38Cb07fyI10kZkL44he3EM2YtjyF4cQ/biGLIXx5C9OIbsxTFkL44he3EM2YtjyF4cQ/biGLIXx5C9OIbsxTFkL44he3EM2YtjyF4cQ/biGLIXx5C9OIbsxXFkL44je3Ec2YvjyF4cT0QbHdmL48heHEf24jiyF8eRvTiO7MVxZC+OI3txHNmL48heHEf24jiyF8df7cWJlPRK6ogYU0dL373F/mlT9OfTpp3TLQ5d3V3j1X1nIQcPl7YZNGtnd4c+USWX8d6880NZn31aSpvlUrzZZr62v5T+tpS9pbxaGjTLpehtKftLsbel7C/F35ayv5T89yyl+mYpdtxS4rcvJefNUnq8PGf4uMDIOx/QNnzbU/YCzl7B2Rs4e+dm9wTOLkj29QdF/pjdwNkdmv1xePnfxe3y4vL66m74lvVXv6ze3y9vVs8v7////O0rw+Gv","brillig_names":["unconstrained_is_consumable"]},{"name":"set_authorized_private","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"authwit::aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"approver","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"message_hash","type":{"kind":"field"},"visibility":"private"},{"name":"authorize","type":{"kind":"boolean"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"authwit::aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"7Z3dbts6DMffJde9EKkPkn2Vg2FIt24IEKRD2x3goNi7Hzunlh1Hto8RO1Yc3mz1StHk769YIt2pH5vvz0+/f37dHX68vG0e//rY7F++bd93L4fi6mMD/vhvb7+2h/Ly7X37+r55NA+b58P34u8/D5sfu/3z5jG4Pw9nZkhCn5bIINFYKGHsUMKnsbM0YAwGrf+0Lr52HM3Rh5S9D7Yy94zR2mLSOUVjwBPjLw8bCEqkRYSUSIsIK5EWEVEip0TQKJEWEVAiLSKoRFpEbK5ECGsiHAaIIDNUkYgxFxFxVyNiRSoijny+c8QrkRaRoERaREiJtIiwEmkRESVySsSaXIkstfraS/asVkJlWaRbR8326Brnc53cRVlAV40Bhv4bgGWu9kdQ3IJq8+QkFMdVQCDeDZkvOMedsulk45VNJ5uQP5vFnpKkbDrZ8OVsnDHxDs4EGUi2QAPRnO0QG8sUUVoWaC4miZUHfVx5kMI62g5WVKTsRXJGRcpfJFCR8hcJVaT8RbIq0v8WaandnXP3LNKNtLWcV5HyFymoSPmLRCpS/iLddcfhVkS6647Djbz98fl3HASh7pp6bopUJpB/NS6G+xLIv1KVILV3wP6PCXiJnxMIQNDON/+ib9p83cryDWiieUDbfjPr8y9Fps134V29kOs3J189fqjhmVNrhcdqJnvvm6ZlnnQnefKK8owtpoDQb2oxNHY3trlhKaGIQjmDEsydQhmxD7YU6wlLZNoEQQmupZkfULVcjZZWtVyNlk61XI2WXrVcjZZrqhsz0XKpLmpYU208l5Y38toi3Gv9v0Yt77VtsUItSbst69FS+z7r0VL7Pqv5aQBaU98n+KglNk3LPN318xSObxG9gdA0LyO6fmXvLdYRWTYD5iJSAcXipSkMmC84iYOinAolKcqpUPICKOv/b+qd4X5zz1CR9GwHfigCLUAVSvG1OzEvs5V7ypY7ShOBuEOQgdMOhEIVvVBjXpK74RYng3JJckHlkuRilUuSi1MuSS5euSS5hLy5LLUHY7oylxtp4TArlyQXUS4pLmKUS5ILKJckF8yby1LrkUyw32WIXNhBk0t5AzfBDWIVnrrBBDsw9hhv0DgUK6ksCMWtBhS528sKdwm3HT5dO3wBanTb6CSe4uLpdbff735+PfkFHKb8A5JLRnBVOz802kGl49IbHAcmcwxcxcHEjYHc/bsL+ofI6CHp0+/7h8D4ITh+SPKpIibqjHAyJPFuK8QJ1NjNWyPdp3VP596Pc/+l62xo8RQXDByICONTGvk8IrrUfTNhc+I+8YGMSxcYMGep8jVjQRdXumDPsEg2oaQP9V0mFMgnFMwnFJtPKC6fUPxVQ+l7xtkwZSjn7mle9zyve5nVffrQx551YOyikT6wcNQNeudx+qy9Cf3bmf27mf37mf2Hmf3TzP75cv/dD7fiCo+FRPJT7ABjp6Cu/MH57i1+/xAYPwTHD7EjhxRX9gghOdUBjKm7FHRWiLnj0OQsDrYSlrEWFqwpBhaXf29fd9un/XNZCJbf/X34VtWFxeX7P7/++05h/C8=","brillig_names":["pack_arguments_array","call_private_function_internal","unpack_returns","pack_arguments","enqueue_public_function_call_internal"]},{"name":"set_authorized","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"message_hash","type":{"kind":"field"},"visibility":"private"},{"name":"authorize","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/+1c0W7aMBR1gECAtLS0g31GCBD2UqnSuvZx2vaw56qk0x62TlW1T9p3Dte+4nCZ2KTZuqpuLKE4xvE591zbsZOrJMal9uaX+Hzqjx2zn6jOpT8W/5dmAdsqYvJMXgjP1gvh2Y7BM4FO22HkrTBtcyCRhR99JvMXYcOXgazPGG6wtt8sVt1NG2+zfRGMt+fK/0fHBAS69mXX7L8cxKO2c2j/Cspo9ngHZV2z225v8xv6svHmd4OC+P9GPn/789v7H3cP6/pT/X1dPyZQrWe2NA8l2/oA6gZ0ZZn79jFxPuiGAXDqx+E0yxmO8VgD4BEIq0xYux04p+EzgrIe8Irkk8K2ncdpuzzxvEnXnPl1CPYdmeB6F6hhCnhHgDsC20PeuGxbx2br5wS4jAB/HEX7+Z3V+sTspkNjbQycTqNwcmONcIhbn2kQ7qa8nCfQNtlL563o+KuFLH51L2x/KWz/TBh/JYy/lMUvC+H+Jzz+qzvl43+hu//NC932V3XT/1X7X/r+Kz3/ap//la9/KunxX+uef5r9X7P/a/Z/zf5PTP9m/2c0+198/b0W1n+p2//a93/a9Zdef0ivv9Q//6iUr7/vdd//xJ8/C88/ZW3x6B34L3+075fPAC/gO+91zuwlDMM0oEQ8csiPQRfkmQbj6WIDzhinM+YXq9N5HJ2eYwPaPijjBDToZPu6pL6MuNgYhuskPsdDGhHmKfjrAnSL079c/FLP7KZ/6V+W03EcTjPsuxhfQmVDwP1bn8PrUuA+jqQnxQcRb8IZMP3QjhTKj4AXBuImUB9jbSZR7HDj6dzspkP9YgKcXkXh5PoF4RC3PtMg9LPWCbOXzlvR8d1aUw7frXUE7S+F7Z8J46+E8Zey+G6tKdj/hMe/e9aqePwvdPe/eaHbfhdr0/R/KXxx/0vff6XnX+3zv/L1TyU9/mvd80+z/2v2f83+r9n/ienf7P+MZv+Lr7/Xwvovdftf+/5Pu/7S6w/p9Zf65x+V8vX3ve77n/jzZ+H5x8Xa0DvwC//y2b5fngJe6FgbtJcwDNOAEvHIIT8BXZBn6FibKeM0ZX6xOr2Oo9NOrM05aECxNqgLxdoQFx5rE4vjIY0I8xT8dQH6UZxFF66P1+9cXANiEYZh/ClNgVMakdOU6TCCsiEcKd5j+6mmp4fH2y/158evT7VhqQV5DGrqQp7Xo/LkD2U20Qd5elkUMZ4HXObbTn3bhEUd/PmDTuy7WYHwZ4hPbRNWBt/6ovyHZFu3D1+nsnVo4BJ/G8TV9Xnkz6/rsOtGUKcL1/XYdXRO/rT63Xh+1m+/Ae1WBs2CUAAA","debug_symbols":"5d3dSltbFIbhe8mxB/MbY475461sNiW2tgRCLJpu2Ij33hWbH8XgOpC2edc6KY3OzIwhwhM8ePO4+HJ78+Pbp9Xm693D4vqfx8X67vNyu7rbDI8en64WN/er9Xr17dPLLy/S7h/p+fzD9+Vm9/Bhu7zfLq5bpKvF7ebL8L/Shud/Xa1vF9clP129OZqttv3ZbK0cD7dzh4v3vj9csvLLw/9eLWRnZzE7zJL7+7N01f3RXurxqHZPe3NWxxXVTytaS+fujeMMPZpOp6OcPX24ub+8uT6v6NNfMU9/xZj+imX6K9bpr9imv2Kf/IqWpr+ipr/i9N/d2Eff3Sjlw1ml3keWPAyS3r806uFgtNc/t93ImTdy8EYuvJErb+TGG7njRvbEG1m8kY03Mk8/5+nnPP2cp5/z9HOefs7TL/P0yzz9Mk+/zNMv8/TLPP0yT7/M0y/z9Ms8/YKnX/D0C55+wdMvePoFT7/g6Rc8/YKnX/D0Kzz9Ck+/wtOv8PQrPP0KT7/C06/w9Cs8/QpPv8rTr/L0qzz9Kk+/ytOv8vSrPP0qT7/K06/y9Gs8/RpPv8bTr/H0azz9Gk+/xtOv8fRrPP0aT7/O06/z9Os8/TpPv87Tr/P06zz9Ok+/ztOv8/RT4vGnxPNPiQegEk/A4RWBM/MMVOIhqMRTUInH4PAyvJkFdFBABwV0UEAHP5zq+RszAx0U0EEBHRTQQQEdNKCDBnTQgA4CGzACRmAErMAImIERsAMjYAhGwBKMgCkYAVswAsZgBKzBCJiDEbAHI2AQRsAijIBJGAGbMAJGYQSswgiYhRGwCyNgGEbAMoyAaRgB2zACxmEErMMImIcRsA8jYCBGwEKMgIkYARsxAkZiBKzECJiJEbATI2AoRsBSjICpGAFbMQLGYgSsxWg0F1Pz+9cTPlerzmDHNoMd+/R3HE3eTGFHzWBHm8GOPoMd8wx2jBns+NH3Ob/lvVlNhw/yrRanK2M/cwXO3IAzd97MLQFnFnBmA87swJkzcOYAzgx0sAEdbEAHG9DBDnSwAx3sQAc70MHRVNAlzgx0sAMd7EAHO9DBznPQEs9BSzwHLfEctMRz0BLPQUs8By3xHLTEc9ASz0FLQAcFdFBABwV0UEAHR3tBlzgz0EEBHRTQQQEdFNBBAzpoQAcN6KABHRztBV3izEAHDeigAR00oIMGdNCBDjrQQQc66EAHR3tBlzgz0EEHOuhABx3ooAMdzEAHM9DBDHQwAx0c7QVd4sxABzPQwQx0MAMdzEAHA+hgAB0MoIMBdHC0F3SJMwMdDKCDAXQwgA4G0MECdLAAHSxABwvQwdFe0CXODHSwAB0sQAcL0MECdLACHaxAByvQwQp08MO9mr8xM9BBYE/GgD0ZA/ZkDNiTMWBPxoA9GQP2ZAzYkzFgT8aAPRkD9mQM2JMxYE/GgD0ZA/ZkDNiTMWBPxoA9GQP2ZAzYkzFgT8aAPRkD9mQM2JNxYE/GgT0ZB/ZkHNiT8cRz0IE9GQf2ZBzYk3FgT8aBPRkH9mQc2JNxYE/GgT0ZB/ZkHNiTcWBPxkd7Mn1s5uFPUYeZh9tevcDb01HT4WNDopodT7dzV/vx5pxOUwx/Kvg1efuzk5fTZ6qVPjJ5hB2ujth9cMl7h1tp+fgbYq8OP+/Z57HnaL1mKntqJnvaTPb0meyZZ7Dn0/Dov+X9anmzvn0YnrP75o/N5+3qbrN/uP3/+6/vDId/Ag==","brillig_names":["set_authorized"]},{"name":"consume","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"on_behalf_of","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"inner_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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","brillig_names":["consume"]},{"name":"set_reject_all","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"reject","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/+1asW7bMBAlHUmWYiWKFfQ/ZNlWuhQI0KRrhw6dA1spOrQpjKB/1LWd26+raPGgh3OSJWQOAUVAEEVT9969IynROq36MukObeuxPR+pw0J9Lu25el5ZOLRV+eSpXwnPiQ+ehmT0wKDQduA8Wsi7f/acwg1k9NKR5ynDdWb77apJOhvv00MBlPXnyv5GZw3iXNu2a/ZbDrbIdq4Goa+gjWYk2Zh2x7FtK7vjAzrflVl3FLZ+8/Pbxx+bu237qf2+bXcauiUg11PFWM+gr8Ow1bl1BwvnE0E9A06pH06LHHCmgJsBD1dYmtmN4JqmSgFtCfjvKSaVsT3zY7s+U/3QJV1noK9Sw7A2HHLlXO8KNYwBLwfcU/Dd5cJvbJ2oIc4auJwC/tyL9suN8ZGWBQUYWHCuzYHTmRdO/VwjHOKWMQ3cPdTWSw22yV+6nnjHv1jJ4je3wv7Xwv4vhPEvhPHXsvh1JTz+hOd/swl8/q/CHn/LKmz/m3Yc/0HHX/r5K73+hr7+B/7+00jP/zbs9Wfc/437v3H/N+7/xPQf938q5PiLv39vhfVfhx3/0Pd/oesv/f4h/f4V/P8fTeDv37dhP//E/38WXn/q1uDRN/Bf9my+L5eA5/Cb9zZn/hKGYhpQIR451OegC/KMnfHscwNKxqlkcTE6nfvRaZ8bcGQTagrQIEoPdYltG3ExuRy/X4DjUxqdQ6woXu9AP8z5UMDVz7jr8xoQizAU40+lBE4nHjmVTIcC2kgjk5PzxtaH9LH7u93Nl/bz7ut9q1iZQP0YyMdQ5/2oXT/QRnaMGNPUixj7CZemgxgRYNEA3ydZsbw9R/gLxCfbhEXtEdT/gj4Z5PuZPjRxib9JJkpsHfnz+yJ2XwF9Erhvyu6ja4qn0e+PrZu4/QegkuwrViwAAA==","debug_symbols":"5d3BSiNBFIXhd+m1izpVdavq+irDIFGjBEIUjQOD+O6TmHQbMRhhhhn+qY2kzaX63Gy+Xp1+Hq7nl0+3F4vVzd3jcP7teVjeXc3Wi7vV5ur55Wy4fFgsl4vbi8N/D2H7R+F1/vF+ttpePq5nD+vhXDGXs2G+ut5+LHlzws1iOR/Otx8/DOdY2344x1am4XZsuCT3/XDJyofD388G6XiamKc02T5P46r7WS91GlX2I7OyMJ7rbZqNLRw712IcD7amt2krR6fHk/3w5Pq6ZOxhydTDkrmHJa2HJUsPS9Yelmw9LOkdLBlDD0v28MQTf/+JRyGPYRTcT6w5RgmfH1rD+OBa49v9ZbvQiRg6E0MbMXQhhq7E0I0Y2oGhUyCGFjE0UcREFDERRUxEERNRxEQUMRFFTEQRM1HETBQxE0XMRBEzUcRMFDETRcxEETNRxEwU0YgiGlFEI4poRBGNKKIRRTSiiEYU0YgiGlHEQhSxEEUsRBELUcRCFLEQRSxEEQtRxEIUsRBFrEQRK1HEShSxEkWsRBErUcRKFLESRaxEEStRxEYUsRFFbEQRG1HERhSxEUVsRBEbUcRGFLERRXSiiE4U0YkiOlFEJ4roRBGdKKITRXSiiE4UUYFIogLRRAUiigpEFTd3RKYmuqhAhFGBKKMCkcbNbYiphbRRSBuFtFFIG/9AhdC/SI20UUgbhbRRSBuFtDEibYxIG5FVNkJ22QhZZiNkm42QdTZC9tkIWWgjZKONkJU2QnbaCFlqI2SrjZC1NkL22ghZbCNks42Q1TZCdtsIWW4jZLuNkPU2QvbbCFlwI2TDjZAVN0J23AhZciNky42QNTdC9twIWXQjZNONkFU3QnbdCFl2I2TbjZB1N0L23QhZeCNk442QlTdCdt4IWXqjL7Te1HQidXSNw0n13S0+TlsN4wtnrMY4TR9931+aTs4hT6PRbZe9/O3spY4/uhU/kd0sjkeb2YkXG7bSxtCtxnfDr5vWbjZt3WzqvWz6hUKf/2VTdbNp7GLTl83Vj9nDYna5nO/fhnvztLo6eDnu+uf97pvN8C8=","brillig_names":["set_reject_all"]}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"AuthRegistry::_set_authorized_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AuthRegistry::_set_authorized_parameters","fields":[{"name":"approver","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"message_hash","type":{"kind":"field"}},{"name":"authorize","type":{"kind":"boolean"}}]}}]},{"kind":"struct","path":"AuthRegistry::consume_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AuthRegistry::consume_parameters","fields":[{"name":"on_behalf_of","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"inner_hash","type":{"kind":"field"}}]}},{"name":"return_type","type":{"kind":"field"}}]},{"kind":"struct","path":"AuthRegistry::set_authorized_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AuthRegistry::set_authorized_private_parameters","fields":[{"name":"approver","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"message_hash","type":{"kind":"field"}},{"name":"authorize","type":{"kind":"boolean"}}]}}]},{"kind":"struct","path":"AuthRegistry::is_reject_all_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AuthRegistry::is_reject_all_parameters","fields":[{"name":"on_behalf_of","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"return_type","type":{"kind":"boolean"}}]},{"kind":"struct","path":"AuthRegistry::set_reject_all_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AuthRegistry::set_reject_all_parameters","fields":[{"name":"reject","type":{"kind":"boolean"}}]}}]},{"kind":"struct","path":"AuthRegistry::set_authorized_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AuthRegistry::set_authorized_parameters","fields":[{"name":"message_hash","type":{"kind":"field"}},{"name":"authorize","type":{"kind":"boolean"}}]}}]},{"kind":"struct","path":"AuthRegistry::is_consumable_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AuthRegistry::is_consumable_parameters","fields":[{"name":"on_behalf_of","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"message_hash","type":{"kind":"field"}}]}},{"name":"return_type","type":{"kind":"boolean"}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"reject_all","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"approved_actions","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}}]}]}},"file_map":{"27":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\nmod sha256;\nmod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\nuse sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\ntrait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n","path":"std/hash/mod.nr"},"32":{"source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"64":{"source":"contract AuthRegistry {\n    use dep::aztec::{state_vars::{PublicMutable, Map}, protocol_types::address::AztecAddress};\n    use dep::authwit::auth::{IS_VALID_SELECTOR, compute_authwit_message_hash, assert_current_call_valid_authwit};\n\n    #[aztec(storage)]\n    struct Storage {\n      reject_all: Map<AztecAddress, PublicMutable<bool>>,\n      // on_behalf_of => authwit hash => authorized\n      approved_actions: Map<AztecAddress, Map<Field, PublicMutable<bool>>>,\n    }\n\n    /**\n     * Updates the `authorized` value for `msg_sender` for `message_hash`.\n     *\n     * @param message_hash The message hash being authorized\n     * @param authorize True if the caller is authorized to perform the message hash, false otherwise\n     */\n    #[aztec(public)]\n    fn set_authorized(message_hash: Field, authorize: bool) {\n        storage.approved_actions.at(context.msg_sender()).at(message_hash).write(authorize);\n    }\n\n    /**\n     * Updates the `reject_all` value for `msg_sender`.\n     * \n     * When `reject_all` is `true` any `consume` on `msg_sender` will revert.\n     * \n     * @param reject True if all actions should be rejected, false otherwise\n     */\n    #[aztec(public)]\n    fn set_reject_all(reject: bool) {\n        storage.reject_all.at(context.msg_sender()).write(reject);\n    }\n\n    /**\n     * Consumes an `inner_hash` on behalf of `on_behalf_of` if the caller is authorized to do so.\n     * \n     * Will revert even if the caller is authorized if `reject_all` is set to true for `on_behalf_of`.\n     * This is to support \"mass-revoke\".\n     *\n     * @param on_behalf_of The address on whose behalf the action is being consumed\n     * @param inner_hash The inner_hash of the authwit\n     * @return `IS_VALID_SELECTOR` if the action was consumed, revert otherwise\n     */\n    #[aztec(public)]\n    fn consume(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n        assert_eq(false, storage.reject_all.at(on_behalf_of).read(), \"rejecting all\");\n\n        let message_hash = compute_authwit_message_hash(\n            context.msg_sender(),\n            context.chain_id(),\n            context.version(),\n            inner_hash\n        );\n\n        let authorized = storage.approved_actions.at(on_behalf_of).at(message_hash).read();\n\n        assert_eq(true, authorized, \"unauthorized\");\n        storage.approved_actions.at(on_behalf_of).at(message_hash).write(false);\n\n        IS_VALID_SELECTOR\n    }\n\n    /**\n     * Updates a public authwit using a private authwit\n     * \n     * Useful for the case where you want someone else to insert a public authwit for you.\n     * For example, if Alice wants Bob to insert an authwit in public, such that they can execute\n     * a trade, Alice can create a private authwit, and Bob can call this function with it.\n     *\n     * @param approver The address of the approver (Alice in the example)\n     * @param message_hash The message hash to authorize\n     * @param authorize True if the message hash should be authorized, false otherwise\n     */\n    #[aztec(private)]\n    fn set_authorized_private(approver: AztecAddress, message_hash: Field, authorize: bool) {\n        assert_current_call_valid_authwit(&mut context, approver);\n        AuthRegistry::at(context.this_address())._set_authorized(approver, message_hash, authorize).enqueue(&mut context);\n    }\n\n    /**\n     * Internal function to update the `authorized` value for `approver` for `messageHash`.\n     * Used along with `set_authorized_private` to update the public authwit.\n     * \n     * @param approver The address of the approver\n     * @param message_hash The message hash being authorized\n     * @param authorize True if the caller is authorized to perform the message hash, false otherwise\n     */\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _set_authorized(approver: AztecAddress, message_hash: Field, authorize: bool) {\n        storage.approved_actions.at(approver).at(message_hash).write(authorize);\n    }\n\n    /**\n     * Fetches the `reject_all` value for `on_behalf_of`.\n     * \n     * @param on_behalf_of The address to check\n     * @return True if all actions are rejected, false otherwise\n     */\n    #[aztec(public)]\n    #[aztec(view)]\n    fn is_reject_all(on_behalf_of: AztecAddress) -> bool {\n        storage.reject_all.at(on_behalf_of).read()\n    }\n\n    /**\n     * Fetches the `authorized` value for `on_behalf_of` for `message_hash`.\n     * \n     * @param on_behalf_of The address on whose behalf the action is being consumed\n     * @param message_hash The message hash to check\n     * @return True if the caller is authorized to perform the action, false otherwise\n     */\n    #[aztec(public)]\n    #[aztec(view)]\n    fn is_consumable(on_behalf_of: AztecAddress, message_hash: Field) -> bool {\n        storage.approved_actions.at(on_behalf_of).at(message_hash).read()\n    }\n\n    unconstrained fn unconstrained_is_consumable(on_behalf_of: AztecAddress, message_hash: Field) -> pub bool {\n        storage.approved_actions.at(on_behalf_of).at(message_hash).read()\n    }\n}\n","path":"/mnt/user-data/grego/repos/aztec-txe/contracts/auth_registry_contract/src/main.nr"},"66":{"source":"use dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{\n    GENERATOR_INDEX__AUTHWIT_INNER, GENERATOR_INDEX__AUTHWIT_OUTER, GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    CANONICAL_AUTH_REGISTRY_ADDRESS\n},\n    hash::poseidon2_hash_with_separator\n};\nuse dep::aztec::{prelude::Deserialize, context::{PrivateContext, PublicContext, gas::GasOpts}, hash::hash_args_array};\nuse dep::aztec::oracle::debug_log::debug_log_format;\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties \n * (e.g. protocols or other users) to execute an action on their behalf.\n * \n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be \n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few \n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can \n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be \n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n * \n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer. \n * \n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is \n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n * \n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline \n * how this would look in private, and then in public later. \n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX). \n * `Alice` would make a `deposit` transaction, that she is executing using her account contract. \n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token` \n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to \n * convince the `Token` contract that it is allowed to do so. \n * \n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the \n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to \n * execute that call.\n * \n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her \n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n * \n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n * \n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts. \n * \n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *  \n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store \n * the messages that we have approved. \n * \n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `keccak256(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a colission and we return \n *      a success flag.\n * \n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be \n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the \n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n * \n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains. \n */\n\nglobal IS_VALID_SELECTOR = 0xabf64ad4; // 4 first bytes of keccak256(\"IS_VALID()\")\n\n/** \n * Assert that `on_behalf_of` have authorized the current call with a valid authentication witness\n * \n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the \n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n * \n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([context.msg_sender().to_field(), context.selector().to_field(), context.args_hash]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/** \n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n * \n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n * \n * @param on_behalf_of The address that have authorized the current call\n * @param inner_hash The hash of the message to authorize  \n */\npub fn assert_inner_hash_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress, inner_hash: Field) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context.static_call_private_function(\n        on_behalf_of,\n        FunctionSelector::from_signature(\"verify_private_authwit(Field)\"),\n        [inner_hash]\n    ).unpack_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allow same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/** \n * Assert that `on_behalf_of` have authorized the current call in the authentication registry\n * \n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the \n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n * \n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n * \n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub fn assert_current_call_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash(\n        [(*context).msg_sender().to_field(), (*context).selector().to_field(), (*context).get_args_hash()]\n    );\n    debug_log_format(\"inner_hash before consume {0}\", [inner_hash]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/** \n * Assert that `on_behalf_of` have authorized a speicifc `inner_hash` in the authentication registry\n * \n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the \n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n * \n * @param on_behalf_of The address that have authorized the `inner_hash`\n */\npub fn assert_inner_hash_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress, inner_hash: Field) {\n    let result: Field = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        FunctionSelector::from_signature(\"consume((Field),Field)\"),\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default()\n    ).deserialize_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness \n * \n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n * \n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N]\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash = compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n * \n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n * \n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/** \n * Computs the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n * \n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n * \n * @param on_behalf_of The address that have authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n * \n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(consumer: AztecAddress, chain_id: Field, version: Field, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        consumer.to_field(),\n        chain_id,\n        version,\n        inner_hash\n    ],\n        GENERATOR_INDEX__AUTHWIT_OUTER\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n * \n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n * \n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub fn set_authorized(context: &mut PublicContext, message_hash: Field, authorize: bool) {\n    context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        FunctionSelector::from_signature(\"set_authorized(Field,bool)\"),\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n\n/**\n * Helper function to reject all authwits\n * \n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise \n */\npub fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        FunctionSelector::from_signature(\"set_reject_all(bool)\"),\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n","path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/authwit/src/auth.nr"},"74":{"source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\ntrait CallInterface<let N: u32, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n","path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr"},"82":{"source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\nstruct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<let N: u32>(self) -> [Field; N] {\n        let unpacked: [Field; N] = unpack_returns(self.packed_returns);\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, let N: u32>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n","path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr"},"83":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n    set_public_teardown_function_call_internal\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, gas::Gas,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, public_call_stack_item::PublicCallStackItem,\n    public_call_stack_item_compressed::PublicCallStackItemCompressed, read_request::ReadRequest,\n    note_hash::NoteHash, nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() });\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = PublicCallStackItemCompressed {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty()\n        };\n\n        let call_request = PublicCallRequest { item, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = PublicCallStackItemCompressed {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty()\n        };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            item,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n","path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"84":{"source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        _contract_address: AztecAddress,\n        _function_selector: FunctionSelector,\n        _args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(_self: Self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [\n        user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n        user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<let N: u32>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N as Field)\n}\n\nunconstrained fn storage_write<let N: u32>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<let N: u32>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<let N: u32>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<let N: u32> {\n    values: [Field; N]\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n","path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"85":{"source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::{\n    execution::{get_chain_id, get_version, get_contract_address, get_block_number},\n    storage::{raw_storage_read, storage_read}\n};\n\nstruct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<let N: u32>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, let N: u32>(\n        self,\n        storage_slot: Field\n    ) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr"},"97":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash,\n    hash::{\n    pedersen_hash, compute_siloed_nullifier, sha256_to_field, pedersen_commitment,\n    poseidon2_hash_with_separator\n}\n};\n// Note: pedersen_commitment is used only as a re-export here\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = poseidon2_hash_with_separator(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = poseidon2_hash_with_separator(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        poseidon2_hash_with_separator(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x1cce4dbf69f14c44865919991ee1057922e34d7310ba237d71759aa422621ca9);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n","path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/hash.nr"},"127":{"source":"#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments_array<let N: u32>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n","path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr"},"128":{"source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; 2] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n","path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr"},"130":{"source":"use dep::protocol_types::{abis::{function_selector::FunctionSelector}, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n\nunconstrained pub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n","path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr"},"131":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\nunconstrained pub fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\nunconstrained pub fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\nunconstrained pub fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\nunconstrained pub fn get_version() -> Field {\n    get_version_oracle()\n}\n","path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/execution.nr"},"145":{"source":"#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle<let N: u32>(_returns: [Field]) -> Field {}\n\nunconstrained pub fn pack_returns(returns: [Field]) {\n    let _unused = pack_returns_oracle(returns);\n}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n\nunconstrained pub fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n","path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/returns.nr"},"146":{"source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(address: Field, storage_slot: Field, block_number: Field, length: Field) -> [Field; N] {}\n\nunconstrained pub fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field\n    )\n}\n\nunconstrained pub fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> T where T: Deserialize<N> {\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::address::AztecAddress;\n\n    use std::test::OracleMock;\n    use crate::test::mocks::mock_struct::MockStruct;\n\n    global address = AztecAddress::from_field(29);\n    global slot = 7;\n    global block_number = 17;\n\n    #[test]\n    fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n","path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/storage.nr"},"149":{"source":"use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"157":{"source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"256":{"source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc, point::Point\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"280":{"source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f);\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript = 0x2499880e2b1b831785c17286f99a0d5122fee784ce7b1c04e380c4a991da819a;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"291":{"source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n","path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"295":{"source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n","path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"309":{"source":"struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/mnt/user-data/grego/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"}}}